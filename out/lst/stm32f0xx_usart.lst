   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"stm32f0xx_usart.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.USART_DeInit,"ax",%progbits
  18              		.align	2
  19              		.global	USART_DeInit
  20              		.code	16
  21              		.thumb_func
  23              	USART_DeInit:
  24              	.LFB33:
  25              		.file 1 ".\\StdPeriphLib\\src/stm32f0xx_usart.c"
   1:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
   2:.\StdPeriphLib\src/stm32f0xx_usart.c ****   ******************************************************************************
   3:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @file    stm32f0xx_usart.c
   4:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @author  MCD Application Team
   5:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @version V1.5.0
   6:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @date    05-December-2014
   7:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief   This file provides firmware functions to manage the following 
   8:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          functionalities of the Universal synchronous asynchronous receiver
   9:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          transmitter (USART):
  10:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           + Initialization and Configuration
  11:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           + STOP Mode
  12:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           + AutoBaudRate
  13:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           + Data transfers
  14:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           + Multi-Processor Communication
  15:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           + LIN mode
  16:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           + Half-duplex mode
  17:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           + Smartcard mode
  18:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           + IrDA mode
  19:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           + RS485 mode  
  20:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           + DMA transfers management
  21:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           + Interrupts and flags management
  22:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           
  23:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *  @verbatim
  24:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
  25:.\StdPeriphLib\src/stm32f0xx_usart.c ****                        ##### How to use this driver #####
  26:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
  27:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..]
  28:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (#) Enable peripheral clock using RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE)
  29:.\StdPeriphLib\src/stm32f0xx_usart.c ****             function for USART1 or using RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE)
  30:.\StdPeriphLib\src/stm32f0xx_usart.c ****             function for USART2 and USART3.
  31:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (#) According to the USART mode, enable the GPIO clocks using 
  32:.\StdPeriphLib\src/stm32f0xx_usart.c ****             RCC_AHBPeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
  33:.\StdPeriphLib\src/stm32f0xx_usart.c ****             or and SCLK). 
  34:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (#) Peripheral's alternate function: 
  35:.\StdPeriphLib\src/stm32f0xx_usart.c ****             (++) Connect the pin to the desired peripherals' Alternate 
  36:.\StdPeriphLib\src/stm32f0xx_usart.c ****                  Function (AF) using GPIO_PinAFConfig() function.
  37:.\StdPeriphLib\src/stm32f0xx_usart.c ****             (++) Configure the desired pin in alternate function by:
  38:.\StdPeriphLib\src/stm32f0xx_usart.c ****                  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF.
  39:.\StdPeriphLib\src/stm32f0xx_usart.c ****             (++) Select the type, pull-up/pull-down and output speed via 
  40:.\StdPeriphLib\src/stm32f0xx_usart.c ****                  GPIO_PuPd, GPIO_OType and GPIO_Speed members.
  41:.\StdPeriphLib\src/stm32f0xx_usart.c ****             (++) Call GPIO_Init() function.        
  42:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (#) Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
  43:.\StdPeriphLib\src/stm32f0xx_usart.c ****             flow control and Mode(Receiver/Transmitter) using the SPI_Init()
  44:.\StdPeriphLib\src/stm32f0xx_usart.c ****             function.  
  45:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (#) For synchronous mode, enable the clock and program the polarity,
  46:.\StdPeriphLib\src/stm32f0xx_usart.c ****             phase and last bit using the USART_ClockInit() function.  
  47:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (#) Enable the NVIC and the corresponding interrupt using the function 
  48:.\StdPeriphLib\src/stm32f0xx_usart.c ****             USART_ITConfig() if you need to use interrupt mode.   
  49:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (#) When using the DMA mode: 
  50:.\StdPeriphLib\src/stm32f0xx_usart.c ****             (++) Configure the DMA using DMA_Init() function.
  51:.\StdPeriphLib\src/stm32f0xx_usart.c ****             (++) Active the needed channel Request using USART_DMACmd() function.   
  52:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (#) Enable the USART using the USART_Cmd() function.   
  53:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (#) Enable the DMA using the DMA_Cmd() function, when using DMA mode.   
  54:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..]
  55:.\StdPeriphLib\src/stm32f0xx_usart.c ****             Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
  56:.\StdPeriphLib\src/stm32f0xx_usart.c ****             for more details.
  57:.\StdPeriphLib\src/stm32f0xx_usart.c ****             
  58:.\StdPeriphLib\src/stm32f0xx_usart.c **** @endverbatim
  59:.\StdPeriphLib\src/stm32f0xx_usart.c ****        
  60:.\StdPeriphLib\src/stm32f0xx_usart.c ****   ******************************************************************************
  61:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @attention
  62:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *
  63:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  64:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *
  65:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  66:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * You may not use this file except in compliance with the License.
  67:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * You may obtain a copy of the License at:
  68:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *
  69:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  70:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *
  71:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * Unless required by applicable law or agreed to in writing, software 
  72:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  73:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  74:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * See the License for the specific language governing permissions and
  75:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * limitations under the License.
  76:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *
  77:.\StdPeriphLib\src/stm32f0xx_usart.c ****   ******************************************************************************
  78:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
  79:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
  80:.\StdPeriphLib\src/stm32f0xx_usart.c **** /* Includes ------------------------------------------------------------------*/
  81:.\StdPeriphLib\src/stm32f0xx_usart.c **** #include "stm32f0xx_usart.h"
  82:.\StdPeriphLib\src/stm32f0xx_usart.c **** #include "stm32f0xx_rcc.h"
  83:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
  84:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @addtogroup STM32F0xx_StdPeriph_Driver
  85:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
  86:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
  87:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
  88:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @defgroup USART 
  89:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief USART driver modules
  90:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
  91:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
  92:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
  93:.\StdPeriphLib\src/stm32f0xx_usart.c **** /* Private typedef -----------------------------------------------------------*/
  94:.\StdPeriphLib\src/stm32f0xx_usart.c **** /* Private define ------------------------------------------------------------*/
  95:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
  96:.\StdPeriphLib\src/stm32f0xx_usart.c **** /*!< USART CR1 register clear Mask ((~(uint32_t)0xFFFFE6F3)) */
  97:.\StdPeriphLib\src/stm32f0xx_usart.c **** #define CR1_CLEAR_MASK            ((uint32_t)(USART_CR1_M | USART_CR1_PCE | \
  98:.\StdPeriphLib\src/stm32f0xx_usart.c ****                                               USART_CR1_PS | USART_CR1_TE | \
  99:.\StdPeriphLib\src/stm32f0xx_usart.c ****                                               USART_CR1_RE))
 100:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 101:.\StdPeriphLib\src/stm32f0xx_usart.c **** /*!< USART CR2 register clock bits clear Mask ((~(uint32_t)0xFFFFF0FF)) */
 102:.\StdPeriphLib\src/stm32f0xx_usart.c **** #define CR2_CLOCK_CLEAR_MASK      ((uint32_t)(USART_CR2_CLKEN | USART_CR2_CPOL | \
 103:.\StdPeriphLib\src/stm32f0xx_usart.c ****                                               USART_CR2_CPHA | USART_CR2_LBCL))
 104:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 105:.\StdPeriphLib\src/stm32f0xx_usart.c **** /*!< USART CR3 register clear Mask ((~(uint32_t)0xFFFFFCFF)) */
 106:.\StdPeriphLib\src/stm32f0xx_usart.c **** #define CR3_CLEAR_MASK            ((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE))
 107:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 108:.\StdPeriphLib\src/stm32f0xx_usart.c **** /*!< USART Interrupts mask */
 109:.\StdPeriphLib\src/stm32f0xx_usart.c **** #define IT_MASK                   ((uint32_t)0x000000FF)
 110:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 111:.\StdPeriphLib\src/stm32f0xx_usart.c **** /* Private macro -------------------------------------------------------------*/
 112:.\StdPeriphLib\src/stm32f0xx_usart.c **** /* Private variables ---------------------------------------------------------*/
 113:.\StdPeriphLib\src/stm32f0xx_usart.c **** /* Private function prototypes -----------------------------------------------*/
 114:.\StdPeriphLib\src/stm32f0xx_usart.c **** /* Private functions ---------------------------------------------------------*/
 115:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 116:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @defgroup USART_Private_Functions
 117:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
 118:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 119:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 120:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @defgroup USART_Group1 Initialization and Configuration functions
 121:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *  @brief   Initialization and Configuration functions 
 122:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *
 123:.\StdPeriphLib\src/stm32f0xx_usart.c **** @verbatim   
 124:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
 125:.\StdPeriphLib\src/stm32f0xx_usart.c ****           ##### Initialization and Configuration functions #####
 126:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
 127:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..]
 128:.\StdPeriphLib\src/stm32f0xx_usart.c ****         This subsection provides a set of functions allowing to initialize the USART 
 129:.\StdPeriphLib\src/stm32f0xx_usart.c ****         in asynchronous and in synchronous modes.
 130:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (+) For the asynchronous mode only these parameters can be configured: 
 131:.\StdPeriphLib\src/stm32f0xx_usart.c ****           (++) Baud Rate.
 132:.\StdPeriphLib\src/stm32f0xx_usart.c ****           (++) Word Length.
 133:.\StdPeriphLib\src/stm32f0xx_usart.c ****           (++) Stop Bit.
 134:.\StdPeriphLib\src/stm32f0xx_usart.c ****           (++) Parity: If the parity is enabled, then the MSB bit of the data written
 135:.\StdPeriphLib\src/stm32f0xx_usart.c ****                in the data register is transmitted but is changed by the parity bit.
 136:.\StdPeriphLib\src/stm32f0xx_usart.c ****                Depending on the frame length defined by the M bit (8-bits or 9-bits),
 137:.\StdPeriphLib\src/stm32f0xx_usart.c ****                the possible USART frame formats are as listed in the following table:
 138:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 139:.\StdPeriphLib\src/stm32f0xx_usart.c ****    +-------------------------------------------------------------+     
 140:.\StdPeriphLib\src/stm32f0xx_usart.c ****    |   M bit |  PCE bit  |            USART frame                |
 141:.\StdPeriphLib\src/stm32f0xx_usart.c ****    |---------------------|---------------------------------------|             
 142:.\StdPeriphLib\src/stm32f0xx_usart.c ****    |    0    |    0      |    | SB | 8 bit data | STB |          |
 143:.\StdPeriphLib\src/stm32f0xx_usart.c ****    |---------|-----------|---------------------------------------|  
 144:.\StdPeriphLib\src/stm32f0xx_usart.c ****    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
 145:.\StdPeriphLib\src/stm32f0xx_usart.c ****    |---------|-----------|---------------------------------------|  
 146:.\StdPeriphLib\src/stm32f0xx_usart.c ****    |    1    |    0      |    | SB | 9 bit data | STB |          |
 147:.\StdPeriphLib\src/stm32f0xx_usart.c ****    |---------|-----------|---------------------------------------|  
 148:.\StdPeriphLib\src/stm32f0xx_usart.c ****    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
 149:.\StdPeriphLib\src/stm32f0xx_usart.c ****    +-------------------------------------------------------------+            
 150:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 151:.\StdPeriphLib\src/stm32f0xx_usart.c ****           (++) Hardware flow control.
 152:.\StdPeriphLib\src/stm32f0xx_usart.c ****           (++) Receiver/transmitter modes.
 153:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] The USART_Init() function follows the USART  asynchronous configuration 
 154:.\StdPeriphLib\src/stm32f0xx_usart.c ****          procedure(details for the procedure are available in reference manual.
 155:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (+) For the synchronous mode in addition to the asynchronous mode parameters
 156:.\StdPeriphLib\src/stm32f0xx_usart.c ****             these parameters should be also configured:
 157:.\StdPeriphLib\src/stm32f0xx_usart.c ****             (++) USART Clock Enabled.
 158:.\StdPeriphLib\src/stm32f0xx_usart.c ****             (++) USART polarity.
 159:.\StdPeriphLib\src/stm32f0xx_usart.c ****             (++) USART phase.
 160:.\StdPeriphLib\src/stm32f0xx_usart.c ****             (++) USART LastBit.
 161:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] These parameters can be configured using the USART_ClockInit() function.
 162:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 163:.\StdPeriphLib\src/stm32f0xx_usart.c **** @endverbatim
 164:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
 165:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 166:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 167:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 168:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
 169:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
 170:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
 171:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices.  
 172:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.
 173:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 174:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 175:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_DeInit(USART_TypeDef* USARTx)
 176:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
  26              		.loc 1 176 0
  27              		.cfi_startproc
  28              	.LVL0:
  29 0000 10B5     		push	{r4, lr}
  30              	.LCFI0:
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 4, -8
  33              		.cfi_offset 14, -4
 177:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 178:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 179:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 180:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (USARTx == USART1)
  34              		.loc 1 180 0
  35 0002 354B     		ldr	r3, .L10
  36 0004 9842     		cmp	r0, r3
  37 0006 0AD1     		bne	.L2
 181:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 182:.\StdPeriphLib\src/stm32f0xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
  38              		.loc 1 182 0
  39 0008 8024     		mov	r4, #128
  40 000a E401     		lsl	r4, r4, #7
  41 000c 201C     		mov	r0, r4
  42              	.LVL1:
  43 000e 0121     		mov	r1, #1
  44 0010 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  45              	.LVL2:
 183:.\StdPeriphLib\src/stm32f0xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  46              		.loc 1 183 0
  47 0014 201C     		mov	r0, r4
  48 0016 0021     		mov	r1, #0
  49 0018 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  50              	.LVL3:
  51 001c 5AE0     		b	.L1
  52              	.LVL4:
  53              	.L2:
 184:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 185:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else if (USARTx == USART2)
  54              		.loc 1 185 0
  55 001e 2F4B     		ldr	r3, .L10+4
  56 0020 9842     		cmp	r0, r3
  57 0022 0AD1     		bne	.L4
 186:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 187:.\StdPeriphLib\src/stm32f0xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
  58              		.loc 1 187 0
  59 0024 8024     		mov	r4, #128
  60 0026 A402     		lsl	r4, r4, #10
  61 0028 201C     		mov	r0, r4
  62              	.LVL5:
  63 002a 0121     		mov	r1, #1
  64 002c FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  65              	.LVL6:
 188:.\StdPeriphLib\src/stm32f0xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  66              		.loc 1 188 0
  67 0030 201C     		mov	r0, r4
  68 0032 0021     		mov	r1, #0
  69 0034 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  70              	.LVL7:
  71 0038 4CE0     		b	.L1
  72              	.LVL8:
  73              	.L4:
 189:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 190:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else if (USARTx == USART3)
  74              		.loc 1 190 0
  75 003a 294B     		ldr	r3, .L10+8
  76 003c 9842     		cmp	r0, r3
  77 003e 0AD1     		bne	.L5
 191:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 192:.\StdPeriphLib\src/stm32f0xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
  78              		.loc 1 192 0
  79 0040 8024     		mov	r4, #128
  80 0042 E402     		lsl	r4, r4, #11
  81 0044 201C     		mov	r0, r4
  82              	.LVL9:
  83 0046 0121     		mov	r1, #1
  84 0048 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  85              	.LVL10:
 193:.\StdPeriphLib\src/stm32f0xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  86              		.loc 1 193 0
  87 004c 201C     		mov	r0, r4
  88 004e 0021     		mov	r1, #0
  89 0050 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  90              	.LVL11:
  91 0054 3EE0     		b	.L1
  92              	.LVL12:
  93              	.L5:
 194:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 195:.\StdPeriphLib\src/stm32f0xx_usart.c ****     else if (USARTx == USART4)
  94              		.loc 1 195 0
  95 0056 234B     		ldr	r3, .L10+12
  96 0058 9842     		cmp	r0, r3
  97 005a 0AD1     		bne	.L6
 196:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 197:.\StdPeriphLib\src/stm32f0xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART4, ENABLE);
  98              		.loc 1 197 0
  99 005c 8024     		mov	r4, #128
 100 005e 2403     		lsl	r4, r4, #12
 101 0060 201C     		mov	r0, r4
 102              	.LVL13:
 103 0062 0121     		mov	r1, #1
 104 0064 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 105              	.LVL14:
 198:.\StdPeriphLib\src/stm32f0xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART4, DISABLE);
 106              		.loc 1 198 0
 107 0068 201C     		mov	r0, r4
 108 006a 0021     		mov	r1, #0
 109 006c FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 110              	.LVL15:
 111 0070 30E0     		b	.L1
 112              	.LVL16:
 113              	.L6:
 199:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 200:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else if (USARTx == USART5)
 114              		.loc 1 200 0
 115 0072 1D4B     		ldr	r3, .L10+16
 116 0074 9842     		cmp	r0, r3
 117 0076 0AD1     		bne	.L7
 201:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 202:.\StdPeriphLib\src/stm32f0xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART5, ENABLE);
 118              		.loc 1 202 0
 119 0078 8024     		mov	r4, #128
 120 007a 6403     		lsl	r4, r4, #13
 121 007c 201C     		mov	r0, r4
 122              	.LVL17:
 123 007e 0121     		mov	r1, #1
 124 0080 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 125              	.LVL18:
 203:.\StdPeriphLib\src/stm32f0xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART5, DISABLE);
 126              		.loc 1 203 0
 127 0084 201C     		mov	r0, r4
 128 0086 0021     		mov	r1, #0
 129 0088 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 130              	.LVL19:
 131 008c 22E0     		b	.L1
 132              	.LVL20:
 133              	.L7:
 204:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 205:.\StdPeriphLib\src/stm32f0xx_usart.c ****     else if (USARTx == USART6)
 134              		.loc 1 205 0
 135 008e 174B     		ldr	r3, .L10+20
 136 0090 9842     		cmp	r0, r3
 137 0092 08D1     		bne	.L8
 206:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 207:.\StdPeriphLib\src/stm32f0xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
 138              		.loc 1 207 0
 139 0094 2020     		mov	r0, #32
 140              	.LVL21:
 141 0096 0121     		mov	r1, #1
 142 0098 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 143              	.LVL22:
 208:.\StdPeriphLib\src/stm32f0xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 144              		.loc 1 208 0
 145 009c 2020     		mov	r0, #32
 146 009e 0021     		mov	r1, #0
 147 00a0 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 148              	.LVL23:
 149 00a4 16E0     		b	.L1
 150              	.LVL24:
 151              	.L8:
 209:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 210:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else if (USARTx == USART7)
 152              		.loc 1 210 0
 153 00a6 124B     		ldr	r3, .L10+24
 154 00a8 9842     		cmp	r0, r3
 155 00aa 08D1     		bne	.L9
 211:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 212:.\StdPeriphLib\src/stm32f0xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART7, ENABLE);
 156              		.loc 1 212 0
 157 00ac 4020     		mov	r0, #64
 158              	.LVL25:
 159 00ae 0121     		mov	r1, #1
 160 00b0 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 161              	.LVL26:
 213:.\StdPeriphLib\src/stm32f0xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART7, DISABLE);
 162              		.loc 1 213 0
 163 00b4 4020     		mov	r0, #64
 164 00b6 0021     		mov	r1, #0
 165 00b8 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 166              	.LVL27:
 167 00bc 0AE0     		b	.L1
 168              	.LVL28:
 169              	.L9:
 214:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 215:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else 
 216:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 217:.\StdPeriphLib\src/stm32f0xx_usart.c ****     if  (USARTx == USART8)
 170              		.loc 1 217 0
 171 00be 0D4B     		ldr	r3, .L10+28
 172 00c0 9842     		cmp	r0, r3
 173 00c2 07D1     		bne	.L1
 218:.\StdPeriphLib\src/stm32f0xx_usart.c ****     {
 219:.\StdPeriphLib\src/stm32f0xx_usart.c ****       RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART8, ENABLE);
 174              		.loc 1 219 0
 175 00c4 8020     		mov	r0, #128
 176              	.LVL29:
 177 00c6 0121     		mov	r1, #1
 178 00c8 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 179              	.LVL30:
 220:.\StdPeriphLib\src/stm32f0xx_usart.c ****       RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART8, DISABLE);
 180              		.loc 1 220 0
 181 00cc 8020     		mov	r0, #128
 182 00ce 0021     		mov	r1, #0
 183 00d0 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 184              	.LVL31:
 185              	.L1:
 221:.\StdPeriphLib\src/stm32f0xx_usart.c ****     }
 222:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 223:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 186              		.loc 1 223 0
 187              		@ sp needed
 188 00d4 10BD     		pop	{r4, pc}
 189              	.L11:
 190 00d6 C046     		.align	2
 191              	.L10:
 192 00d8 00380140 		.word	1073821696
 193 00dc 00440040 		.word	1073759232
 194 00e0 00480040 		.word	1073760256
 195 00e4 004C0040 		.word	1073761280
 196 00e8 00500040 		.word	1073762304
 197 00ec 00140140 		.word	1073812480
 198 00f0 00180140 		.word	1073813504
 199 00f4 001C0140 		.word	1073814528
 200              		.cfi_endproc
 201              	.LFE33:
 203              		.global	__aeabi_uidiv
 204              		.global	__aeabi_uidivmod
 205              		.section	.text.USART_Init,"ax",%progbits
 206              		.align	2
 207              		.global	USART_Init
 208              		.code	16
 209              		.thumb_func
 211              	USART_Init:
 212              	.LFB34:
 224:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 225:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 226:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Initializes the USARTx peripheral according to the specified
 227:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *         parameters in the USART_InitStruct .
 228:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
 229:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
 230:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
 231:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.    
 232:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
 233:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *         the configuration information for the specified USART peripheral.
 234:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 235:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 236:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
 237:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 213              		.loc 1 237 0
 214              		.cfi_startproc
 215              	.LVL32:
 216 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 217              	.LCFI1:
 218              		.cfi_def_cfa_offset 20
 219              		.cfi_offset 4, -20
 220              		.cfi_offset 5, -16
 221              		.cfi_offset 6, -12
 222              		.cfi_offset 7, -8
 223              		.cfi_offset 14, -4
 224 0002 8DB0     		sub	sp, sp, #52
 225              	.LCFI2:
 226              		.cfi_def_cfa_offset 72
 227 0004 041C     		mov	r4, r0
 228 0006 0D1C     		mov	r5, r1
 229              	.LVL33:
 238:.\StdPeriphLib\src/stm32f0xx_usart.c ****   uint32_t divider = 0, apbclock = 0, tmpreg = 0;
 239:.\StdPeriphLib\src/stm32f0xx_usart.c ****   RCC_ClocksTypeDef RCC_ClocksStatus;
 240:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 241:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 242:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 243:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
 244:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
 245:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
 246:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
 247:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
 248:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
 249:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 250:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Disable USART */
 251:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 230              		.loc 1 251 0
 231 0008 0368     		ldr	r3, [r0]
 232 000a 0122     		mov	r2, #1
 233 000c 9343     		bic	r3, r2
 234 000e 0360     		str	r3, [r0]
 252:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 253:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /*---------------------------- USART CR2 Configuration -----------------------*/
 254:.\StdPeriphLib\src/stm32f0xx_usart.c ****   tmpreg = USARTx->CR2;
 235              		.loc 1 254 0
 236 0010 4268     		ldr	r2, [r0, #4]
 237              	.LVL34:
 255:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Clear STOP[13:12] bits */
 256:.\StdPeriphLib\src/stm32f0xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 238              		.loc 1 256 0
 239 0012 2B4B     		ldr	r3, .L21
 240 0014 1340     		and	r3, r2
 241              	.LVL35:
 257:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 258:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
 259:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set STOP[13:12] bits according to USART_StopBits value */
 260:.\StdPeriphLib\src/stm32f0xx_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 242              		.loc 1 260 0
 243 0016 8A68     		ldr	r2, [r1, #8]
 244 0018 1343     		orr	r3, r2
 245              	.LVL36:
 261:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 262:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Write to USART CR2 */
 263:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR2 = tmpreg;
 246              		.loc 1 263 0
 247 001a 4360     		str	r3, [r0, #4]
 264:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 265:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /*---------------------------- USART CR1 Configuration -----------------------*/
 266:.\StdPeriphLib\src/stm32f0xx_usart.c ****   tmpreg = USARTx->CR1;
 248              		.loc 1 266 0
 249 001c 0268     		ldr	r2, [r0]
 250              	.LVL37:
 267:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Clear M, PCE, PS, TE and RE bits */
 268:.\StdPeriphLib\src/stm32f0xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 251              		.loc 1 268 0
 252 001e 294B     		ldr	r3, .L21+4
 253 0020 1A40     		and	r2, r3
 254              	.LVL38:
 269:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 270:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Configure the USART Word Length, Parity and mode ----------------------- */
 271:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set the M bits according to USART_WordLength value */
 272:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set PCE and PS bits according to USART_Parity value */
 273:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set TE and RE bits according to USART_Mode value */
 274:.\StdPeriphLib\src/stm32f0xx_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 255              		.loc 1 274 0
 256 0022 CB68     		ldr	r3, [r1, #12]
 257 0024 4968     		ldr	r1, [r1, #4]
 258              	.LVL39:
 259 0026 0B43     		orr	r3, r1
 260 0028 2969     		ldr	r1, [r5, #16]
 261 002a 0B43     		orr	r3, r1
 262 002c 1343     		orr	r3, r2
 263              	.LVL40:
 275:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USART_InitStruct->USART_Mode;
 276:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 277:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Write to USART CR1 */
 278:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR1 = tmpreg;
 264              		.loc 1 278 0
 265 002e 0360     		str	r3, [r0]
 279:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 280:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /*---------------------------- USART CR3 Configuration -----------------------*/  
 281:.\StdPeriphLib\src/stm32f0xx_usart.c ****   tmpreg = USARTx->CR3;
 266              		.loc 1 281 0
 267 0030 8268     		ldr	r2, [r0, #8]
 268              	.LVL41:
 282:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Clear CTSE and RTSE bits */
 283:.\StdPeriphLib\src/stm32f0xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 269              		.loc 1 283 0
 270 0032 254B     		ldr	r3, .L21+8
 271 0034 1340     		and	r3, r2
 272              	.LVL42:
 284:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 285:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Configure the USART HFC -------------------------------------------------*/
 286:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
 287:.\StdPeriphLib\src/stm32f0xx_usart.c ****   tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 273              		.loc 1 287 0
 274 0036 6A69     		ldr	r2, [r5, #20]
 275 0038 1343     		orr	r3, r2
 276              	.LVL43:
 288:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 289:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Write to USART CR3 */
 290:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR3 = tmpreg;
 277              		.loc 1 290 0
 278 003a 8360     		str	r3, [r0, #8]
 291:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 292:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /*---------------------------- USART BRR Configuration -----------------------*/
 293:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Configure the USART Baud Rate -------------------------------------------*/
 294:.\StdPeriphLib\src/stm32f0xx_usart.c ****   RCC_GetClocksFreq(&RCC_ClocksStatus);
 279              		.loc 1 294 0
 280 003c 02A8     		add	r0, sp, #8
 281              	.LVL44:
 282 003e FFF7FEFF 		bl	RCC_GetClocksFreq
 283              	.LVL45:
 295:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 296:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (USARTx == USART1)
 284              		.loc 1 296 0
 285 0042 224B     		ldr	r3, .L21+12
 286 0044 9C42     		cmp	r4, r3
 287 0046 01D1     		bne	.L13
 297:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 298:.\StdPeriphLib\src/stm32f0xx_usart.c ****     apbclock = RCC_ClocksStatus.USART1CLK_Frequency;
 288              		.loc 1 298 0
 289 0048 089E     		ldr	r6, [sp, #32]
 290              	.LVL46:
 291 004a 0AE0     		b	.L14
 292              	.LVL47:
 293              	.L13:
 299:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 300:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else if (USARTx == USART2)
 294              		.loc 1 300 0
 295 004c 204B     		ldr	r3, .L21+16
 296 004e 9C42     		cmp	r4, r3
 297 0050 01D1     		bne	.L15
 301:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 302:.\StdPeriphLib\src/stm32f0xx_usart.c ****     apbclock = RCC_ClocksStatus.USART2CLK_Frequency;
 298              		.loc 1 302 0
 299 0052 099E     		ldr	r6, [sp, #36]
 300              	.LVL48:
 301 0054 05E0     		b	.L14
 302              	.LVL49:
 303              	.L15:
 303:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 304:.\StdPeriphLib\src/stm32f0xx_usart.c ****    else if (USARTx == USART3)
 304              		.loc 1 304 0
 305 0056 1F4B     		ldr	r3, .L21+20
 306 0058 9C42     		cmp	r4, r3
 307 005a 01D1     		bne	.L16
 305:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 306:.\StdPeriphLib\src/stm32f0xx_usart.c ****     apbclock = RCC_ClocksStatus.USART3CLK_Frequency;
 308              		.loc 1 306 0
 309 005c 0A9E     		ldr	r6, [sp, #40]
 310              	.LVL50:
 311 005e 00E0     		b	.L14
 312              	.LVL51:
 313              	.L16:
 307:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 308:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
 309:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 310:.\StdPeriphLib\src/stm32f0xx_usart.c ****     apbclock = RCC_ClocksStatus.PCLK_Frequency;
 314              		.loc 1 310 0
 315 0060 049E     		ldr	r6, [sp, #16]
 316              	.LVL52:
 317              	.L14:
 311:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 312:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 313:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Determine the integer part */
 314:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 318              		.loc 1 314 0
 319 0062 2368     		ldr	r3, [r4]
 320 0064 1B04     		lsl	r3, r3, #16
 321 0066 0CD5     		bpl	.L17
 315:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 316:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* (divider * 10) computing in case Oversampling mode is 8 Samples */
 317:.\StdPeriphLib\src/stm32f0xx_usart.c ****     divider = (uint32_t)((2 * apbclock) / (USART_InitStruct->USART_BaudRate));
 322              		.loc 1 317 0
 323 0068 7600     		lsl	r6, r6, #1
 324              	.LVL53:
 325 006a 2B68     		ldr	r3, [r5]
 326 006c 301C     		mov	r0, r6
 327 006e 0193     		str	r3, [sp, #4]
 328 0070 191C     		mov	r1, r3
 329 0072 FFF7FEFF 		bl	__aeabi_uidiv
 330              	.LVL54:
 331 0076 071C     		mov	r7, r0
 332              	.LVL55:
 318:.\StdPeriphLib\src/stm32f0xx_usart.c ****     tmpreg  = (uint32_t)((2 * apbclock) % (USART_InitStruct->USART_BaudRate));
 333              		.loc 1 318 0
 334 0078 301C     		mov	r0, r6
 335              	.LVL56:
 336 007a 0199     		ldr	r1, [sp, #4]
 337 007c FFF7FEFF 		bl	__aeabi_uidivmod
 338              	.LVL57:
 339 0080 0AE0     		b	.L18
 340              	.LVL58:
 341              	.L17:
 319:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 320:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
 321:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 322:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* (divider * 10) computing in case Oversampling mode is 16 Samples */
 323:.\StdPeriphLib\src/stm32f0xx_usart.c ****     divider = (uint32_t)((apbclock) / (USART_InitStruct->USART_BaudRate));
 342              		.loc 1 323 0
 343 0082 2B68     		ldr	r3, [r5]
 344 0084 301C     		mov	r0, r6
 345 0086 0193     		str	r3, [sp, #4]
 346 0088 191C     		mov	r1, r3
 347 008a FFF7FEFF 		bl	__aeabi_uidiv
 348              	.LVL59:
 349 008e 071C     		mov	r7, r0
 350              	.LVL60:
 324:.\StdPeriphLib\src/stm32f0xx_usart.c ****     tmpreg  = (uint32_t)((apbclock) % (USART_InitStruct->USART_BaudRate));
 351              		.loc 1 324 0
 352 0090 301C     		mov	r0, r6
 353              	.LVL61:
 354 0092 0199     		ldr	r1, [sp, #4]
 355 0094 FFF7FEFF 		bl	__aeabi_uidivmod
 356              	.LVL62:
 357              	.L18:
 325:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 326:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 327:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* round the divider : if fractional part i greater than 0.5 increment divider */
 328:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
 358              		.loc 1 328 0
 359 0098 2A68     		ldr	r2, [r5]
 360 009a 5208     		lsr	r2, r2, #1
 329:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 330:.\StdPeriphLib\src/stm32f0xx_usart.c ****     divider++;
 361              		.loc 1 330 0
 362 009c 0023     		mov	r3, #0
 363 009e 9142     		cmp	r1, r2
 364 00a0 5B41     		adc	r3, r3, r3
 365 00a2 FF18     		add	r7, r7, r3
 366              	.LVL63:
 331:.\StdPeriphLib\src/stm32f0xx_usart.c ****   } 
 332:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 333:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Implement the divider in case Oversampling mode is 8 Samples */
 334:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 367              		.loc 1 334 0
 368 00a4 2368     		ldr	r3, [r4]
 369 00a6 1B04     		lsl	r3, r3, #16
 370 00a8 05D5     		bpl	.L20
 335:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 336:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* get the LSB of divider and shift it to the right by 1 bit */
 337:.\StdPeriphLib\src/stm32f0xx_usart.c ****     tmpreg = (divider & (uint16_t)0x000F) >> 1;
 371              		.loc 1 337 0
 372 00aa 3A07     		lsl	r2, r7, #28
 373 00ac 520F     		lsr	r2, r2, #29
 374              	.LVL64:
 338:.\StdPeriphLib\src/stm32f0xx_usart.c ****     
 339:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* update the divider value */
 340:.\StdPeriphLib\src/stm32f0xx_usart.c ****     divider = (divider & (uint16_t)0xFFF0) | tmpreg;
 375              		.loc 1 340 0
 376 00ae 0A4B     		ldr	r3, .L21+24
 377 00b0 3B40     		and	r3, r7
 378 00b2 1A43     		orr	r2, r3
 379              	.LVL65:
 380 00b4 171C     		mov	r7, r2
 381              	.LVL66:
 382              	.L20:
 341:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 342:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 343:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Write to USART BRR */
 344:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->BRR = (uint16_t)divider;
 383              		.loc 1 344 0
 384 00b6 BBB2     		uxth	r3, r7
 385 00b8 A381     		strh	r3, [r4, #12]
 345:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 386              		.loc 1 345 0
 387 00ba 0DB0     		add	sp, sp, #52
 388              		@ sp needed
 389              	.LVL67:
 390              	.LVL68:
 391              	.LVL69:
 392 00bc F0BD     		pop	{r4, r5, r6, r7, pc}
 393              	.L22:
 394 00be C046     		.align	2
 395              	.L21:
 396 00c0 FFCFFFFF 		.word	-12289
 397 00c4 F3E9FFFF 		.word	-5645
 398 00c8 FFFCFFFF 		.word	-769
 399 00cc 00380140 		.word	1073821696
 400 00d0 00440040 		.word	1073759232
 401 00d4 00480040 		.word	1073760256
 402 00d8 F0FF0000 		.word	65520
 403              		.cfi_endproc
 404              	.LFE34:
 406              		.section	.text.USART_StructInit,"ax",%progbits
 407              		.align	2
 408              		.global	USART_StructInit
 409              		.code	16
 410              		.thumb_func
 412              	USART_StructInit:
 413              	.LFB35:
 346:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 347:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 348:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Fills each USART_InitStruct member with its default value.
 349:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
 350:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *         which will be initialized.
 351:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 352:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 353:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
 354:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 414              		.loc 1 354 0
 415              		.cfi_startproc
 416              	.LVL70:
 355:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* USART_InitStruct members default value */
 356:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USART_InitStruct->USART_BaudRate = 9600;
 417              		.loc 1 356 0
 418 0000 9623     		mov	r3, #150
 419 0002 9B01     		lsl	r3, r3, #6
 420 0004 0360     		str	r3, [r0]
 357:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 421              		.loc 1 357 0
 422 0006 0023     		mov	r3, #0
 423 0008 4360     		str	r3, [r0, #4]
 358:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USART_InitStruct->USART_StopBits = USART_StopBits_1;
 424              		.loc 1 358 0
 425 000a 8360     		str	r3, [r0, #8]
 359:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USART_InitStruct->USART_Parity = USART_Parity_No ;
 426              		.loc 1 359 0
 427 000c C360     		str	r3, [r0, #12]
 360:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 428              		.loc 1 360 0
 429 000e 0C22     		mov	r2, #12
 430 0010 0261     		str	r2, [r0, #16]
 361:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 431              		.loc 1 361 0
 432 0012 4361     		str	r3, [r0, #20]
 362:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 433              		.loc 1 362 0
 434              		@ sp needed
 435 0014 7047     		bx	lr
 436              		.cfi_endproc
 437              	.LFE35:
 439 0016 C046     		.section	.text.USART_ClockInit,"ax",%progbits
 440              		.align	2
 441              		.global	USART_ClockInit
 442              		.code	16
 443              		.thumb_func
 445              	USART_ClockInit:
 446              	.LFB36:
 363:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 364:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 365:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Initializes the USARTx peripheral Clock according to the 
 366:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *         specified parameters in the USART_ClockInitStruct.
 367:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
 368:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
 369:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
 370:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.   
 371:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
 372:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *         structure that contains the configuration information for the specified 
 373:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *         USART peripheral.  
 374:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 375:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 376:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
 377:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 447              		.loc 1 377 0
 448              		.cfi_startproc
 449              	.LVL71:
 450 0000 10B5     		push	{r4, lr}
 451              	.LCFI3:
 452              		.cfi_def_cfa_offset 8
 453              		.cfi_offset 4, -8
 454              		.cfi_offset 14, -4
 455              	.LVL72:
 378:.\StdPeriphLib\src/stm32f0xx_usart.c ****   uint32_t tmpreg = 0;
 379:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 380:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 381:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
 382:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
 383:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
 384:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
 385:.\StdPeriphLib\src/stm32f0xx_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 386:.\StdPeriphLib\src/stm32f0xx_usart.c ****   tmpreg = USARTx->CR2;
 456              		.loc 1 386 0
 457 0002 4268     		ldr	r2, [r0, #4]
 458              	.LVL73:
 387:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Clear CLKEN, CPOL, CPHA, LBCL and SSM bits */
 388:.\StdPeriphLib\src/stm32f0xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 459              		.loc 1 388 0
 460 0004 054B     		ldr	r3, .L25
 461 0006 1A40     		and	r2, r3
 462              	.LVL74:
 389:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
 390:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set CLKEN bit according to USART_Clock value */
 391:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set CPOL bit according to USART_CPOL value */
 392:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set CPHA bit according to USART_CPHA value */
 393:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set LBCL bit according to USART_LastBit value */
 394:.\StdPeriphLib\src/stm32f0xx_usart.c ****   tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 463              		.loc 1 394 0
 464 0008 4B68     		ldr	r3, [r1, #4]
 465 000a 0C68     		ldr	r4, [r1]
 466 000c 2343     		orr	r3, r4
 467 000e 8C68     		ldr	r4, [r1, #8]
 468 0010 2343     		orr	r3, r4
 469 0012 C968     		ldr	r1, [r1, #12]
 470              	.LVL75:
 471 0014 0B43     		orr	r3, r1
 472 0016 1343     		orr	r3, r2
 473              	.LVL76:
 395:.\StdPeriphLib\src/stm32f0xx_usart.c ****                        USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit);
 396:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Write to USART CR2 */
 397:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR2 = tmpreg;
 474              		.loc 1 397 0
 475 0018 4360     		str	r3, [r0, #4]
 398:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 476              		.loc 1 398 0
 477              		@ sp needed
 478 001a 10BD     		pop	{r4, pc}
 479              	.L26:
 480              		.align	2
 481              	.L25:
 482 001c FFF0FFFF 		.word	-3841
 483              		.cfi_endproc
 484              	.LFE36:
 486              		.section	.text.USART_ClockStructInit,"ax",%progbits
 487              		.align	2
 488              		.global	USART_ClockStructInit
 489              		.code	16
 490              		.thumb_func
 492              	USART_ClockStructInit:
 493              	.LFB37:
 399:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 400:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 401:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Fills each USART_ClockInitStruct member with its default value.
 402:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
 403:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *         structure which will be initialized.
 404:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 405:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 406:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
 407:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 494              		.loc 1 407 0
 495              		.cfi_startproc
 496              	.LVL77:
 408:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* USART_ClockInitStruct members default value */
 409:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 497              		.loc 1 409 0
 498 0000 0023     		mov	r3, #0
 499 0002 0360     		str	r3, [r0]
 410:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 500              		.loc 1 410 0
 501 0004 4360     		str	r3, [r0, #4]
 411:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 502              		.loc 1 411 0
 503 0006 8360     		str	r3, [r0, #8]
 412:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 504              		.loc 1 412 0
 505 0008 C360     		str	r3, [r0, #12]
 413:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 506              		.loc 1 413 0
 507              		@ sp needed
 508 000a 7047     		bx	lr
 509              		.cfi_endproc
 510              	.LFE37:
 512              		.section	.text.USART_Cmd,"ax",%progbits
 513              		.align	2
 514              		.global	USART_Cmd
 515              		.code	16
 516              		.thumb_func
 518              	USART_Cmd:
 519              	.LFB38:
 414:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 415:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 416:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the specified USART peripheral.
 417:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
 418:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
 419:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
 420:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.    
 421:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the USARTx peripheral.
 422:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 423:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 424:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 425:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 426:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 520              		.loc 1 426 0
 521              		.cfi_startproc
 522              	.LVL78:
 427:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 428:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 429:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 430:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 431:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 523              		.loc 1 431 0
 524 0000 0029     		cmp	r1, #0
 525 0002 04D0     		beq	.L29
 432:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 433:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the selected USART by setting the UE bit in the CR1 register */
 434:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR1 |= USART_CR1_UE;
 526              		.loc 1 434 0
 527 0004 0268     		ldr	r2, [r0]
 528 0006 0123     		mov	r3, #1
 529 0008 1343     		orr	r3, r2
 530 000a 0360     		str	r3, [r0]
 531 000c 03E0     		b	.L28
 532              	.L29:
 435:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 436:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
 437:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 438:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the selected USART by clearing the UE bit in the CR1 register */
 439:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 533              		.loc 1 439 0
 534 000e 0368     		ldr	r3, [r0]
 535 0010 0122     		mov	r2, #1
 536 0012 9343     		bic	r3, r2
 537 0014 0360     		str	r3, [r0]
 538              	.L28:
 440:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 441:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 539              		.loc 1 441 0
 540              		@ sp needed
 541 0016 7047     		bx	lr
 542              		.cfi_endproc
 543              	.LFE38:
 545              		.section	.text.USART_DirectionModeCmd,"ax",%progbits
 546              		.align	2
 547              		.global	USART_DirectionModeCmd
 548              		.code	16
 549              		.thumb_func
 551              	USART_DirectionModeCmd:
 552              	.LFB39:
 442:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 443:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 444:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the USART's transmitter or receiver.
 445:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
 446:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
 447:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
 448:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
 449:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_Direction: specifies the USART direction.
 450:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be any combination of the following values:
 451:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_Mode_Tx: USART Transmitter
 452:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_Mode_Rx: USART Receiver
 453:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the USART transfer direction.
 454:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.  
 455:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 456:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 457:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_DirectionModeCmd(USART_TypeDef* USARTx, uint32_t USART_DirectionMode, FunctionalState Ne
 458:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 553              		.loc 1 458 0
 554              		.cfi_startproc
 555              	.LVL79:
 459:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 460:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 461:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_MODE(USART_DirectionMode));
 462:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 463:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 464:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 556              		.loc 1 464 0
 557 0000 002A     		cmp	r2, #0
 558 0002 03D0     		beq	.L32
 465:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 466:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the USART's transfer interface by setting the TE and/or RE bits 
 467:.\StdPeriphLib\src/stm32f0xx_usart.c ****        in the USART CR1 register */
 468:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR1 |= USART_DirectionMode;
 559              		.loc 1 468 0
 560 0004 0368     		ldr	r3, [r0]
 561 0006 1943     		orr	r1, r3
 562              	.LVL80:
 563 0008 0160     		str	r1, [r0]
 564 000a 02E0     		b	.L31
 565              	.LVL81:
 566              	.L32:
 469:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 470:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
 471:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 472:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the USART's transfer interface by clearing the TE and/or RE bits
 473:.\StdPeriphLib\src/stm32f0xx_usart.c ****        in the USART CR3 register */
 474:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR1 &= (uint32_t)~USART_DirectionMode;
 567              		.loc 1 474 0
 568 000c 0368     		ldr	r3, [r0]
 569 000e 8B43     		bic	r3, r1
 570 0010 0360     		str	r3, [r0]
 571              	.LVL82:
 572              	.L31:
 475:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 476:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 573              		.loc 1 476 0
 574              		@ sp needed
 575 0012 7047     		bx	lr
 576              		.cfi_endproc
 577              	.LFE39:
 579              		.section	.text.USART_OverSampling8Cmd,"ax",%progbits
 580              		.align	2
 581              		.global	USART_OverSampling8Cmd
 582              		.code	16
 583              		.thumb_func
 585              	USART_OverSampling8Cmd:
 586              	.LFB40:
 477:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 478:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 479:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the USART's 8x oversampling mode.
 480:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
 481:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
 482:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
 483:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
 484:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the USART 8x oversampling mode.
 485:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 486:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function has to be called before calling USART_Init() function
 487:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *         in order to have correct baudrate Divider value.
 488:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 489:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 490:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 491:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 587              		.loc 1 491 0
 588              		.cfi_startproc
 589              	.LVL83:
 492:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 493:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 494:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 495:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 496:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 590              		.loc 1 496 0
 591 0000 0029     		cmp	r1, #0
 592 0002 05D0     		beq	.L35
 497:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 498:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
 499:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR1 |= USART_CR1_OVER8;
 593              		.loc 1 499 0
 594 0004 0368     		ldr	r3, [r0]
 595 0006 8022     		mov	r2, #128
 596 0008 1202     		lsl	r2, r2, #8
 597 000a 1343     		orr	r3, r2
 598 000c 0360     		str	r3, [r0]
 599 000e 03E0     		b	.L34
 600              	.L35:
 500:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 501:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
 502:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 503:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
 504:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_OVER8);
 601              		.loc 1 504 0
 602 0010 0268     		ldr	r2, [r0]
 603 0012 024B     		ldr	r3, .L37
 604 0014 1340     		and	r3, r2
 605 0016 0360     		str	r3, [r0]
 606              	.L34:
 505:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 506:.\StdPeriphLib\src/stm32f0xx_usart.c **** }  
 607              		.loc 1 506 0
 608              		@ sp needed
 609 0018 7047     		bx	lr
 610              	.L38:
 611 001a C046     		.align	2
 612              	.L37:
 613 001c FF7FFFFF 		.word	-32769
 614              		.cfi_endproc
 615              	.LFE40:
 617              		.section	.text.USART_OneBitMethodCmd,"ax",%progbits
 618              		.align	2
 619              		.global	USART_OneBitMethodCmd
 620              		.code	16
 621              		.thumb_func
 623              	USART_OneBitMethodCmd:
 624              	.LFB41:
 507:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 508:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 509:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the USART's one bit sampling method.
 510:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
 511:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
 512:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
 513:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
 514:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the USART one bit sampling method.
 515:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 516:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function has to be called before calling USART_Cmd() function.  
 517:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 518:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 519:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 520:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 625              		.loc 1 520 0
 626              		.cfi_startproc
 627              	.LVL84:
 521:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 522:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 523:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 524:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 525:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 628              		.loc 1 525 0
 629 0000 0029     		cmp	r1, #0
 630 0002 05D0     		beq	.L40
 526:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 527:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
 528:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR3 |= USART_CR3_ONEBIT;
 631              		.loc 1 528 0
 632 0004 8368     		ldr	r3, [r0, #8]
 633 0006 8022     		mov	r2, #128
 634 0008 1201     		lsl	r2, r2, #4
 635 000a 1343     		orr	r3, r2
 636 000c 8360     		str	r3, [r0, #8]
 637 000e 03E0     		b	.L39
 638              	.L40:
 529:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 530:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
 531:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 532:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
 533:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_ONEBIT);
 639              		.loc 1 533 0
 640 0010 8268     		ldr	r2, [r0, #8]
 641 0012 024B     		ldr	r3, .L42
 642 0014 1340     		and	r3, r2
 643 0016 8360     		str	r3, [r0, #8]
 644              	.L39:
 534:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 535:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 645              		.loc 1 535 0
 646              		@ sp needed
 647 0018 7047     		bx	lr
 648              	.L43:
 649 001a C046     		.align	2
 650              	.L42:
 651 001c FFF7FFFF 		.word	-2049
 652              		.cfi_endproc
 653              	.LFE41:
 655              		.section	.text.USART_MSBFirstCmd,"ax",%progbits
 656              		.align	2
 657              		.global	USART_MSBFirstCmd
 658              		.code	16
 659              		.thumb_func
 661              	USART_MSBFirstCmd:
 662              	.LFB42:
 536:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 537:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 538:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the USART's most significant bit first 
 539:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *         transmitted/received following the start bit.
 540:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
 541:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
 542:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
 543:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
 544:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the USART most significant bit first
 545:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *         transmitted/received following the start bit.
 546:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 547:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function has to be called before calling USART_Cmd() function.  
 548:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 549:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 550:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_MSBFirstCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 551:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 663              		.loc 1 551 0
 664              		.cfi_startproc
 665              	.LVL85:
 552:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 553:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 554:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 555:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 556:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 666              		.loc 1 556 0
 667 0000 0029     		cmp	r1, #0
 668 0002 05D0     		beq	.L45
 557:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 558:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the most significant bit first transmitted/received following the 
 559:.\StdPeriphLib\src/stm32f0xx_usart.c ****        start bit by setting the MSBFIRST bit in the CR2 register */
 560:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR2 |= USART_CR2_MSBFIRST;
 669              		.loc 1 560 0
 670 0004 4368     		ldr	r3, [r0, #4]
 671 0006 8022     		mov	r2, #128
 672 0008 1203     		lsl	r2, r2, #12
 673 000a 1343     		orr	r3, r2
 674 000c 4360     		str	r3, [r0, #4]
 675 000e 03E0     		b	.L44
 676              	.L45:
 561:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 562:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
 563:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 564:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the most significant bit first transmitted/received following the 
 565:.\StdPeriphLib\src/stm32f0xx_usart.c ****        start bit by clearing the MSBFIRST bit in the CR2 register */
 566:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_MSBFIRST);
 677              		.loc 1 566 0
 678 0010 4268     		ldr	r2, [r0, #4]
 679 0012 024B     		ldr	r3, .L47
 680 0014 1340     		and	r3, r2
 681 0016 4360     		str	r3, [r0, #4]
 682              	.L44:
 567:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 568:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 683              		.loc 1 568 0
 684              		@ sp needed
 685 0018 7047     		bx	lr
 686              	.L48:
 687 001a C046     		.align	2
 688              	.L47:
 689 001c FFFFF7FF 		.word	-524289
 690              		.cfi_endproc
 691              	.LFE42:
 693              		.section	.text.USART_DataInvCmd,"ax",%progbits
 694              		.align	2
 695              		.global	USART_DataInvCmd
 696              		.code	16
 697              		.thumb_func
 699              	USART_DataInvCmd:
 700              	.LFB43:
 569:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 570:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 571:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the binary data inversion.
 572:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
 573:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
 574:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
 575:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
 576:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new defined levels for the USART data.
 577:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be:
 578:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg ENABLE: Logical data from the data register are send/received in negative
 579:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *                          logic (1=L, 0=H). The parity bit is also inverted.
 580:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg DISABLE: Logical data from the data register are send/received in positive
 581:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *                          logic (1=H, 0=L) 
 582:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function has to be called before calling USART_Cmd() function.  
 583:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 584:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 585:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_DataInvCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 586:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 701              		.loc 1 586 0
 702              		.cfi_startproc
 703              	.LVL86:
 587:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 588:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 589:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 590:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 591:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 704              		.loc 1 591 0
 705 0000 0029     		cmp	r1, #0
 706 0002 05D0     		beq	.L50
 592:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 593:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the binary data inversion feature by setting the DATAINV bit in 
 594:.\StdPeriphLib\src/stm32f0xx_usart.c ****        the CR2 register */
 595:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR2 |= USART_CR2_DATAINV;
 707              		.loc 1 595 0
 708 0004 4368     		ldr	r3, [r0, #4]
 709 0006 8022     		mov	r2, #128
 710 0008 D202     		lsl	r2, r2, #11
 711 000a 1343     		orr	r3, r2
 712 000c 4360     		str	r3, [r0, #4]
 713 000e 03E0     		b	.L49
 714              	.L50:
 596:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 597:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
 598:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 599:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the binary data inversion feature by clearing the DATAINV bit in 
 600:.\StdPeriphLib\src/stm32f0xx_usart.c ****        the CR2 register */
 601:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_DATAINV);
 715              		.loc 1 601 0
 716 0010 4268     		ldr	r2, [r0, #4]
 717 0012 024B     		ldr	r3, .L52
 718 0014 1340     		and	r3, r2
 719 0016 4360     		str	r3, [r0, #4]
 720              	.L49:
 602:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 603:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 721              		.loc 1 603 0
 722              		@ sp needed
 723 0018 7047     		bx	lr
 724              	.L53:
 725 001a C046     		.align	2
 726              	.L52:
 727 001c FFFFFBFF 		.word	-262145
 728              		.cfi_endproc
 729              	.LFE43:
 731              		.section	.text.USART_InvPinCmd,"ax",%progbits
 732              		.align	2
 733              		.global	USART_InvPinCmd
 734              		.code	16
 735              		.thumb_func
 737              	USART_InvPinCmd:
 738              	.LFB44:
 604:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 605:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 606:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the Pin(s) active level inversion.
 607:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
 608:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
 609:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
 610:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
 611:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_InvPin: specifies the USART pin(s) to invert.
 612:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be any combination of the following values:
 613:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_InvPin_Tx: USART Tx pin active level inversion.
 614:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_InvPin_Rx: USART Rx pin active level inversion.
 615:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new active level status for the USART pin(s).
 616:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be:
 617:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg ENABLE: pin(s) signal values are inverted (Vdd =0, Gnd =1).
 618:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg DISABLE: pin(s) signal works using the standard logic levels (Vdd =1, Gnd =0).
 619:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function has to be called before calling USART_Cmd() function.  
 620:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 621:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 622:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_InvPinCmd(USART_TypeDef* USARTx, uint32_t USART_InvPin, FunctionalState NewState)
 623:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 739              		.loc 1 623 0
 740              		.cfi_startproc
 741              	.LVL87:
 624:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 625:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 626:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_INVERSTION_PIN(USART_InvPin));  
 627:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 628:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 629:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 742              		.loc 1 629 0
 743 0000 002A     		cmp	r2, #0
 744 0002 03D0     		beq	.L55
 630:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 631:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the active level inversion for selected pins by setting the TXINV 
 632:.\StdPeriphLib\src/stm32f0xx_usart.c ****        and/or RXINV bits in the USART CR2 register */
 633:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR2 |= USART_InvPin;
 745              		.loc 1 633 0
 746 0004 4368     		ldr	r3, [r0, #4]
 747 0006 1943     		orr	r1, r3
 748              	.LVL88:
 749 0008 4160     		str	r1, [r0, #4]
 750 000a 02E0     		b	.L54
 751              	.LVL89:
 752              	.L55:
 634:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 635:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
 636:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 637:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the active level inversion for selected requests by clearing the 
 638:.\StdPeriphLib\src/stm32f0xx_usart.c ****        TXINV and/or RXINV bits in the USART CR2 register */
 639:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR2 &= (uint32_t)~USART_InvPin;
 753              		.loc 1 639 0
 754 000c 4368     		ldr	r3, [r0, #4]
 755 000e 8B43     		bic	r3, r1
 756 0010 4360     		str	r3, [r0, #4]
 757              	.LVL90:
 758              	.L54:
 640:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 641:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 759              		.loc 1 641 0
 760              		@ sp needed
 761 0012 7047     		bx	lr
 762              		.cfi_endproc
 763              	.LFE44:
 765              		.section	.text.USART_SWAPPinCmd,"ax",%progbits
 766              		.align	2
 767              		.global	USART_SWAPPinCmd
 768              		.code	16
 769              		.thumb_func
 771              	USART_SWAPPinCmd:
 772              	.LFB45:
 642:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 643:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 644:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the swap Tx/Rx pins.
 645:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
 646:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
 647:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
 648:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
 649:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the USARTx TX/RX pins pinout.
 650:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be:
 651:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg ENABLE: The TX and RX pins functions are swapped.
 652:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg DISABLE: TX/RX pins are used as defined in standard pinout
 653:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function has to be called before calling USART_Cmd() function.  
 654:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 655:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 656:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_SWAPPinCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 657:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 773              		.loc 1 657 0
 774              		.cfi_startproc
 775              	.LVL91:
 658:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 659:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 660:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 661:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 662:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 776              		.loc 1 662 0
 777 0000 0029     		cmp	r1, #0
 778 0002 05D0     		beq	.L58
 663:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 664:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the SWAP feature by setting the SWAP bit in the CR2 register */
 665:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR2 |= USART_CR2_SWAP;
 779              		.loc 1 665 0
 780 0004 4368     		ldr	r3, [r0, #4]
 781 0006 8022     		mov	r2, #128
 782 0008 1202     		lsl	r2, r2, #8
 783 000a 1343     		orr	r3, r2
 784 000c 4360     		str	r3, [r0, #4]
 785 000e 03E0     		b	.L57
 786              	.L58:
 666:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 667:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
 668:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 669:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the SWAP feature by clearing the SWAP bit in the CR2 register */
 670:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_SWAP);
 787              		.loc 1 670 0
 788 0010 4268     		ldr	r2, [r0, #4]
 789 0012 024B     		ldr	r3, .L60
 790 0014 1340     		and	r3, r2
 791 0016 4360     		str	r3, [r0, #4]
 792              	.L57:
 671:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 672:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 793              		.loc 1 672 0
 794              		@ sp needed
 795 0018 7047     		bx	lr
 796              	.L61:
 797 001a C046     		.align	2
 798              	.L60:
 799 001c FF7FFFFF 		.word	-32769
 800              		.cfi_endproc
 801              	.LFE45:
 803              		.section	.text.USART_ReceiverTimeOutCmd,"ax",%progbits
 804              		.align	2
 805              		.global	USART_ReceiverTimeOutCmd
 806              		.code	16
 807              		.thumb_func
 809              	USART_ReceiverTimeOutCmd:
 810              	.LFB46:
 673:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 674:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 675:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the receiver Time Out feature.
 676:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
 677:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
 678:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices.  
 679:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the USARTx receiver Time Out.
 680:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 681:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 682:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 683:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_ReceiverTimeOutCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 684:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 811              		.loc 1 684 0
 812              		.cfi_startproc
 813              	.LVL92:
 685:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 686:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 687:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 688:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 689:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 814              		.loc 1 689 0
 815 0000 0029     		cmp	r1, #0
 816 0002 05D0     		beq	.L63
 690:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 691:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the receiver time out feature by setting the RTOEN bit in the CR2 
 692:.\StdPeriphLib\src/stm32f0xx_usart.c ****        register */
 693:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR2 |= USART_CR2_RTOEN;
 817              		.loc 1 693 0
 818 0004 4368     		ldr	r3, [r0, #4]
 819 0006 8022     		mov	r2, #128
 820 0008 1204     		lsl	r2, r2, #16
 821 000a 1343     		orr	r3, r2
 822 000c 4360     		str	r3, [r0, #4]
 823 000e 03E0     		b	.L62
 824              	.L63:
 694:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 695:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
 696:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 697:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the receiver time out feature by clearing the RTOEN bit in the CR2 
 698:.\StdPeriphLib\src/stm32f0xx_usart.c ****        register */
 699:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_RTOEN);
 825              		.loc 1 699 0
 826 0010 4268     		ldr	r2, [r0, #4]
 827 0012 024B     		ldr	r3, .L65
 828 0014 1340     		and	r3, r2
 829 0016 4360     		str	r3, [r0, #4]
 830              	.L62:
 700:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 701:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 831              		.loc 1 701 0
 832              		@ sp needed
 833 0018 7047     		bx	lr
 834              	.L66:
 835 001a C046     		.align	2
 836              	.L65:
 837 001c FFFF7FFF 		.word	-8388609
 838              		.cfi_endproc
 839              	.LFE46:
 841              		.section	.text.USART_SetReceiverTimeOut,"ax",%progbits
 842              		.align	2
 843              		.global	USART_SetReceiverTimeOut
 844              		.code	16
 845              		.thumb_func
 847              	USART_SetReceiverTimeOut:
 848              	.LFB47:
 702:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 703:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 704:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Sets the receiver Time Out value.
 705:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
 706:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
 707:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices.   
 708:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_ReceiverTimeOut: specifies the Receiver Time Out value.
 709:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 710:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 711:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_SetReceiverTimeOut(USART_TypeDef* USARTx, uint32_t USART_ReceiverTimeOut)
 712:.\StdPeriphLib\src/stm32f0xx_usart.c **** {    
 849              		.loc 1 712 0
 850              		.cfi_startproc
 851              	.LVL93:
 713:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 714:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 715:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_TIMEOUT(USART_ReceiverTimeOut));
 716:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 717:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Clear the receiver Time Out value by clearing the RTO[23:0] bits in the RTOR
 718:.\StdPeriphLib\src/stm32f0xx_usart.c ****      register  */
 719:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_RTO);
 852              		.loc 1 719 0
 853 0000 4369     		ldr	r3, [r0, #20]
 854 0002 1B0E     		lsr	r3, r3, #24
 855 0004 1B06     		lsl	r3, r3, #24
 856 0006 4361     		str	r3, [r0, #20]
 720:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set the receiver Time Out value by setting the RTO[23:0] bits in the RTOR
 721:.\StdPeriphLib\src/stm32f0xx_usart.c ****      register  */
 722:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->RTOR |= USART_ReceiverTimeOut;
 857              		.loc 1 722 0
 858 0008 4369     		ldr	r3, [r0, #20]
 859 000a 1943     		orr	r1, r3
 860              	.LVL94:
 861 000c 4161     		str	r1, [r0, #20]
 723:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 862              		.loc 1 723 0
 863              		@ sp needed
 864 000e 7047     		bx	lr
 865              		.cfi_endproc
 866              	.LFE47:
 868              		.section	.text.USART_SetPrescaler,"ax",%progbits
 869              		.align	2
 870              		.global	USART_SetPrescaler
 871              		.code	16
 872              		.thumb_func
 874              	USART_SetPrescaler:
 875              	.LFB48:
 724:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 725:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 726:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Sets the system clock prescaler.
 727:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function is not available for STM32F030 devices.    
 728:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
 729:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
 730:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices. 
 731:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_Prescaler: specifies the prescaler clock.
 732:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function has to be called before calling USART_Cmd() function.    
 733:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 734:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 735:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
 736:.\StdPeriphLib\src/stm32f0xx_usart.c **** { 
 876              		.loc 1 736 0
 877              		.cfi_startproc
 878              	.LVL95:
 737:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 738:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 739:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 740:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Clear the USART prescaler */
 741:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->GTPR &= USART_GTPR_GT;
 879              		.loc 1 741 0
 880 0000 038A     		ldrh	r3, [r0, #16]
 881 0002 FF22     		mov	r2, #255
 882 0004 9343     		bic	r3, r2
 883 0006 0382     		strh	r3, [r0, #16]
 742:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set the USART prescaler */
 743:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->GTPR |= USART_Prescaler;
 884              		.loc 1 743 0
 885 0008 038A     		ldrh	r3, [r0, #16]
 886 000a 1943     		orr	r1, r3
 887              	.LVL96:
 888 000c 0182     		strh	r1, [r0, #16]
 744:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 889              		.loc 1 744 0
 890              		@ sp needed
 891 000e 7047     		bx	lr
 892              		.cfi_endproc
 893              	.LFE48:
 895              		.section	.text.USART_STOPModeCmd,"ax",%progbits
 896              		.align	2
 897              		.global	USART_STOPModeCmd
 898              		.code	16
 899              		.thumb_func
 901              	USART_STOPModeCmd:
 902              	.LFB49:
 745:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 746:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 747:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @}
 748:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 749:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 750:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 751:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @defgroup USART_Group2 STOP Mode functions
 752:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *  @brief   STOP Mode functions
 753:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *
 754:.\StdPeriphLib\src/stm32f0xx_usart.c **** @verbatim
 755:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
 756:.\StdPeriphLib\src/stm32f0xx_usart.c ****                         ##### STOP Mode functions #####
 757:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
 758:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] This subsection provides a set of functions allowing to manage 
 759:.\StdPeriphLib\src/stm32f0xx_usart.c ****          WakeUp from STOP mode.
 760:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 761:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] The USART is able to WakeUp from Stop Mode if USART clock is set to HSI
 762:.\StdPeriphLib\src/stm32f0xx_usart.c ****          or LSI.
 763:.\StdPeriphLib\src/stm32f0xx_usart.c ****          
 764:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] The WakeUp source is configured by calling USART_StopModeWakeUpSourceConfig()
 765:.\StdPeriphLib\src/stm32f0xx_usart.c ****          function.
 766:.\StdPeriphLib\src/stm32f0xx_usart.c ****          
 767:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] After configuring the source of WakeUp and before entering in Stop Mode 
 768:.\StdPeriphLib\src/stm32f0xx_usart.c ****          USART_STOPModeCmd() function should be called to allow USART WakeUp.
 769:.\StdPeriphLib\src/stm32f0xx_usart.c ****                            
 770:.\StdPeriphLib\src/stm32f0xx_usart.c **** @endverbatim
 771:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
 772:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 773:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 774:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 775:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the specified USART peripheral in STOP Mode.
 776:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1 or 2 or 3  to select the USART peripheral.
 777:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices.  
 778:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices.   
 779:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the USARTx peripheral state in stop mode.
 780:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 781:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function has to be called when USART clock is set to HSI or LSE. 
 782:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 783:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 784:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_STOPModeCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 785:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 903              		.loc 1 785 0
 904              		.cfi_startproc
 905              	.LVL97:
 786:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 787:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 788:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 789:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 790:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 906              		.loc 1 790 0
 907 0000 0029     		cmp	r1, #0
 908 0002 04D0     		beq	.L70
 791:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 792:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the selected USART in STOP mode by setting the UESM bit in the CR1
 793:.\StdPeriphLib\src/stm32f0xx_usart.c ****        register */
 794:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR1 |= USART_CR1_UESM;
 909              		.loc 1 794 0
 910 0004 0268     		ldr	r2, [r0]
 911 0006 0223     		mov	r3, #2
 912 0008 1343     		orr	r3, r2
 913 000a 0360     		str	r3, [r0]
 914 000c 03E0     		b	.L69
 915              	.L70:
 795:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 796:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
 797:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 798:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the selected USART in STOP mode by clearing the UE bit in the CR1
 799:.\StdPeriphLib\src/stm32f0xx_usart.c ****        register */
 800:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UESM);
 916              		.loc 1 800 0
 917 000e 0368     		ldr	r3, [r0]
 918 0010 0222     		mov	r2, #2
 919 0012 9343     		bic	r3, r2
 920 0014 0360     		str	r3, [r0]
 921              	.L69:
 801:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 802:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 922              		.loc 1 802 0
 923              		@ sp needed
 924 0016 7047     		bx	lr
 925              		.cfi_endproc
 926              	.LFE49:
 928              		.section	.text.USART_StopModeWakeUpSourceConfig,"ax",%progbits
 929              		.align	2
 930              		.global	USART_StopModeWakeUpSourceConfig
 931              		.code	16
 932              		.thumb_func
 934              	USART_StopModeWakeUpSourceConfig:
 935              	.LFB50:
 803:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 804:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 805:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Selects the USART WakeUp method form stop mode.
 806:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function is not available for STM32F030 devices.   
 807:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1 or 2 or 3 to select the USART peripheral.
 808:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
 809:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices.     
 810:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_WakeUp: specifies the selected USART wakeup method.
 811:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be one of the following values:
 812:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_WakeUpSource_AddressMatch: WUF active on address match.
 813:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_WakeUpSource_StartBit: WUF active on Start bit detection.
 814:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_WakeUpSource_RXNE: WUF active on RXNE.
 815:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function has to be called before calling USART_Cmd() function.   
 816:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 817:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 818:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_StopModeWakeUpSourceConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUpSource)
 819:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 936              		.loc 1 819 0
 937              		.cfi_startproc
 938              	.LVL98:
 820:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 821:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 822:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_STOPMODE_WAKEUPSOURCE(USART_WakeUpSource));
 823:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 824:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_WUS);
 939              		.loc 1 824 0
 940 0000 8268     		ldr	r2, [r0, #8]
 941 0002 034B     		ldr	r3, .L73
 942 0004 1340     		and	r3, r2
 943 0006 8360     		str	r3, [r0, #8]
 825:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR3 |= USART_WakeUpSource;
 944              		.loc 1 825 0
 945 0008 8368     		ldr	r3, [r0, #8]
 946 000a 1943     		orr	r1, r3
 947              	.LVL99:
 948 000c 8160     		str	r1, [r0, #8]
 826:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 949              		.loc 1 826 0
 950              		@ sp needed
 951 000e 7047     		bx	lr
 952              	.L74:
 953              		.align	2
 954              	.L73:
 955 0010 FFFFCFFF 		.word	-3145729
 956              		.cfi_endproc
 957              	.LFE50:
 959              		.section	.text.USART_AutoBaudRateCmd,"ax",%progbits
 960              		.align	2
 961              		.global	USART_AutoBaudRateCmd
 962              		.code	16
 963              		.thumb_func
 965              	USART_AutoBaudRateCmd:
 966              	.LFB51:
 827:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 828:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 829:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @}
 830:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 831:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 832:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 833:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @defgroup USART_Group3 AutoBaudRate functions
 834:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *  @brief   AutoBaudRate functions 
 835:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *
 836:.\StdPeriphLib\src/stm32f0xx_usart.c **** @verbatim
 837:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
 838:.\StdPeriphLib\src/stm32f0xx_usart.c ****                        ##### AutoBaudRate functions #####
 839:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
 840:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] This subsection provides a set of functions allowing to manage 
 841:.\StdPeriphLib\src/stm32f0xx_usart.c ****          the AutoBaudRate detections.
 842:.\StdPeriphLib\src/stm32f0xx_usart.c ****          
 843:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] Before Enabling AutoBaudRate detection using USART_AutoBaudRateCmd ()
 844:.\StdPeriphLib\src/stm32f0xx_usart.c ****          The character patterns used to calculate baudrate must be chosen by calling 
 845:.\StdPeriphLib\src/stm32f0xx_usart.c ****          USART_AutoBaudRateConfig() function. These function take as parameter :
 846:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (#)USART_AutoBaudRate_StartBit : any character starting with a bit 1.
 847:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (#)USART_AutoBaudRate_FallingEdge : any character starting with a 10xx bit pattern. 
 848:.\StdPeriphLib\src/stm32f0xx_usart.c ****                           
 849:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] At any later time, another request for AutoBaudRate detection can be performed
 850:.\StdPeriphLib\src/stm32f0xx_usart.c ****          using USART_RequestCmd() function.
 851:.\StdPeriphLib\src/stm32f0xx_usart.c ****          
 852:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] The AutoBaudRate detection is monitored by the status of ABRF flag which indicate
 853:.\StdPeriphLib\src/stm32f0xx_usart.c ****          that the AutoBaudRate detection is completed. In addition to ABRF flag, the ABRE flag
 854:.\StdPeriphLib\src/stm32f0xx_usart.c ****          indicate that this procedure is completed without success. USART_GetFlagStatus () 
 855:.\StdPeriphLib\src/stm32f0xx_usart.c ****          function should be used to monitor the status of these flags.  
 856:.\StdPeriphLib\src/stm32f0xx_usart.c ****              
 857:.\StdPeriphLib\src/stm32f0xx_usart.c **** @endverbatim
 858:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
 859:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 860:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 861:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 862:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the Auto Baud Rate.
 863:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1or 2  to select the USART peripheral.
 864:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
 865:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices.  
 866:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the USARTx auto baud rate.
 867:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 868:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 869:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 870:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_AutoBaudRateCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 871:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 967              		.loc 1 871 0
 968              		.cfi_startproc
 969              	.LVL100:
 872:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 873:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 874:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 875:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 876:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 970              		.loc 1 876 0
 971 0000 0029     		cmp	r1, #0
 972 0002 05D0     		beq	.L76
 877:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 878:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the auto baud rate feature by setting the ABREN bit in the CR2 
 879:.\StdPeriphLib\src/stm32f0xx_usart.c ****        register */
 880:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR2 |= USART_CR2_ABREN;
 973              		.loc 1 880 0
 974 0004 4368     		ldr	r3, [r0, #4]
 975 0006 8022     		mov	r2, #128
 976 0008 5203     		lsl	r2, r2, #13
 977 000a 1343     		orr	r3, r2
 978 000c 4360     		str	r3, [r0, #4]
 979 000e 03E0     		b	.L75
 980              	.L76:
 881:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 882:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
 883:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 884:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the auto baud rate feature by clearing the ABREN bit in the CR2 
 885:.\StdPeriphLib\src/stm32f0xx_usart.c ****        register */
 886:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABREN);
 981              		.loc 1 886 0
 982 0010 4268     		ldr	r2, [r0, #4]
 983 0012 024B     		ldr	r3, .L78
 984 0014 1340     		and	r3, r2
 985 0016 4360     		str	r3, [r0, #4]
 986              	.L75:
 887:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 888:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 987              		.loc 1 888 0
 988              		@ sp needed
 989 0018 7047     		bx	lr
 990              	.L79:
 991 001a C046     		.align	2
 992              	.L78:
 993 001c FFFFEFFF 		.word	-1048577
 994              		.cfi_endproc
 995              	.LFE51:
 997              		.section	.text.USART_AutoBaudRateConfig,"ax",%progbits
 998              		.align	2
 999              		.global	USART_AutoBaudRateConfig
 1000              		.code	16
 1001              		.thumb_func
 1003              	USART_AutoBaudRateConfig:
 1004              	.LFB52:
 889:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 890:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 891:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Selects the USART auto baud rate method.
 892:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1or 2  to select the USART peripheral.
 893:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
 894:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices.  
 895:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_AutoBaudRate: specifies the selected USART auto baud rate method.
 896:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be one of the following values:
 897:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_AutoBaudRate_StartBit: Start Bit duration measurement.
 898:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_AutoBaudRate_FallingEdge: Falling edge to falling edge measurement.
 899:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function has to be called before calling USART_Cmd() function.  
 900:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 901:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 902:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_AutoBaudRateConfig(USART_TypeDef* USARTx, uint32_t USART_AutoBaudRate)
 903:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1005              		.loc 1 903 0
 1006              		.cfi_startproc
 1007              	.LVL101:
 904:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 905:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 906:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_AUTOBAUDRATE_MODE(USART_AutoBaudRate));
 907:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 908:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABRMODE);
 1008              		.loc 1 908 0
 1009 0000 4268     		ldr	r2, [r0, #4]
 1010 0002 034B     		ldr	r3, .L81
 1011 0004 1340     		and	r3, r2
 1012 0006 4360     		str	r3, [r0, #4]
 909:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR2 |= USART_AutoBaudRate;
 1013              		.loc 1 909 0
 1014 0008 4368     		ldr	r3, [r0, #4]
 1015 000a 1943     		orr	r1, r3
 1016              	.LVL102:
 1017 000c 4160     		str	r1, [r0, #4]
 910:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1018              		.loc 1 910 0
 1019              		@ sp needed
 1020 000e 7047     		bx	lr
 1021              	.L82:
 1022              		.align	2
 1023              	.L81:
 1024 0010 FFFF9FFF 		.word	-6291457
 1025              		.cfi_endproc
 1026              	.LFE52:
 1028              		.section	.text.USART_SendData,"ax",%progbits
 1029              		.align	2
 1030              		.global	USART_SendData
 1031              		.code	16
 1032              		.thumb_func
 1034              	USART_SendData:
 1035              	.LFB53:
 911:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 912:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 913:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @}
 914:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 915:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 916:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 917:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @defgroup USART_Group4 Data transfers functions
 918:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *  @brief   Data transfers functions 
 919:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *
 920:.\StdPeriphLib\src/stm32f0xx_usart.c **** @verbatim   
 921:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
 922:.\StdPeriphLib\src/stm32f0xx_usart.c ****                     ##### Data transfers functions #####
 923:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
 924:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] This subsection provides a set of functions allowing to manage 
 925:.\StdPeriphLib\src/stm32f0xx_usart.c ****          the USART data transfers.
 926:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] During an USART reception, data shifts in least significant bit first 
 927:.\StdPeriphLib\src/stm32f0xx_usart.c ****          through the RX pin. When a transmission is taking place, a write instruction to 
 928:.\StdPeriphLib\src/stm32f0xx_usart.c ****          the USART_TDR register stores the data in the shift register.
 929:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] The read access of the USART_RDR register can be done using 
 930:.\StdPeriphLib\src/stm32f0xx_usart.c ****          the USART_ReceiveData() function and returns the RDR value.
 931:.\StdPeriphLib\src/stm32f0xx_usart.c ****          Whereas a write access to the USART_TDR can be done using USART_SendData()
 932:.\StdPeriphLib\src/stm32f0xx_usart.c ****          function and stores the written data into TDR.
 933:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 934:.\StdPeriphLib\src/stm32f0xx_usart.c **** @endverbatim
 935:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
 936:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 937:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 938:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 939:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Transmits single data through the USARTx peripheral.
 940:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
 941:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
 942:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
 943:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
 944:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  Data: the data to transmit.
 945:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
 946:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 947:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
 948:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1036              		.loc 1 948 0
 1037              		.cfi_startproc
 1038              	.LVL103:
 949:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 950:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 951:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_DATA(Data)); 
 952:.\StdPeriphLib\src/stm32f0xx_usart.c ****     
 953:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Transmit Data */
 954:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->TDR = (Data & (uint16_t)0x01FF);
 1039              		.loc 1 954 0
 1040 0000 C905     		lsl	r1, r1, #23
 1041              	.LVL104:
 1042 0002 C90D     		lsr	r1, r1, #23
 1043 0004 0185     		strh	r1, [r0, #40]
 955:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1044              		.loc 1 955 0
 1045              		@ sp needed
 1046 0006 7047     		bx	lr
 1047              		.cfi_endproc
 1048              	.LFE53:
 1050              		.section	.text.USART_ReceiveData,"ax",%progbits
 1051              		.align	2
 1052              		.global	USART_ReceiveData
 1053              		.code	16
 1054              		.thumb_func
 1056              	USART_ReceiveData:
 1057              	.LFB54:
 956:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 957:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 958:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Returns the most recent received data by the USARTx peripheral.
 959:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
 960:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
 961:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
 962:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.   
 963:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval The received data.
 964:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 965:.\StdPeriphLib\src/stm32f0xx_usart.c **** uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
 966:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1058              		.loc 1 966 0
 1059              		.cfi_startproc
 1060              	.LVL105:
 967:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
 968:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 969:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
 970:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Receive Data */
 971:.\StdPeriphLib\src/stm32f0xx_usart.c ****   return (uint16_t)(USARTx->RDR & (uint16_t)0x01FF);
 1061              		.loc 1 971 0
 1062 0000 808C     		ldrh	r0, [r0, #36]
 1063              	.LVL106:
 1064 0002 C005     		lsl	r0, r0, #23
 1065 0004 C00D     		lsr	r0, r0, #23
 972:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1066              		.loc 1 972 0
 1067              		@ sp needed
 1068 0006 7047     		bx	lr
 1069              		.cfi_endproc
 1070              	.LFE54:
 1072              		.section	.text.USART_SetAddress,"ax",%progbits
 1073              		.align	2
 1074              		.global	USART_SetAddress
 1075              		.code	16
 1076              		.thumb_func
 1078              	USART_SetAddress:
 1079              	.LFB55:
 973:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 974:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
 975:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @}
 976:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
 977:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
 978:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @defgroup USART_Group5 MultiProcessor Communication functions
 979:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *  @brief   Multi-Processor Communication functions 
 980:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *
 981:.\StdPeriphLib\src/stm32f0xx_usart.c **** @verbatim   
 982:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
 983:.\StdPeriphLib\src/stm32f0xx_usart.c ****              ##### Multi-Processor Communication functions #####
 984:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
 985:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
 986:.\StdPeriphLib\src/stm32f0xx_usart.c ****          multiprocessor communication.
 987:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] For instance one of the USARTs can be the master, its TX output is
 988:.\StdPeriphLib\src/stm32f0xx_usart.c ****          connected to the RX input of the other USART. The others are slaves,
 989:.\StdPeriphLib\src/stm32f0xx_usart.c ****          their respective TX outputs are logically ANDed together and connected 
 990:.\StdPeriphLib\src/stm32f0xx_usart.c ****          to the RX input of the master. USART multiprocessor communication is 
 991:.\StdPeriphLib\src/stm32f0xx_usart.c ****          possible through the following procedure:
 992:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Program the Baud rate, Word length = 9 bits, Stop bits, Parity, 
 993:.\StdPeriphLib\src/stm32f0xx_usart.c ****              Mode transmitter or Mode receiver and hardware flow control values 
 994:.\StdPeriphLib\src/stm32f0xx_usart.c ****              using the USART_Init() function.
 995:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Configures the USART address using the USART_SetAddress() function.
 996:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Configures the wake up methode (USART_WakeUp_IdleLine or 
 997:.\StdPeriphLib\src/stm32f0xx_usart.c ****              USART_WakeUp_AddressMark) using USART_WakeUpConfig() function only 
 998:.\StdPeriphLib\src/stm32f0xx_usart.c ****              for the slaves.
 999:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1000:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() 
1001:.\StdPeriphLib\src/stm32f0xx_usart.c ****              function.
1002:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] The USART Slave exit from mute mode when receive the wake up condition.
1003:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1004:.\StdPeriphLib\src/stm32f0xx_usart.c **** @endverbatim
1005:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
1006:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1007:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1008:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1009:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Sets the address of the USART node.
1010:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1011:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1012:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1013:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.   
1014:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_Address: Indicates the address of the USART node.
1015:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1016:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1017:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
1018:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1080              		.loc 1 1018 0
 1081              		.cfi_startproc
 1082              	.LVL107:
1019:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1020:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1021:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
1022:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Clear the USART address */
1023:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADD);
 1083              		.loc 1 1023 0
 1084 0000 4368     		ldr	r3, [r0, #4]
 1085 0002 1B02     		lsl	r3, r3, #8
 1086 0004 1B0A     		lsr	r3, r3, #8
 1087 0006 4360     		str	r3, [r0, #4]
1024:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set the USART address node */
1025:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR2 |=((uint32_t)USART_Address << (uint32_t)0x18);
 1088              		.loc 1 1025 0
 1089 0008 4368     		ldr	r3, [r0, #4]
 1090 000a 0906     		lsl	r1, r1, #24
 1091              	.LVL108:
 1092 000c 1943     		orr	r1, r3
 1093 000e 4160     		str	r1, [r0, #4]
1026:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1094              		.loc 1 1026 0
 1095              		@ sp needed
 1096 0010 7047     		bx	lr
 1097              		.cfi_endproc
 1098              	.LFE55:
 1100 0012 C046     		.section	.text.USART_MuteModeCmd,"ax",%progbits
 1101              		.align	2
 1102              		.global	USART_MuteModeCmd
 1103              		.code	16
 1104              		.thumb_func
 1106              	USART_MuteModeCmd:
 1107              	.LFB56:
1027:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1028:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1029:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the USART's mute mode.
1030:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1031:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1032:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1033:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
1034:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the USART mute mode.
1035:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
1036:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1037:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1038:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_MuteModeCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1039:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1108              		.loc 1 1039 0
 1109              		.cfi_startproc
 1110              	.LVL109:
1040:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1041:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1042:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
1043:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
1044:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 1111              		.loc 1 1044 0
 1112 0000 0029     		cmp	r1, #0
 1113 0002 05D0     		beq	.L87
1045:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1046:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the USART mute mode by setting the MME bit in the CR1 register */
1047:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR1 |= USART_CR1_MME;
 1114              		.loc 1 1047 0
 1115 0004 0368     		ldr	r3, [r0]
 1116 0006 8022     		mov	r2, #128
 1117 0008 9201     		lsl	r2, r2, #6
 1118 000a 1343     		orr	r3, r2
 1119 000c 0360     		str	r3, [r0]
 1120 000e 03E0     		b	.L86
 1121              	.L87:
1048:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1049:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
1050:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1051:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the USART mute mode by clearing the MME bit in the CR1 register */
1052:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_MME);
 1122              		.loc 1 1052 0
 1123 0010 0268     		ldr	r2, [r0]
 1124 0012 024B     		ldr	r3, .L89
 1125 0014 1340     		and	r3, r2
 1126 0016 0360     		str	r3, [r0]
 1127              	.L86:
1053:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1054:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1128              		.loc 1 1054 0
 1129              		@ sp needed
 1130 0018 7047     		bx	lr
 1131              	.L90:
 1132 001a C046     		.align	2
 1133              	.L89:
 1134 001c FFDFFFFF 		.word	-8193
 1135              		.cfi_endproc
 1136              	.LFE56:
 1138              		.section	.text.USART_MuteModeWakeUpConfig,"ax",%progbits
 1139              		.align	2
 1140              		.global	USART_MuteModeWakeUpConfig
 1141              		.code	16
 1142              		.thumb_func
 1144              	USART_MuteModeWakeUpConfig:
 1145              	.LFB57:
1055:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1056:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1057:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Selects the USART WakeUp method from mute mode.
1058:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1059:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1060:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1061:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.   
1062:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_WakeUp: specifies the USART wakeup method.
1063:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be one of the following values:
1064:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
1065:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
1066:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1067:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1068:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_MuteModeWakeUpConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUp)
1069:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1146              		.loc 1 1069 0
 1147              		.cfi_startproc
 1148              	.LVL110:
1070:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1071:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1072:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_MUTEMODE_WAKEUP(USART_WakeUp));
1073:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1074:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_WAKE);
 1149              		.loc 1 1074 0
 1150 0000 0268     		ldr	r2, [r0]
 1151 0002 034B     		ldr	r3, .L92
 1152 0004 1340     		and	r3, r2
 1153 0006 0360     		str	r3, [r0]
1075:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR1 |= USART_WakeUp;
 1154              		.loc 1 1075 0
 1155 0008 0368     		ldr	r3, [r0]
 1156 000a 1943     		orr	r1, r3
 1157              	.LVL111:
 1158 000c 0160     		str	r1, [r0]
1076:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1159              		.loc 1 1076 0
 1160              		@ sp needed
 1161 000e 7047     		bx	lr
 1162              	.L93:
 1163              		.align	2
 1164              	.L92:
 1165 0010 FFF7FFFF 		.word	-2049
 1166              		.cfi_endproc
 1167              	.LFE57:
 1169              		.section	.text.USART_AddressDetectionConfig,"ax",%progbits
 1170              		.align	2
 1171              		.global	USART_AddressDetectionConfig
 1172              		.code	16
 1173              		.thumb_func
 1175              	USART_AddressDetectionConfig:
 1176              	.LFB58:
1077:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1078:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1079:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Configure the the USART Address detection length.
1080:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1081:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1082:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1083:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
1084:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_AddressLength: specifies the USART address length detection.
1085:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be one of the following values:
1086:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_AddressLength_4b: 4-bit address length detection 
1087:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_AddressLength_7b: 7-bit address length detection 
1088:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1089:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1090:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_AddressDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_AddressLength)
1091:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1177              		.loc 1 1091 0
 1178              		.cfi_startproc
 1179              	.LVL112:
1092:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1093:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1094:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ADDRESS_DETECTION(USART_AddressLength));
1095:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1096:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADDM7);
 1180              		.loc 1 1096 0
 1181 0000 4368     		ldr	r3, [r0, #4]
 1182 0002 1022     		mov	r2, #16
 1183 0004 9343     		bic	r3, r2
 1184 0006 4360     		str	r3, [r0, #4]
1097:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR2 |= USART_AddressLength;
 1185              		.loc 1 1097 0
 1186 0008 4368     		ldr	r3, [r0, #4]
 1187 000a 1943     		orr	r1, r3
 1188              	.LVL113:
 1189 000c 4160     		str	r1, [r0, #4]
1098:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1190              		.loc 1 1098 0
 1191              		@ sp needed
 1192 000e 7047     		bx	lr
 1193              		.cfi_endproc
 1194              	.LFE58:
 1196              		.section	.text.USART_LINBreakDetectLengthConfig,"ax",%progbits
 1197              		.align	2
 1198              		.global	USART_LINBreakDetectLengthConfig
 1199              		.code	16
 1200              		.thumb_func
 1202              	USART_LINBreakDetectLengthConfig:
 1203              	.LFB59:
1099:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1100:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1101:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @}
1102:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1103:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1104:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @defgroup USART_Group6 LIN mode functions
1105:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *  @brief   LIN mode functions 
1106:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *
1107:.\StdPeriphLib\src/stm32f0xx_usart.c **** @verbatim   
1108:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
1109:.\StdPeriphLib\src/stm32f0xx_usart.c ****                        ##### LIN mode functions #####
1110:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
1111:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART 
1112:.\StdPeriphLib\src/stm32f0xx_usart.c ****          LIN Mode communication.
1113:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] In LIN mode, 8-bit data format with 1 stop bit is required in accordance 
1114:.\StdPeriphLib\src/stm32f0xx_usart.c ****          with the LIN standard.
1115:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] Only this LIN Feature is supported by the USART IP:
1116:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (+) LIN Master Synchronous Break send capability and LIN slave break 
1117:.\StdPeriphLib\src/stm32f0xx_usart.c ****              detection capability :  13-bit break generation and 10/11 bit break 
1118:.\StdPeriphLib\src/stm32f0xx_usart.c ****              detection.
1119:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] USART LIN Master transmitter communication is possible through the 
1120:.\StdPeriphLib\src/stm32f0xx_usart.c ****          following procedure:
1121:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
1122:.\StdPeriphLib\src/stm32f0xx_usart.c ****              Mode transmitter or Mode receiver and hardware flow control values 
1123:.\StdPeriphLib\src/stm32f0xx_usart.c ****              using the USART_Init() function.
1124:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enable the LIN mode using the USART_LINCmd() function.
1125:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1126:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Send the break character using USART_SendBreak() function.
1127:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] USART LIN Master receiver communication is possible through the 
1128:.\StdPeriphLib\src/stm32f0xx_usart.c ****          following procedure:
1129:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
1130:.\StdPeriphLib\src/stm32f0xx_usart.c ****              Mode transmitter or Mode receiver and hardware flow control values 
1131:.\StdPeriphLib\src/stm32f0xx_usart.c ****              using the USART_Init() function.
1132:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Configures the break detection length 
1133:.\StdPeriphLib\src/stm32f0xx_usart.c ****              using the USART_LINBreakDetectLengthConfig() function.
1134:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enable the LIN mode using the USART_LINCmd() function.
1135:.\StdPeriphLib\src/stm32f0xx_usart.c ****          -@- In LIN mode, the following bits must be kept cleared:
1136:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (+@) CLKEN in the USART_CR2 register.
1137:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (+@) STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
1138:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1139:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1140:.\StdPeriphLib\src/stm32f0xx_usart.c **** @endverbatim
1141:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
1142:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1143:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1144:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1145:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Sets the USART LIN Break detection length.
1146:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function is not available for STM32F030 devices.  
1147:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1or 2  to select the USART peripheral.
1148:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
1149:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices.
1150:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
1151:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be one of the following values:
1152:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
1153:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
1154:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1155:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1156:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint32_t USART_LINBreakDetectLength)
1157:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1204              		.loc 1 1157 0
 1205              		.cfi_startproc
 1206              	.LVL114:
1158:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1159:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1160:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
1161:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1162:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LBDL);
 1207              		.loc 1 1162 0
 1208 0000 4368     		ldr	r3, [r0, #4]
 1209 0002 2022     		mov	r2, #32
 1210 0004 9343     		bic	r3, r2
 1211 0006 4360     		str	r3, [r0, #4]
1163:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR2 |= USART_LINBreakDetectLength;  
 1212              		.loc 1 1163 0
 1213 0008 4368     		ldr	r3, [r0, #4]
 1214 000a 1943     		orr	r1, r3
 1215              	.LVL115:
 1216 000c 4160     		str	r1, [r0, #4]
1164:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1217              		.loc 1 1164 0
 1218              		@ sp needed
 1219 000e 7047     		bx	lr
 1220              		.cfi_endproc
 1221              	.LFE59:
 1223              		.section	.text.USART_LINCmd,"ax",%progbits
 1224              		.align	2
 1225              		.global	USART_LINCmd
 1226              		.code	16
 1227              		.thumb_func
 1229              	USART_LINCmd:
 1230              	.LFB60:
1165:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1166:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1167:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the USART's LIN mode.
1168:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function is not available for STM32F030 devices.
1169:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1or 2  to select the USART peripheral.
1170:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
1171:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices.  
1172:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the USART LIN mode.
1173:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
1174:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1175:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1176:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1177:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1231              		.loc 1 1177 0
 1232              		.cfi_startproc
 1233              	.LVL116:
1178:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1179:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1180:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1181:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1182:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 1234              		.loc 1 1182 0
 1235 0000 0029     		cmp	r1, #0
 1236 0002 05D0     		beq	.L97
1183:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1184:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
1185:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR2 |= USART_CR2_LINEN;
 1237              		.loc 1 1185 0
 1238 0004 4368     		ldr	r3, [r0, #4]
 1239 0006 8022     		mov	r2, #128
 1240 0008 D201     		lsl	r2, r2, #7
 1241 000a 1343     		orr	r3, r2
 1242 000c 4360     		str	r3, [r0, #4]
 1243 000e 03E0     		b	.L96
 1244              	.L97:
1186:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1187:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
1188:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1189:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
1190:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LINEN);
 1245              		.loc 1 1190 0
 1246 0010 4268     		ldr	r2, [r0, #4]
 1247 0012 024B     		ldr	r3, .L99
 1248 0014 1340     		and	r3, r2
 1249 0016 4360     		str	r3, [r0, #4]
 1250              	.L96:
1191:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1192:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1251              		.loc 1 1192 0
 1252              		@ sp needed
 1253 0018 7047     		bx	lr
 1254              	.L100:
 1255 001a C046     		.align	2
 1256              	.L99:
 1257 001c FFBFFFFF 		.word	-16385
 1258              		.cfi_endproc
 1259              	.LFE60:
 1261              		.section	.text.USART_HalfDuplexCmd,"ax",%progbits
 1262              		.align	2
 1263              		.global	USART_HalfDuplexCmd
 1264              		.code	16
 1265              		.thumb_func
 1267              	USART_HalfDuplexCmd:
 1268              	.LFB61:
1193:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1194:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1195:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @}
1196:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1197:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1198:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @defgroup USART_Group7 Halfduplex mode function
1199:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *  @brief   Half-duplex mode function 
1200:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *
1201:.\StdPeriphLib\src/stm32f0xx_usart.c **** @verbatim   
1202:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
1203:.\StdPeriphLib\src/stm32f0xx_usart.c ****                    ##### Half-duplex mode function #####
1204:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
1205:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
1206:.\StdPeriphLib\src/stm32f0xx_usart.c ****          Half-duplex communication.
1207:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] The USART can be configured to follow a single-wire half-duplex protocol 
1208:.\StdPeriphLib\src/stm32f0xx_usart.c ****          where the TX and RX lines are internally connected.
1209:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] USART Half duplex communication is possible through the following procedure:
1210:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
1211:.\StdPeriphLib\src/stm32f0xx_usart.c ****              or Mode receiver and hardware flow control values using the USART_Init()
1212:.\StdPeriphLib\src/stm32f0xx_usart.c ****             function.
1213:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Configures the USART address using the USART_SetAddress() function.
1214:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enable the half duplex mode using USART_HalfDuplexCmd() function.
1215:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1216:.\StdPeriphLib\src/stm32f0xx_usart.c ****          -@- The RX pin is no longer used.
1217:.\StdPeriphLib\src/stm32f0xx_usart.c ****          -@- In Half-duplex mode the following bits must be kept cleared:
1218:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (+@) LINEN and CLKEN bits in the USART_CR2 register.
1219:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (+@) SCEN and IREN bits in the USART_CR3 register.
1220:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1221:.\StdPeriphLib\src/stm32f0xx_usart.c **** @endverbatim
1222:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
1223:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1224:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1225:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1226:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the USART's Half Duplex communication.
1227:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1228:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1229:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1230:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.    
1231:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the USART Communication.
1232:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
1233:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1234:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1235:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1236:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1269              		.loc 1 1236 0
 1270              		.cfi_startproc
 1271              	.LVL117:
1237:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1238:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1239:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1240:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
1241:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 1272              		.loc 1 1241 0
 1273 0000 0029     		cmp	r1, #0
 1274 0002 04D0     		beq	.L102
1242:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1243:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
1244:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR3 |= USART_CR3_HDSEL;
 1275              		.loc 1 1244 0
 1276 0004 8268     		ldr	r2, [r0, #8]
 1277 0006 0823     		mov	r3, #8
 1278 0008 1343     		orr	r3, r2
 1279 000a 8360     		str	r3, [r0, #8]
 1280 000c 03E0     		b	.L101
 1281              	.L102:
1245:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1246:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
1247:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1248:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
1249:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_HDSEL);
 1282              		.loc 1 1249 0
 1283 000e 8368     		ldr	r3, [r0, #8]
 1284 0010 0822     		mov	r2, #8
 1285 0012 9343     		bic	r3, r2
 1286 0014 8360     		str	r3, [r0, #8]
 1287              	.L101:
1250:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1251:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1288              		.loc 1 1251 0
 1289              		@ sp needed
 1290 0016 7047     		bx	lr
 1291              		.cfi_endproc
 1292              	.LFE61:
 1294              		.section	.text.USART_SetGuardTime,"ax",%progbits
 1295              		.align	2
 1296              		.global	USART_SetGuardTime
 1297              		.code	16
 1298              		.thumb_func
 1300              	USART_SetGuardTime:
 1301              	.LFB62:
1252:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1253:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1254:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @}
1255:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1256:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1257:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1258:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @defgroup USART_Group8 Smartcard mode functions
1259:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *  @brief   Smartcard mode functions 
1260:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *
1261:.\StdPeriphLib\src/stm32f0xx_usart.c **** @verbatim   
1262:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
1263:.\StdPeriphLib\src/stm32f0xx_usart.c ****                      ##### Smartcard mode functions #####
1264:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
1265:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
1266:.\StdPeriphLib\src/stm32f0xx_usart.c ****          Smartcard communication.
1267:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] The Smartcard interface is designed to support asynchronous protocol 
1268:.\StdPeriphLib\src/stm32f0xx_usart.c ****          Smartcards as defined in the ISO 7816-3 standard. The USART can provide 
1269:.\StdPeriphLib\src/stm32f0xx_usart.c ****          a clock to the smartcard through the SCLK output. In smartcard mode, 
1270:.\StdPeriphLib\src/stm32f0xx_usart.c ****          SCLK is not associated to the communication but is simply derived from 
1271:.\StdPeriphLib\src/stm32f0xx_usart.c ****          the internal peripheral input clock through a 5-bit prescaler.
1272:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] Smartcard communication is possible through the following procedure:
1273:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Configures the Smartcard Prsecaler using the USART_SetPrescaler() 
1274:.\StdPeriphLib\src/stm32f0xx_usart.c ****              function.
1275:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Configures the Smartcard Guard Time using the USART_SetGuardTime() 
1276:.\StdPeriphLib\src/stm32f0xx_usart.c ****              function.
1277:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Program the USART clock using the USART_ClockInit() function as following:
1278:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (++) USART Clock enabled.
1279:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (++) USART CPOL Low.
1280:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (++) USART CPHA on first edge.
1281:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (++) USART Last Bit Clock Enabled.
1282:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Program the Smartcard interface using the USART_Init() function as 
1283:.\StdPeriphLib\src/stm32f0xx_usart.c ****              following:
1284:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (++) Word Length = 9 Bits.
1285:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (++) 1.5 Stop Bit.
1286:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (++) Even parity.
1287:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (++) BaudRate = 12096 baud.
1288:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (++) Hardware flow control disabled (RTS and CTS signals).
1289:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (++) Tx and Rx enabled
1290:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Optionally you can enable the parity error interrupt using 
1291:.\StdPeriphLib\src/stm32f0xx_usart.c ****              the USART_ITConfig() function.
1292:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
1293:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enable the Smartcard interface using the USART_SmartCardCmd() function.
1294:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1295:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] 
1296:.\StdPeriphLib\src/stm32f0xx_usart.c ****   Please refer to the ISO 7816-3 specification for more details.
1297:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] 
1298:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (@) It is also possible to choose 0.5 stop bit for receiving but it is 
1299:.\StdPeriphLib\src/stm32f0xx_usart.c ****              recommended to use 1.5 stop bits for both transmitting and receiving 
1300:.\StdPeriphLib\src/stm32f0xx_usart.c ****              to avoid switching between the two configurations.
1301:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (@) In smartcard mode, the following bits must be kept cleared:
1302:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (+@) LINEN bit in the USART_CR2 register.
1303:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (+@) HDSEL and IREN bits in the USART_CR3 register.
1304:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1305:.\StdPeriphLib\src/stm32f0xx_usart.c **** @endverbatim
1306:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
1307:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1308:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1309:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1310:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Sets the specified USART guard time.
1311:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function is not available for STM32F030 devices.  
1312:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1or 2  to select the USART peripheral.
1313:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
1314:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices. 
1315:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_GuardTime: specifies the guard time.
1316:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1317:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1318:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
1319:.\StdPeriphLib\src/stm32f0xx_usart.c **** {    
 1302              		.loc 1 1319 0
 1303              		.cfi_startproc
 1304              	.LVL118:
1320:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1321:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1322:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1323:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Clear the USART Guard time */
1324:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->GTPR &= USART_GTPR_PSC;
 1305              		.loc 1 1324 0
 1306 0000 028A     		ldrh	r2, [r0, #16]
 1307 0002 FF23     		mov	r3, #255
 1308 0004 1340     		and	r3, r2
 1309 0006 0382     		strh	r3, [r0, #16]
1325:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set the USART guard time */
1326:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 1310              		.loc 1 1326 0
 1311 0008 038A     		ldrh	r3, [r0, #16]
 1312 000a 0902     		lsl	r1, r1, #8
 1313              	.LVL119:
 1314 000c 1943     		orr	r1, r3
 1315 000e 0182     		strh	r1, [r0, #16]
1327:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1316              		.loc 1 1327 0
 1317              		@ sp needed
 1318 0010 7047     		bx	lr
 1319              		.cfi_endproc
 1320              	.LFE62:
 1322 0012 C046     		.section	.text.USART_SmartCardCmd,"ax",%progbits
 1323              		.align	2
 1324              		.global	USART_SmartCardCmd
 1325              		.code	16
 1326              		.thumb_func
 1328              	USART_SmartCardCmd:
 1329              	.LFB63:
1328:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1329:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1330:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the USART's Smart Card mode.
1331:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function is not available for STM32F030 devices.  
1332:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1or 2  to select the USART peripheral.
1333:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
1334:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices. 
1335:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the Smart Card mode.
1336:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.      
1337:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1338:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1339:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1340:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1330              		.loc 1 1340 0
 1331              		.cfi_startproc
 1332              	.LVL120:
1341:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1342:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1343:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1344:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 1333              		.loc 1 1344 0
 1334 0000 0029     		cmp	r1, #0
 1335 0002 04D0     		beq	.L106
1345:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1346:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the SC mode by setting the SCEN bit in the CR3 register */
1347:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR3 |= USART_CR3_SCEN;
 1336              		.loc 1 1347 0
 1337 0004 8268     		ldr	r2, [r0, #8]
 1338 0006 2023     		mov	r3, #32
 1339 0008 1343     		orr	r3, r2
 1340 000a 8360     		str	r3, [r0, #8]
 1341 000c 03E0     		b	.L105
 1342              	.L106:
1348:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1349:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
1350:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1351:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
1352:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCEN);
 1343              		.loc 1 1352 0
 1344 000e 8368     		ldr	r3, [r0, #8]
 1345 0010 2022     		mov	r2, #32
 1346 0012 9343     		bic	r3, r2
 1347 0014 8360     		str	r3, [r0, #8]
 1348              	.L105:
1353:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1354:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1349              		.loc 1 1354 0
 1350              		@ sp needed
 1351 0016 7047     		bx	lr
 1352              		.cfi_endproc
 1353              	.LFE63:
 1355              		.section	.text.USART_SmartCardNACKCmd,"ax",%progbits
 1356              		.align	2
 1357              		.global	USART_SmartCardNACKCmd
 1358              		.code	16
 1359              		.thumb_func
 1361              	USART_SmartCardNACKCmd:
 1362              	.LFB64:
1355:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1356:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1357:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables NACK transmission.
1358:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function is not available for STM32F030 devices.  
1359:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1or 2  to select the USART peripheral.
1360:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
1361:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices.
1362:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the NACK transmission.
1363:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.  
1364:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1365:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1366:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1367:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1363              		.loc 1 1367 0
 1364              		.cfi_startproc
 1365              	.LVL121:
1368:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1369:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx)); 
1370:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1371:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 1366              		.loc 1 1371 0
 1367 0000 0029     		cmp	r1, #0
 1368 0002 04D0     		beq	.L109
1372:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1373:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
1374:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR3 |= USART_CR3_NACK;
 1369              		.loc 1 1374 0
 1370 0004 8268     		ldr	r2, [r0, #8]
 1371 0006 1023     		mov	r3, #16
 1372 0008 1343     		orr	r3, r2
 1373 000a 8360     		str	r3, [r0, #8]
 1374 000c 03E0     		b	.L108
 1375              	.L109:
1375:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1376:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
1377:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1378:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
1379:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_NACK);
 1376              		.loc 1 1379 0
 1377 000e 8368     		ldr	r3, [r0, #8]
 1378 0010 1022     		mov	r2, #16
 1379 0012 9343     		bic	r3, r2
 1380 0014 8360     		str	r3, [r0, #8]
 1381              	.L108:
1380:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1381:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1382              		.loc 1 1381 0
 1383              		@ sp needed
 1384 0016 7047     		bx	lr
 1385              		.cfi_endproc
 1386              	.LFE64:
 1388              		.section	.text.USART_SetAutoRetryCount,"ax",%progbits
 1389              		.align	2
 1390              		.global	USART_SetAutoRetryCount
 1391              		.code	16
 1392              		.thumb_func
 1394              	USART_SetAutoRetryCount:
 1395              	.LFB65:
1382:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1383:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1384:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Sets the Smart Card number of retries in transmit and receive.
1385:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function is not available for STM32F030 devices.  
1386:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1or 3  to select the USART peripheral.
1387:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
1388:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices.
1389:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_AutoCount: specifies the Smart Card auto retry count.
1390:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1391:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1392:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_SetAutoRetryCount(USART_TypeDef* USARTx, uint8_t USART_AutoCount)
1393:.\StdPeriphLib\src/stm32f0xx_usart.c **** {    
 1396              		.loc 1 1393 0
 1397              		.cfi_startproc
 1398              	.LVL122:
1394:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1395:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1396:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_AUTO_RETRY_COUNTER(USART_AutoCount));
1397:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Clear the USART auto retry count */
1398:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCARCNT);
 1399              		.loc 1 1398 0
 1400 0000 8268     		ldr	r2, [r0, #8]
 1401 0002 044B     		ldr	r3, .L112
 1402 0004 1340     		and	r3, r2
 1403 0006 8360     		str	r3, [r0, #8]
1399:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set the USART auto retry count*/
1400:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR3 |= (uint32_t)((uint32_t)USART_AutoCount << 0x11);
 1404              		.loc 1 1400 0
 1405 0008 8368     		ldr	r3, [r0, #8]
 1406 000a 4904     		lsl	r1, r1, #17
 1407              	.LVL123:
 1408 000c 1943     		orr	r1, r3
 1409 000e 8160     		str	r1, [r0, #8]
1401:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1410              		.loc 1 1401 0
 1411              		@ sp needed
 1412 0010 7047     		bx	lr
 1413              	.L113:
 1414 0012 C046     		.align	2
 1415              	.L112:
 1416 0014 FFFFF1FF 		.word	-917505
 1417              		.cfi_endproc
 1418              	.LFE65:
 1420              		.section	.text.USART_SetBlockLength,"ax",%progbits
 1421              		.align	2
 1422              		.global	USART_SetBlockLength
 1423              		.code	16
 1424              		.thumb_func
 1426              	USART_SetBlockLength:
 1427              	.LFB66:
1402:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1403:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1404:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Sets the Smart Card Block length.
1405:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function is not available for STM32F030 devices.  
1406:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1or 3  to select the USART peripheral.
1407:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
1408:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices.
1409:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_BlockLength: specifies the Smart Card block length.
1410:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1411:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1412:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_SetBlockLength(USART_TypeDef* USARTx, uint8_t USART_BlockLength)
1413:.\StdPeriphLib\src/stm32f0xx_usart.c **** {    
 1428              		.loc 1 1413 0
 1429              		.cfi_startproc
 1430              	.LVL124:
1414:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1415:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1416:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1417:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Clear the Smart card block length */
1418:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_BLEN);
 1431              		.loc 1 1418 0
 1432 0000 4369     		ldr	r3, [r0, #20]
 1433 0002 1B02     		lsl	r3, r3, #8
 1434 0004 1B0A     		lsr	r3, r3, #8
 1435 0006 4361     		str	r3, [r0, #20]
1419:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set the Smart Card block length */
1420:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->RTOR |= (uint32_t)((uint32_t)USART_BlockLength << 0x18);
 1436              		.loc 1 1420 0
 1437 0008 4369     		ldr	r3, [r0, #20]
 1438 000a 0906     		lsl	r1, r1, #24
 1439              	.LVL125:
 1440 000c 1943     		orr	r1, r3
 1441 000e 4161     		str	r1, [r0, #20]
1421:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1442              		.loc 1 1421 0
 1443              		@ sp needed
 1444 0010 7047     		bx	lr
 1445              		.cfi_endproc
 1446              	.LFE66:
 1448 0012 C046     		.section	.text.USART_IrDAConfig,"ax",%progbits
 1449              		.align	2
 1450              		.global	USART_IrDAConfig
 1451              		.code	16
 1452              		.thumb_func
 1454              	USART_IrDAConfig:
 1455              	.LFB67:
1422:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1423:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1424:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @}
1425:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1426:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1427:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @defgroup USART_Group9 IrDA mode functions
1428:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *  @brief   IrDA mode functions 
1429:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *
1430:.\StdPeriphLib\src/stm32f0xx_usart.c **** @verbatim   
1431:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
1432:.\StdPeriphLib\src/stm32f0xx_usart.c ****                         ##### IrDA mode functions #####
1433:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
1434:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
1435:.\StdPeriphLib\src/stm32f0xx_usart.c ****          IrDA communication.
1436:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] IrDA is a half duplex communication protocol. If the Transmitter is busy, 
1437:.\StdPeriphLib\src/stm32f0xx_usart.c ****          any data on the IrDA receive line will be ignored by the IrDA decoder 
1438:.\StdPeriphLib\src/stm32f0xx_usart.c ****          and if the Receiver is busy, data on the TX from the USART to IrDA will 
1439:.\StdPeriphLib\src/stm32f0xx_usart.c ****          not be encoded by IrDA. While receiving data, transmission should be 
1440:.\StdPeriphLib\src/stm32f0xx_usart.c ****          avoided as the data to be transmitted could be corrupted.
1441:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] IrDA communication is possible through the following procedure:
1442:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Program the Baud rate, Word length = 8 bits, Stop bits, Parity, 
1443:.\StdPeriphLib\src/stm32f0xx_usart.c ****              Transmitter/Receiver modes and hardware flow control values using 
1444:.\StdPeriphLib\src/stm32f0xx_usart.c ****              the USART_Init() function.
1445:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Configures the IrDA pulse width by configuring the prescaler using  
1446:.\StdPeriphLib\src/stm32f0xx_usart.c ****              the USART_SetPrescaler() function.
1447:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal 
1448:.\StdPeriphLib\src/stm32f0xx_usart.c ****              mode using the USART_IrDAConfig() function.
1449:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enable the IrDA using the USART_IrDACmd() function.
1450:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enable the USART using the USART_Cmd() function.         
1451:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..]
1452:.\StdPeriphLib\src/stm32f0xx_usart.c ****     (@) A pulse of width less than two and greater than one PSC period(s) may or 
1453:.\StdPeriphLib\src/stm32f0xx_usart.c ****         may not be rejected.
1454:.\StdPeriphLib\src/stm32f0xx_usart.c ****     (@) The receiver set up time should be managed by software. The IrDA physical 
1455:.\StdPeriphLib\src/stm32f0xx_usart.c ****         layer specification specifies a minimum of 10 ms delay between 
1456:.\StdPeriphLib\src/stm32f0xx_usart.c ****         transmission and reception (IrDA is a half duplex protocol).
1457:.\StdPeriphLib\src/stm32f0xx_usart.c ****     (@) In IrDA mode, the following bits must be kept cleared:
1458:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (+@) LINEN, STOP and CLKEN bits in the USART_CR2 register.
1459:.\StdPeriphLib\src/stm32f0xx_usart.c ****         (+@) SCEN and HDSEL bits in the USART_CR3 register.
1460:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1461:.\StdPeriphLib\src/stm32f0xx_usart.c **** @endverbatim
1462:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
1463:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1464:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1465:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1466:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Configures the USART's IrDA interface.
1467:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function is not available for STM32F030 devices.  
1468:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1or 2  to select the USART peripheral.
1469:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
1470:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices.
1471:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_IrDAMode: specifies the IrDA mode.
1472:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be one of the following values:
1473:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IrDAMode_LowPower
1474:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IrDAMode_Normal
1475:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1476:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1477:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_IrDAConfig(USART_TypeDef* USARTx, uint32_t USART_IrDAMode)
1478:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1456              		.loc 1 1478 0
 1457              		.cfi_startproc
 1458              	.LVL126:
1479:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1480:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1481:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
1482:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1483:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IRLP);
 1459              		.loc 1 1483 0
 1460 0000 8368     		ldr	r3, [r0, #8]
 1461 0002 0422     		mov	r2, #4
 1462 0004 9343     		bic	r3, r2
 1463 0006 8360     		str	r3, [r0, #8]
1484:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR3 |= USART_IrDAMode;
 1464              		.loc 1 1484 0
 1465 0008 8368     		ldr	r3, [r0, #8]
 1466 000a 1943     		orr	r1, r3
 1467              	.LVL127:
 1468 000c 8160     		str	r1, [r0, #8]
1485:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1469              		.loc 1 1485 0
 1470              		@ sp needed
 1471 000e 7047     		bx	lr
 1472              		.cfi_endproc
 1473              	.LFE67:
 1475              		.section	.text.USART_IrDACmd,"ax",%progbits
 1476              		.align	2
 1477              		.global	USART_IrDACmd
 1478              		.code	16
 1479              		.thumb_func
 1481              	USART_IrDACmd:
 1482              	.LFB68:
1486:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1487:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1488:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the USART's IrDA interface.
1489:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   This function is not available for STM32F030 devices.  
1490:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be 1or 2  to select the USART peripheral.
1491:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is available only for STM32F072 and STM32F091 devices. 
1492:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 is available only for STM32F091 devices. 
1493:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the IrDA mode.
1494:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
1495:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1496:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1497:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
1498:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1483              		.loc 1 1498 0
 1484              		.cfi_startproc
 1485              	.LVL128:
1499:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1500:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1501:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1502:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1503:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 1486              		.loc 1 1503 0
 1487 0000 0029     		cmp	r1, #0
 1488 0002 04D0     		beq	.L117
1504:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1505:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
1506:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR3 |= USART_CR3_IREN;
 1489              		.loc 1 1506 0
 1490 0004 8268     		ldr	r2, [r0, #8]
 1491 0006 0223     		mov	r3, #2
 1492 0008 1343     		orr	r3, r2
 1493 000a 8360     		str	r3, [r0, #8]
 1494 000c 03E0     		b	.L116
 1495              	.L117:
1507:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1508:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
1509:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1510:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
1511:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IREN);
 1496              		.loc 1 1511 0
 1497 000e 8368     		ldr	r3, [r0, #8]
 1498 0010 0222     		mov	r2, #2
 1499 0012 9343     		bic	r3, r2
 1500 0014 8360     		str	r3, [r0, #8]
 1501              	.L116:
1512:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1513:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1502              		.loc 1 1513 0
 1503              		@ sp needed
 1504 0016 7047     		bx	lr
 1505              		.cfi_endproc
 1506              	.LFE68:
 1508              		.section	.text.USART_DECmd,"ax",%progbits
 1509              		.align	2
 1510              		.global	USART_DECmd
 1511              		.code	16
 1512              		.thumb_func
 1514              	USART_DECmd:
 1515              	.LFB69:
1514:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1515:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @}
1516:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1517:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1518:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @defgroup USART_Group10 RS485 mode function
1519:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *  @brief  RS485 mode function 
1520:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *
1521:.\StdPeriphLib\src/stm32f0xx_usart.c **** @verbatim  
1522:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
1523:.\StdPeriphLib\src/stm32f0xx_usart.c ****                         ##### RS485 mode functions #####
1524:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
1525:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
1526:.\StdPeriphLib\src/stm32f0xx_usart.c ****          RS485 flow control.
1527:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] RS485 flow control (Driver enable feature) handling is possible through
1528:.\StdPeriphLib\src/stm32f0xx_usart.c ****          the following procedure:
1529:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Program the Baud rate, Word length = 8 bits, Stop bits, Parity, 
1530:.\StdPeriphLib\src/stm32f0xx_usart.c ****              Transmitter/Receiver modes and hardware flow control values using 
1531:.\StdPeriphLib\src/stm32f0xx_usart.c ****              the USART_Init() function.
1532:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enable the Driver Enable using the USART_DECmd() function.
1533:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Configures the Driver Enable polarity using the USART_DEPolarityConfig()
1534:.\StdPeriphLib\src/stm32f0xx_usart.c ****              function.
1535:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Configures the Driver Enable assertion time using USART_SetDEAssertionTime() 
1536:.\StdPeriphLib\src/stm32f0xx_usart.c ****              function and deassertion time using the USART_SetDEDeassertionTime()
1537:.\StdPeriphLib\src/stm32f0xx_usart.c ****              function.    
1538:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1539:.\StdPeriphLib\src/stm32f0xx_usart.c ****       -@-  
1540:.\StdPeriphLib\src/stm32f0xx_usart.c ****        (+@) The assertion and dessertion times are expressed in sample time units (1/8 or 
1541:.\StdPeriphLib\src/stm32f0xx_usart.c ****             1/16 bit time, depending on the oversampling rate).
1542:.\StdPeriphLib\src/stm32f0xx_usart.c ****        
1543:.\StdPeriphLib\src/stm32f0xx_usart.c **** @endverbatim
1544:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
1545:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1546:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1547:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1548:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the USART's DE functionality.
1549:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1550:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1551:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1552:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
1553:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the driver enable mode.
1554:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.      
1555:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1556:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1557:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_DECmd(USART_TypeDef* USARTx, FunctionalState NewState)
1558:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1516              		.loc 1 1558 0
 1517              		.cfi_startproc
 1518              	.LVL129:
1559:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1560:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1561:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1562:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 1519              		.loc 1 1562 0
 1520 0000 0029     		cmp	r1, #0
 1521 0002 05D0     		beq	.L120
1563:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1564:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the DE functionality by setting the DEM bit in the CR3 register */
1565:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR3 |= USART_CR3_DEM;
 1522              		.loc 1 1565 0
 1523 0004 8368     		ldr	r3, [r0, #8]
 1524 0006 8022     		mov	r2, #128
 1525 0008 D201     		lsl	r2, r2, #7
 1526 000a 1343     		orr	r3, r2
 1527 000c 8360     		str	r3, [r0, #8]
 1528 000e 03E0     		b	.L119
 1529              	.L120:
1566:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1567:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
1568:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1569:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the DE functionality by clearing the DEM bit in the CR3 register */
1570:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEM);
 1530              		.loc 1 1570 0
 1531 0010 8268     		ldr	r2, [r0, #8]
 1532 0012 024B     		ldr	r3, .L122
 1533 0014 1340     		and	r3, r2
 1534 0016 8360     		str	r3, [r0, #8]
 1535              	.L119:
1571:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1572:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1536              		.loc 1 1572 0
 1537              		@ sp needed
 1538 0018 7047     		bx	lr
 1539              	.L123:
 1540 001a C046     		.align	2
 1541              	.L122:
 1542 001c FFBFFFFF 		.word	-16385
 1543              		.cfi_endproc
 1544              	.LFE69:
 1546              		.section	.text.USART_DEPolarityConfig,"ax",%progbits
 1547              		.align	2
 1548              		.global	USART_DEPolarityConfig
 1549              		.code	16
 1550              		.thumb_func
 1552              	USART_DEPolarityConfig:
 1553              	.LFB70:
1573:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1574:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1575:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Configures the USART's DE polarity
1576:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1577:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1578:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1579:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
1580:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_DEPolarity: specifies the DE polarity.
1581:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be one of the following values:
1582:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_DEPolarity_Low
1583:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_DEPolarity_High
1584:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1585:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1586:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_DEPolarityConfig(USART_TypeDef* USARTx, uint32_t USART_DEPolarity)
1587:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1554              		.loc 1 1587 0
 1555              		.cfi_startproc
 1556              	.LVL130:
1588:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1589:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1590:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_DE_POLARITY(USART_DEPolarity));
1591:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1592:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEP);
 1557              		.loc 1 1592 0
 1558 0000 8268     		ldr	r2, [r0, #8]
 1559 0002 034B     		ldr	r3, .L125
 1560 0004 1340     		and	r3, r2
 1561 0006 8360     		str	r3, [r0, #8]
1593:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR3 |= USART_DEPolarity;
 1562              		.loc 1 1593 0
 1563 0008 8368     		ldr	r3, [r0, #8]
 1564 000a 1943     		orr	r1, r3
 1565              	.LVL131:
 1566 000c 8160     		str	r1, [r0, #8]
1594:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1567              		.loc 1 1594 0
 1568              		@ sp needed
 1569 000e 7047     		bx	lr
 1570              	.L126:
 1571              		.align	2
 1572              	.L125:
 1573 0010 FF7FFFFF 		.word	-32769
 1574              		.cfi_endproc
 1575              	.LFE70:
 1577              		.section	.text.USART_SetDEAssertionTime,"ax",%progbits
 1578              		.align	2
 1579              		.global	USART_SetDEAssertionTime
 1580              		.code	16
 1581              		.thumb_func
 1583              	USART_SetDEAssertionTime:
 1584              	.LFB71:
1595:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1596:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1597:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Sets the specified RS485 DE assertion time
1598:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1599:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1600:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1601:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
1602:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_DEAssertionTime: specifies the time between the activation of
1603:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *         the DE signal and the beginning of the start bit
1604:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1605:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1606:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_SetDEAssertionTime(USART_TypeDef* USARTx, uint32_t USART_DEAssertionTime)
1607:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1585              		.loc 1 1607 0
 1586              		.cfi_startproc
 1587              	.LVL132:
1608:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1609:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1610:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEAssertionTime)); 
1611:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1612:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Clear the DE assertion time */
1613:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEAT);
 1588              		.loc 1 1613 0
 1589 0000 0268     		ldr	r2, [r0]
 1590 0002 044B     		ldr	r3, .L128
 1591 0004 1340     		and	r3, r2
 1592 0006 0360     		str	r3, [r0]
1614:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set the new value for the DE assertion time */
1615:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR1 |=((uint32_t)USART_DEAssertionTime << (uint32_t)0x15);
 1593              		.loc 1 1615 0
 1594 0008 0368     		ldr	r3, [r0]
 1595 000a 4905     		lsl	r1, r1, #21
 1596              	.LVL133:
 1597 000c 1943     		orr	r1, r3
 1598 000e 0160     		str	r1, [r0]
1616:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1599              		.loc 1 1616 0
 1600              		@ sp needed
 1601 0010 7047     		bx	lr
 1602              	.L129:
 1603 0012 C046     		.align	2
 1604              	.L128:
 1605 0014 FFFF1FFC 		.word	-65011713
 1606              		.cfi_endproc
 1607              	.LFE71:
 1609              		.section	.text.USART_SetDEDeassertionTime,"ax",%progbits
 1610              		.align	2
 1611              		.global	USART_SetDEDeassertionTime
 1612              		.code	16
 1613              		.thumb_func
 1615              	USART_SetDEDeassertionTime:
 1616              	.LFB72:
1617:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1618:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1619:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Sets the specified RS485 DE deassertion time
1620:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1621:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1622:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1623:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
1624:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_DeassertionTime: specifies the time between the middle of the last 
1625:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *         stop bit in a transmitted message and the de-activation of the DE signal
1626:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1627:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1628:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_SetDEDeassertionTime(USART_TypeDef* USARTx, uint32_t USART_DEDeassertionTime)
1629:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1617              		.loc 1 1629 0
 1618              		.cfi_startproc
 1619              	.LVL134:
1630:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1631:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1632:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEDeassertionTime)); 
1633:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1634:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Clear the DE deassertion time */
1635:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEDT);
 1620              		.loc 1 1635 0
 1621 0000 0268     		ldr	r2, [r0]
 1622 0002 044B     		ldr	r3, .L131
 1623 0004 1340     		and	r3, r2
 1624 0006 0360     		str	r3, [r0]
1636:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set the new value for the DE deassertion time */
1637:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR1 |=((uint32_t)USART_DEDeassertionTime << (uint32_t)0x10);
 1625              		.loc 1 1637 0
 1626 0008 0368     		ldr	r3, [r0]
 1627 000a 0904     		lsl	r1, r1, #16
 1628              	.LVL135:
 1629 000c 1943     		orr	r1, r3
 1630 000e 0160     		str	r1, [r0]
1638:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1631              		.loc 1 1638 0
 1632              		@ sp needed
 1633 0010 7047     		bx	lr
 1634              	.L132:
 1635 0012 C046     		.align	2
 1636              	.L131:
 1637 0014 FFFFE0FF 		.word	-2031617
 1638              		.cfi_endproc
 1639              	.LFE72:
 1641              		.section	.text.USART_DMACmd,"ax",%progbits
 1642              		.align	2
 1643              		.global	USART_DMACmd
 1644              		.code	16
 1645              		.thumb_func
 1647              	USART_DMACmd:
 1648              	.LFB73:
1639:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1640:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1641:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @}
1642:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1643:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1644:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @defgroup USART_Group11 DMA transfers management functions
1645:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *  @brief   DMA transfers management functions
1646:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *
1647:.\StdPeriphLib\src/stm32f0xx_usart.c **** @verbatim   
1648:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
1649:.\StdPeriphLib\src/stm32f0xx_usart.c ****                ##### DMA transfers management functions #####
1650:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
1651:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] This section provides two functions that can be used only in DMA mode.
1652:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] In DMA Mode, the USART communication can be managed by 2 DMA Channel 
1653:.\StdPeriphLib\src/stm32f0xx_usart.c ****          requests:
1654:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request.
1655:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request.
1656:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] In this Mode it is advised to use the following function:
1657:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (+) void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, 
1658:.\StdPeriphLib\src/stm32f0xx_usart.c ****              FunctionalState NewState).
1659:.\StdPeriphLib\src/stm32f0xx_usart.c **** @endverbatim
1660:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
1661:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1662:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1663:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1664:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the USART's DMA interface.
1665:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1666:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1667:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1668:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
1669:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_DMAReq: specifies the DMA request.
1670:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be any combination of the following values:
1671:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_DMAReq_Tx: USART DMA transmit request
1672:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_DMAReq_Rx: USART DMA receive request
1673:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the DMA Request sources.
1674:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.  
1675:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1676:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1677:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_DMACmd(USART_TypeDef* USARTx, uint32_t USART_DMAReq, FunctionalState NewState)
1678:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1649              		.loc 1 1678 0
 1650              		.cfi_startproc
 1651              	.LVL136:
1679:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1680:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1681:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_DMAREQ(USART_DMAReq));  
1682:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
1683:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1684:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 1652              		.loc 1 1684 0
 1653 0000 002A     		cmp	r2, #0
 1654 0002 03D0     		beq	.L134
1685:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1686:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the DMA transfer for selected requests by setting the DMAT and/or
1687:.\StdPeriphLib\src/stm32f0xx_usart.c ****        DMAR bits in the USART CR3 register */
1688:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR3 |= USART_DMAReq;
 1655              		.loc 1 1688 0
 1656 0004 8368     		ldr	r3, [r0, #8]
 1657 0006 1943     		orr	r1, r3
 1658              	.LVL137:
 1659 0008 8160     		str	r1, [r0, #8]
 1660 000a 02E0     		b	.L133
 1661              	.LVL138:
 1662              	.L134:
1689:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1690:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
1691:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1692:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
1693:.\StdPeriphLib\src/stm32f0xx_usart.c ****        DMAR bits in the USART CR3 register */
1694:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->CR3 &= (uint32_t)~USART_DMAReq;
 1663              		.loc 1 1694 0
 1664 000c 8368     		ldr	r3, [r0, #8]
 1665 000e 8B43     		bic	r3, r1
 1666 0010 8360     		str	r3, [r0, #8]
 1667              	.LVL139:
 1668              	.L133:
1695:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1696:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1669              		.loc 1 1696 0
 1670              		@ sp needed
 1671 0012 7047     		bx	lr
 1672              		.cfi_endproc
 1673              	.LFE73:
 1675              		.section	.text.USART_DMAReceptionErrorConfig,"ax",%progbits
 1676              		.align	2
 1677              		.global	USART_DMAReceptionErrorConfig
 1678              		.code	16
 1679              		.thumb_func
 1681              	USART_DMAReceptionErrorConfig:
 1682              	.LFB74:
1697:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1698:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1699:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the USART's DMA interface when reception error occurs.
1700:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1701:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1702:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1703:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
1704:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_DMAOnError: specifies the DMA status in case of reception error.
1705:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be any combination of the following values:
1706:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_DMAOnError_Enable: DMA receive request enabled when the USART DMA  
1707:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *                                          reception error is asserted.
1708:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_DMAOnError_Disable: DMA receive request disabled when the USART DMA 
1709:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *                                           reception error is asserted.
1710:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1711:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1712:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_DMAReceptionErrorConfig(USART_TypeDef* USARTx, uint32_t USART_DMAOnError)
1713:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1683              		.loc 1 1713 0
 1684              		.cfi_startproc
 1685              	.LVL140:
1714:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1715:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1716:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_DMAONERROR(USART_DMAOnError)); 
1717:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
1718:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Clear the DMA Reception error detection bit */
1719:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DDRE);
 1686              		.loc 1 1719 0
 1687 0000 8268     		ldr	r2, [r0, #8]
 1688 0002 034B     		ldr	r3, .L137
 1689 0004 1340     		and	r3, r2
 1690 0006 8360     		str	r3, [r0, #8]
1720:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set the new value for the DMA Reception error detection bit */
1721:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR3 |= USART_DMAOnError;
 1691              		.loc 1 1721 0
 1692 0008 8368     		ldr	r3, [r0, #8]
 1693 000a 1943     		orr	r1, r3
 1694              	.LVL141:
 1695 000c 8160     		str	r1, [r0, #8]
1722:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1696              		.loc 1 1722 0
 1697              		@ sp needed
 1698 000e 7047     		bx	lr
 1699              	.L138:
 1700              		.align	2
 1701              	.L137:
 1702 0010 FFDFFFFF 		.word	-8193
 1703              		.cfi_endproc
 1704              	.LFE74:
 1706              		.section	.text.USART_ITConfig,"ax",%progbits
 1707              		.align	2
 1708              		.global	USART_ITConfig
 1709              		.code	16
 1710              		.thumb_func
 1712              	USART_ITConfig:
 1713              	.LFB75:
1723:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1724:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1725:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @}
1726:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1727:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
1728:.\StdPeriphLib\src/stm32f0xx_usart.c **** /** @defgroup USART_Group12 Interrupts and flags management functions
1729:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *  @brief   Interrupts and flags management functions 
1730:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *
1731:.\StdPeriphLib\src/stm32f0xx_usart.c **** @verbatim   
1732:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
1733:.\StdPeriphLib\src/stm32f0xx_usart.c ****             ##### Interrupts and flags management functions #####
1734:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ===============================================================================
1735:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] This subsection provides a set of functions allowing to configure the 
1736:.\StdPeriphLib\src/stm32f0xx_usart.c ****          USART Interrupts sources, Requests and check or clear the flags or pending bits status. 
1737:.\StdPeriphLib\src/stm32f0xx_usart.c ****          The user should identify which mode will be used in his application to 
1738:.\StdPeriphLib\src/stm32f0xx_usart.c ****          manage the communication: Polling mode, Interrupt mode.
1739:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1740:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *** Polling Mode ***
1741:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ====================
1742:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] In Polling Mode, the SPI communication can be managed by these flags:
1743:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_REACK: to indicate the status of the Receive Enable 
1744:.\StdPeriphLib\src/stm32f0xx_usart.c ****              acknowledge flag
1745:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_TEACK: to indicate the status of the Transmit Enable 
1746:.\StdPeriphLib\src/stm32f0xx_usart.c ****              acknowledge flag.
1747:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_WU: to indicate the status of the Wake up flag.
1748:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_RWU: to indicate the status of the Receive Wake up flag.
1749:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_SBK: to indicate the status of the Send Break flag.
1750:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_CM: to indicate the status of the Character match flag.
1751:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_BUSY: to indicate the status of the Busy flag.
1752:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_ABRF: to indicate the status of the Auto baud rate flag.
1753:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_ABRE: to indicate the status of the Auto baud rate error flag.
1754:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_EOB: to indicate the status of the End of block flag.
1755:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_RTO: to indicate the status of the Receive time out flag.
1756:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_nCTSS: to indicate the status of the Inverted nCTS input 
1757:.\StdPeriphLib\src/stm32f0xx_usart.c ****              bit status.
1758:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_TXE: to indicate the status of the transmit buffer register.
1759:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_RXNE: to indicate the status of the receive buffer register.
1760:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_TC: to indicate the status of the transmit operation.
1761:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_IDLE: to indicate the status of the Idle Line.
1762:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_CTS: to indicate the status of the nCTS input.
1763:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_LBD: to indicate the status of the LIN break detection.
1764:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_NE: to indicate if a noise error occur.
1765:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_FE: to indicate if a frame error occur.
1766:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_PE: to indicate if a parity error occur.
1767:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (#) USART_FLAG_ORE: to indicate if an Overrun error occur.
1768:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] In this Mode it is advised to use the following functions:
1769:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (+) FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG).
1770:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (+) void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG).
1771:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1772:.\StdPeriphLib\src/stm32f0xx_usart.c ****  *** Interrupt Mode ***
1773:.\StdPeriphLib\src/stm32f0xx_usart.c ****  ======================
1774:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] In Interrupt Mode, the USART communication can be managed by 8 interrupt 
1775:.\StdPeriphLib\src/stm32f0xx_usart.c ****          sources and 10 pending bits:
1776:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (+) Pending Bits:
1777:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_WU: to indicate the status of the Wake up interrupt.
1778:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_CM: to indicate the status of Character match interrupt.
1779:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_EOB: to indicate the status of End of block interrupt.
1780:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_RTO: to indicate the status of Receive time out interrupt.
1781:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_CTS: to indicate the status of CTS change interrupt.
1782:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_LBD: to indicate the status of LIN Break detection interrupt.
1783:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_TC: to indicate the status of Transmission complete interrupt.
1784:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_IDLE: to indicate the status of IDLE line detected interrupt.
1785:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_ORE: to indicate the status of OverRun Error interrupt.
1786:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_NE: to indicate the status of Noise Error interrupt.
1787:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_FE: to indicate the status of Framing Error interrupt.
1788:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_PE: to indicate the status of Parity Error interrupt.  
1789:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1790:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (+) Interrupt Source:
1791:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_WU: specifies the interrupt source for Wake up interrupt.
1792:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_CM: specifies the interrupt source for Character match 
1793:.\StdPeriphLib\src/stm32f0xx_usart.c ****                   interrupt.
1794:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_EOB: specifies the interrupt source for End of block
1795:.\StdPeriphLib\src/stm32f0xx_usart.c ****                   interrupt.
1796:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_RTO: specifies the interrupt source for Receive time-out
1797:.\StdPeriphLib\src/stm32f0xx_usart.c ****                   interrupt.
1798:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_CTS: specifies the interrupt source for CTS change interrupt.
1799:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_LBD: specifies the interrupt source for LIN Break 
1800:.\StdPeriphLib\src/stm32f0xx_usart.c ****                   detection interrupt.
1801:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_TXE: specifies the interrupt source for Tansmit Data 
1802:.\StdPeriphLib\src/stm32f0xx_usart.c ****                   Register empty interrupt.
1803:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_TC: specifies the interrupt source for Transmission 
1804:.\StdPeriphLib\src/stm32f0xx_usart.c ****                   complete interrupt.
1805:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_RXNE: specifies the interrupt source for Receive Data 
1806:.\StdPeriphLib\src/stm32f0xx_usart.c ****                   register not empty interrupt.
1807:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_IDLE: specifies the interrupt source for Idle line 
1808:.\StdPeriphLib\src/stm32f0xx_usart.c ****                   detection interrupt.
1809:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_PE: specifies the interrupt source for Parity Error interrupt.
1810:.\StdPeriphLib\src/stm32f0xx_usart.c ****              (##) USART_IT_ERR: specifies the interrupt source for Error interrupt
1811:.\StdPeriphLib\src/stm32f0xx_usart.c ****                   (Frame error, noise error, overrun error)
1812:.\StdPeriphLib\src/stm32f0xx_usart.c ****              -@@- Some parameters are coded in order to use them as interrupt 
1813:.\StdPeriphLib\src/stm32f0xx_usart.c ****                  source or as pending bits.
1814:.\StdPeriphLib\src/stm32f0xx_usart.c ****     [..] In this Mode it is advised to use the following functions:
1815:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (+) void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState
1816:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (+) ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT).
1817:.\StdPeriphLib\src/stm32f0xx_usart.c ****          (+) void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT).
1818:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1819:.\StdPeriphLib\src/stm32f0xx_usart.c **** @endverbatim
1820:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @{
1821:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1822:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1823:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1824:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the specified USART interrupts.
1825:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1826:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1827:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1828:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
1829:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
1830:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be one of the following values:
1831:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_WU:  Wake up interrupt, not available for  STM32F030 devices.
1832:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_CM:  Character match interrupt.
1833:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_EOB:  End of block interrupt, not available for  STM32F030 devices.
1834:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_RTO:  Receive time out interrupt.
1835:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt.
1836:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt, not available for  STM32F030 devi
1837:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_TXE:  Tansmit Data Register empty interrupt.
1838:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_TC:  Transmission complete interrupt.
1839:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_RXNE:  Receive Data register not empty interrupt.
1840:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_IDLE:  Idle line detection interrupt.
1841:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_PE:  Parity Error interrupt.
1842:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
1843:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the specified USARTx interrupts.
1844:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
1845:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1846:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1847:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState)
1848:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1714              		.loc 1 1848 0
 1715              		.cfi_startproc
 1716              	.LVL142:
 1717 0000 30B5     		push	{r4, r5, lr}
 1718              	.LCFI4:
 1719              		.cfi_def_cfa_offset 12
 1720              		.cfi_offset 4, -12
 1721              		.cfi_offset 5, -8
 1722              		.cfi_offset 14, -4
 1723              	.LVL143:
1849:.\StdPeriphLib\src/stm32f0xx_usart.c ****   uint32_t usartreg = 0, itpos = 0, itmask = 0;
1850:.\StdPeriphLib\src/stm32f0xx_usart.c ****   uint32_t usartxbase = 0;
1851:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1852:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1853:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_CONFIG_IT(USART_IT));
1854:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1855:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
1856:.\StdPeriphLib\src/stm32f0xx_usart.c ****   usartxbase = (uint32_t)USARTx;
 1724              		.loc 1 1856 0
 1725 0002 051C     		mov	r5, r0
 1726              	.LVL144:
1857:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
1858:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Get the USART register index */
1859:.\StdPeriphLib\src/stm32f0xx_usart.c ****   usartreg = (((uint16_t)USART_IT) >> 0x08);
 1727              		.loc 1 1859 0
 1728 0004 8CB2     		uxth	r4, r1
 1729 0006 240A     		lsr	r4, r4, #8
 1730              	.LVL145:
1860:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
1861:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Get the interrupt position */
1862:.\StdPeriphLib\src/stm32f0xx_usart.c ****   itpos = USART_IT & IT_MASK;
 1731              		.loc 1 1862 0
 1732 0008 FF23     		mov	r3, #255
 1733 000a 1940     		and	r1, r3
 1734              	.LVL146:
1863:.\StdPeriphLib\src/stm32f0xx_usart.c ****   itmask = (((uint32_t)0x01) << itpos);
 1735              		.loc 1 1863 0
 1736 000c FE3B     		sub	r3, r3, #254
 1737 000e 8B40     		lsl	r3, r3, r1
 1738 0010 191C     		mov	r1, r3
 1739              	.LVL147:
1864:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
1865:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (usartreg == 0x02) /* The IT is in CR2 register */
 1740              		.loc 1 1865 0
 1741 0012 022C     		cmp	r4, #2
 1742 0014 01D1     		bne	.L140
1866:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1867:.\StdPeriphLib\src/stm32f0xx_usart.c ****     usartxbase += 0x04;
 1743              		.loc 1 1867 0
 1744 0016 051D     		add	r5, r0, #4
 1745              	.LVL148:
 1746 0018 03E0     		b	.L141
 1747              	.LVL149:
 1748              	.L140:
1868:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1869:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else if (usartreg == 0x03) /* The IT is in CR3 register */
 1749              		.loc 1 1869 0
 1750 001a 032C     		cmp	r4, #3
 1751 001c 01D1     		bne	.L141
1870:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1871:.\StdPeriphLib\src/stm32f0xx_usart.c ****     usartxbase += 0x08;
 1752              		.loc 1 1871 0
 1753 001e 0830     		add	r0, r0, #8
 1754              	.LVL150:
 1755 0020 051C     		mov	r5, r0
 1756              	.LVL151:
 1757              	.L141:
1872:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1873:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else /* The IT is in CR1 register */
1874:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1875:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1876:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 1758              		.loc 1 1876 0
 1759 0022 002A     		cmp	r2, #0
 1760 0024 03D0     		beq	.L142
1877:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1878:.\StdPeriphLib\src/stm32f0xx_usart.c ****     *(__IO uint32_t*)usartxbase  |= itmask;
 1761              		.loc 1 1878 0
 1762 0026 2B68     		ldr	r3, [r5]
 1763 0028 1943     		orr	r1, r3
 1764              	.LVL152:
 1765 002a 2960     		str	r1, [r5]
 1766 002c 02E0     		b	.L139
 1767              	.LVL153:
 1768              	.L142:
1879:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1880:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
1881:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1882:.\StdPeriphLib\src/stm32f0xx_usart.c ****     *(__IO uint32_t*)usartxbase &= ~itmask;
 1769              		.loc 1 1882 0
 1770 002e 2B68     		ldr	r3, [r5]
 1771 0030 8B43     		bic	r3, r1
 1772 0032 2B60     		str	r3, [r5]
 1773              	.LVL154:
 1774              	.L139:
1883:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1884:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1775              		.loc 1 1884 0
 1776              		@ sp needed
 1777              	.LVL155:
 1778              	.LVL156:
 1779 0034 30BD     		pop	{r4, r5, pc}
 1780              		.cfi_endproc
 1781              	.LFE75:
 1783 0036 C046     		.section	.text.USART_RequestCmd,"ax",%progbits
 1784              		.align	2
 1785              		.global	USART_RequestCmd
 1786              		.code	16
 1787              		.thumb_func
 1789              	USART_RequestCmd:
 1790              	.LFB76:
1885:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1886:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1887:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables the specified USART's Request.
1888:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1889:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1890:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1891:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
1892:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_Request: specifies the USART request.
1893:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be any combination of the following values:
1894:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_Request_TXFRQ: Transmit data flush ReQuest
1895:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_Request_RXFRQ: Receive data flush ReQuest
1896:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_Request_MMRQ: Mute Mode ReQuest
1897:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_Request_SBKRQ: Send Break ReQuest
1898:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_Request_ABRRQ: Auto Baud Rate ReQuest
1899:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  NewState: new state of the DMA interface when reception error occurs.
1900:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.  
1901:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1902:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1903:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_RequestCmd(USART_TypeDef* USARTx, uint32_t USART_Request, FunctionalState NewState)
1904:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1791              		.loc 1 1904 0
 1792              		.cfi_startproc
 1793              	.LVL157:
1905:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1906:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1907:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_REQUEST(USART_Request));
1908:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
1909:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1910:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (NewState != DISABLE)
 1794              		.loc 1 1910 0
 1795 0000 002A     		cmp	r2, #0
 1796 0002 04D0     		beq	.L145
1911:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1912:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
1913:.\StdPeriphLib\src/stm32f0xx_usart.c ****        register.*/
1914:.\StdPeriphLib\src/stm32f0xx_usart.c ****       USARTx->RQR |= USART_Request;
 1797              		.loc 1 1914 0
 1798 0004 038B     		ldrh	r3, [r0, #24]
 1799 0006 1943     		orr	r1, r3
 1800              	.LVL158:
 1801 0008 89B2     		uxth	r1, r1
 1802 000a 0183     		strh	r1, [r0, #24]
 1803 000c 02E0     		b	.L144
 1804              	.LVL159:
 1805              	.L145:
1915:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1916:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
1917:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1918:.\StdPeriphLib\src/stm32f0xx_usart.c ****     /* Disable the USART ReQuest by clearing the dedicated request bit in the RQR
1919:.\StdPeriphLib\src/stm32f0xx_usart.c ****        register.*/
1920:.\StdPeriphLib\src/stm32f0xx_usart.c ****     USARTx->RQR &= (uint32_t)~USART_Request;
 1806              		.loc 1 1920 0
 1807 000e 038B     		ldrh	r3, [r0, #24]
 1808 0010 8B43     		bic	r3, r1
 1809 0012 0383     		strh	r3, [r0, #24]
 1810              	.LVL160:
 1811              	.L144:
1921:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1922:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1812              		.loc 1 1922 0
 1813              		@ sp needed
 1814 0014 7047     		bx	lr
 1815              		.cfi_endproc
 1816              	.LFE76:
 1818 0016 C046     		.section	.text.USART_OverrunDetectionConfig,"ax",%progbits
 1819              		.align	2
 1820              		.global	USART_OverrunDetectionConfig
 1821              		.code	16
 1822              		.thumb_func
 1824              	USART_OverrunDetectionConfig:
 1825              	.LFB77:
1923:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1924:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1925:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Enables or disables the USART's Overrun detection.
1926:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1927:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1928:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1929:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
1930:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_OVRDetection: specifies the OVR detection status in case of OVR error.
1931:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be any combination of the following values:
1932:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_OVRDetection_Enable: OVR error detection enabled when
1933:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *                                            the USART OVR error is asserted.
1934:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_OVRDetection_Disable: OVR error detection disabled when
1935:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *                                             the USART OVR error is asserted.
1936:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
1937:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1938:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_OverrunDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_OVRDetection)
1939:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1826              		.loc 1 1939 0
 1827              		.cfi_startproc
 1828              	.LVL161:
1940:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1941:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1942:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_OVRDETECTION(USART_OVRDetection));
1943:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
1944:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Clear the OVR detection bit */
1945:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_OVRDIS);
 1829              		.loc 1 1945 0
 1830 0000 8268     		ldr	r2, [r0, #8]
 1831 0002 034B     		ldr	r3, .L148
 1832 0004 1340     		and	r3, r2
 1833 0006 8360     		str	r3, [r0, #8]
1946:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Set the new value for the OVR detection bit */
1947:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->CR3 |= USART_OVRDetection;
 1834              		.loc 1 1947 0
 1835 0008 8368     		ldr	r3, [r0, #8]
 1836 000a 1943     		orr	r1, r3
 1837              	.LVL162:
 1838 000c 8160     		str	r1, [r0, #8]
1948:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1839              		.loc 1 1948 0
 1840              		@ sp needed
 1841 000e 7047     		bx	lr
 1842              	.L149:
 1843              		.align	2
 1844              	.L148:
 1845 0010 FFEFFFFF 		.word	-4097
 1846              		.cfi_endproc
 1847              	.LFE77:
 1849              		.section	.text.USART_GetFlagStatus,"ax",%progbits
 1850              		.align	2
 1851              		.global	USART_GetFlagStatus
 1852              		.code	16
 1853              		.thumb_func
 1855              	USART_GetFlagStatus:
 1856              	.LFB78:
1949:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
1950:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
1951:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Checks whether the specified USART flag is set or not.
1952:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
1953:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
1954:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
1955:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
1956:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_FLAG: specifies the flag to check.
1957:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be one of the following values:
1958:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_REACK:  Receive Enable acknowledge flag.
1959:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_TEACK:  Transmit Enable acknowledge flag.
1960:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_WU:  Wake up flag, not available for  STM32F030 devices.
1961:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_RWU:  Receive Wake up flag, not available for  STM32F030 devices.
1962:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_SBK:  Send Break flag.
1963:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_CM:  Character match flag.
1964:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_BUSY:  Busy flag.
1965:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_ABRF:  Auto baud rate flag.
1966:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_ABRE:  Auto baud rate error flag.
1967:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_EOB:  End of block flag, not available for  STM32F030 devices.
1968:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_RTO:  Receive time out flag.
1969:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_nCTSS:  Inverted nCTS input bit status.
1970:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_CTS:  CTS Change flag.
1971:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_LBD:  LIN Break detection flag, not available for  STM32F030 devices
1972:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_TXE:  Transmit data register empty flag.
1973:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_TC:  Transmission Complete flag.
1974:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_RXNE:  Receive data register not empty flag.
1975:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_IDLE:  Idle Line detection flag.
1976:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_ORE:  OverRun Error flag.
1977:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_NE:  Noise Error flag.
1978:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_FE:  Framing Error flag.
1979:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_PE:  Parity Error flag.
1980:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval The new state of USART_FLAG (SET or RESET).
1981:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
1982:.\StdPeriphLib\src/stm32f0xx_usart.c **** FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint32_t USART_FLAG)
1983:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1857              		.loc 1 1983 0
 1858              		.cfi_startproc
 1859              	.LVL163:
1984:.\StdPeriphLib\src/stm32f0xx_usart.c ****   FlagStatus bitstatus = RESET;
1985:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
1986:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1987:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_FLAG(USART_FLAG));
1988:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
1989:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if ((USARTx->ISR & USART_FLAG) != (uint16_t)RESET)
 1860              		.loc 1 1989 0
 1861 0000 C069     		ldr	r0, [r0, #28]
 1862              	.LVL164:
 1863 0002 0840     		and	r0, r1
 1864              	.LVL165:
 1865 0004 411E     		sub	r1, r0, #1
 1866 0006 8841     		sbc	r0, r0, r1
 1867              	.LVL166:
1990:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1991:.\StdPeriphLib\src/stm32f0xx_usart.c ****     bitstatus = SET;
1992:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1993:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
1994:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
1995:.\StdPeriphLib\src/stm32f0xx_usart.c ****     bitstatus = RESET;
1996:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
1997:.\StdPeriphLib\src/stm32f0xx_usart.c ****   return bitstatus;
 1868              		.loc 1 1997 0
 1869 0008 C0B2     		uxtb	r0, r0
1998:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1870              		.loc 1 1998 0
 1871              		@ sp needed
 1872 000a 7047     		bx	lr
 1873              		.cfi_endproc
 1874              	.LFE78:
 1876              		.section	.text.USART_ClearFlag,"ax",%progbits
 1877              		.align	2
 1878              		.global	USART_ClearFlag
 1879              		.code	16
 1880              		.thumb_func
 1882              	USART_ClearFlag:
 1883              	.LFB79:
1999:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
2000:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
2001:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Clears the USARTx's pending flags.
2002:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
2003:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
2004:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
2005:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
2006:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_FLAG: specifies the flag to clear.
2007:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be any combination of the following values:
2008:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_WU:  Wake up flag, not available for  STM32F030 devices.
2009:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_CM:  Character match flag.
2010:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_EOB:  End of block flag, not available for  STM32F030 devices.
2011:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_RTO:  Receive time out flag.
2012:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_CTS:  CTS Change flag.
2013:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_LBD:  LIN Break detection flag, not available for  STM32F030 devices
2014:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_TC:  Transmission Complete flag.
2015:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_IDLE:  IDLE line detected flag.
2016:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_ORE:  OverRun Error flag.
2017:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_NE: Noise Error flag.
2018:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_FE: Framing Error flag.
2019:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_FLAG_PE:   Parity Errorflag.
2020:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *   
2021:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note     RXNE pending bit is cleared by a read to the USART_RDR register 
2022:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           (USART_ReceiveData()) or by writing 1 to the RXFRQ in the register
2023:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           USART_RQR (USART_RequestCmd()).
2024:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note     TC flag can be also cleared by software sequence: a read operation
2025:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           to USART_SR register (USART_GetFlagStatus()) followed by a write 
2026:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           operation to USART_TDR register (USART_SendData()).
2027:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note     TXE flag is cleared by a write to the USART_TDR register (USART_SendData())
2028:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           or by writing 1 to the TXFRQ in the register USART_RQR (USART_RequestCmd()).
2029:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note     SBKF flag is cleared by 1 to the SBKRQ in the register USART_RQR
2030:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           (USART_RequestCmd()).
2031:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
2032:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
2033:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_ClearFlag(USART_TypeDef* USARTx, uint32_t USART_FLAG)
2034:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1884              		.loc 1 2034 0
 1885              		.cfi_startproc
 1886              	.LVL167:
2035:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
2036:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
2037:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
2038:.\StdPeriphLib\src/stm32f0xx_usart.c ****      
2039:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->ICR = USART_FLAG;
 1887              		.loc 1 2039 0
 1888 0000 0162     		str	r1, [r0, #32]
2040:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1889              		.loc 1 2040 0
 1890              		@ sp needed
 1891 0002 7047     		bx	lr
 1892              		.cfi_endproc
 1893              	.LFE79:
 1895              		.section	.text.USART_GetITStatus,"ax",%progbits
 1896              		.align	2
 1897              		.global	USART_GetITStatus
 1898              		.code	16
 1899              		.thumb_func
 1901              	USART_GetITStatus:
 1902              	.LFB80:
2041:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
2042:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
2043:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Checks whether the specified USART interrupt has occurred or not.
2044:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
2045:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
2046:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
2047:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
2048:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_IT: specifies the USART interrupt source to check.
2049:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be one of the following values:
2050:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_WU:  Wake up interrupt, not available for  STM32F030 devices.
2051:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_CM:  Character match interrupt.
2052:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_EOB:  End of block interrupt, not available for  STM32F030 devices.
2053:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_RTO:  Receive time out interrupt.
2054:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt.
2055:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt, not available for  STM32F030 devi
2056:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_TXE:  Tansmit Data Register empty interrupt.
2057:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_TC:  Transmission complete interrupt.
2058:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_RXNE:  Receive Data register not empty interrupt.
2059:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_IDLE:  Idle line detection interrupt.
2060:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_ORE:  OverRun Error interrupt.
2061:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_NE:  Noise Error interrupt.
2062:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_FE:  Framing Error interrupt.
2063:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_PE:  Parity Error interrupt.
2064:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval The new state of USART_IT (SET or RESET).
2065:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
2066:.\StdPeriphLib\src/stm32f0xx_usart.c **** ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint32_t USART_IT)
2067:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1903              		.loc 1 2067 0
 1904              		.cfi_startproc
 1905              	.LVL168:
 1906 0000 10B5     		push	{r4, lr}
 1907              	.LCFI5:
 1908              		.cfi_def_cfa_offset 8
 1909              		.cfi_offset 4, -8
 1910              		.cfi_offset 14, -4
 1911              	.LVL169:
2068:.\StdPeriphLib\src/stm32f0xx_usart.c ****   uint32_t bitpos = 0, itmask = 0, usartreg = 0;
2069:.\StdPeriphLib\src/stm32f0xx_usart.c ****   ITStatus bitstatus = RESET;
2070:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
2071:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
2072:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_GET_IT(USART_IT)); 
2073:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
2074:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Get the USART register index */
2075:.\StdPeriphLib\src/stm32f0xx_usart.c ****   usartreg = (((uint16_t)USART_IT) >> 0x08);
 1912              		.loc 1 2075 0
 1913 0002 8AB2     		uxth	r2, r1
 1914 0004 120A     		lsr	r2, r2, #8
 1915              	.LVL170:
2076:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Get the interrupt position */
2077:.\StdPeriphLib\src/stm32f0xx_usart.c ****   itmask = USART_IT & IT_MASK;
 1916              		.loc 1 2077 0
 1917 0006 FF23     		mov	r3, #255
 1918 0008 0B40     		and	r3, r1
 1919              	.LVL171:
 1920 000a 1C1C     		mov	r4, r3
2078:.\StdPeriphLib\src/stm32f0xx_usart.c ****   itmask = (uint32_t)0x01 << itmask;
 1921              		.loc 1 2078 0
 1922 000c 0123     		mov	r3, #1
 1923              	.LVL172:
 1924 000e A340     		lsl	r3, r3, r4
 1925              	.LVL173:
2079:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
2080:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if (usartreg == 0x01) /* The IT  is in CR1 register */
 1926              		.loc 1 2080 0
 1927 0010 012A     		cmp	r2, #1
 1928 0012 02D1     		bne	.L153
2081:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
2082:.\StdPeriphLib\src/stm32f0xx_usart.c ****     itmask &= USARTx->CR1;
 1929              		.loc 1 2082 0
 1930 0014 0268     		ldr	r2, [r0]
 1931              	.LVL174:
 1932 0016 1340     		and	r3, r2
 1933              	.LVL175:
 1934 0018 06E0     		b	.L154
 1935              	.LVL176:
 1936              	.L153:
2083:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
2084:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else if (usartreg == 0x02) /* The IT  is in CR2 register */
 1937              		.loc 1 2084 0
 1938 001a 022A     		cmp	r2, #2
 1939 001c 02D1     		bne	.L155
2085:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
2086:.\StdPeriphLib\src/stm32f0xx_usart.c ****     itmask &= USARTx->CR2;
 1940              		.loc 1 2086 0
 1941 001e 4268     		ldr	r2, [r0, #4]
 1942              	.LVL177:
 1943 0020 1340     		and	r3, r2
 1944              	.LVL178:
 1945 0022 01E0     		b	.L154
 1946              	.LVL179:
 1947              	.L155:
2087:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
2088:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else /* The IT  is in CR3 register */
2089:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
2090:.\StdPeriphLib\src/stm32f0xx_usart.c ****     itmask &= USARTx->CR3;
 1948              		.loc 1 2090 0
 1949 0024 8268     		ldr	r2, [r0, #8]
 1950              	.LVL180:
 1951 0026 1340     		and	r3, r2
 1952              	.LVL181:
 1953              	.L154:
2091:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
2092:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
2093:.\StdPeriphLib\src/stm32f0xx_usart.c ****   bitpos = USART_IT >> 0x10;
2094:.\StdPeriphLib\src/stm32f0xx_usart.c ****   bitpos = (uint32_t)0x01 << bitpos;
2095:.\StdPeriphLib\src/stm32f0xx_usart.c ****   bitpos &= USARTx->ISR;
 1954              		.loc 1 2095 0
 1955 0028 C269     		ldr	r2, [r0, #28]
 1956              	.LVL182:
2096:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
2097:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
2098:.\StdPeriphLib\src/stm32f0xx_usart.c ****     bitstatus = SET;
2099:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
2100:.\StdPeriphLib\src/stm32f0xx_usart.c ****   else
2101:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
2102:.\StdPeriphLib\src/stm32f0xx_usart.c ****     bitstatus = RESET;
 1957              		.loc 1 2102 0
 1958 002a 0020     		mov	r0, #0
 1959              	.LVL183:
2096:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 1960              		.loc 1 2096 0
 1961 002c 002B     		cmp	r3, #0
 1962 002e 07D0     		beq	.L156
2093:.\StdPeriphLib\src/stm32f0xx_usart.c ****   bitpos = (uint32_t)0x01 << bitpos;
 1963              		.loc 1 2093 0 discriminator 1
 1964 0030 090C     		lsr	r1, r1, #16
 1965              	.LVL184:
2094:.\StdPeriphLib\src/stm32f0xx_usart.c ****   bitpos &= USARTx->ISR;
 1966              		.loc 1 2094 0 discriminator 1
 1967 0032 0123     		mov	r3, #1
 1968              	.LVL185:
 1969 0034 8B40     		lsl	r3, r3, r1
2095:.\StdPeriphLib\src/stm32f0xx_usart.c ****   if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 1970              		.loc 1 2095 0 discriminator 1
 1971 0036 1A40     		and	r2, r3
 1972              	.LVL186:
 1973 0038 101C     		mov	r0, r2
2096:.\StdPeriphLib\src/stm32f0xx_usart.c ****   {
 1974              		.loc 1 2096 0 discriminator 1
 1975 003a 411E     		sub	r1, r0, #1
 1976 003c 8841     		sbc	r0, r0, r1
2098:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
 1977              		.loc 1 2098 0 discriminator 1
 1978 003e C0B2     		uxtb	r0, r0
 1979              	.L156:
 1980              	.LVL187:
2103:.\StdPeriphLib\src/stm32f0xx_usart.c ****   }
2104:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
2105:.\StdPeriphLib\src/stm32f0xx_usart.c ****   return bitstatus;  
2106:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 1981              		.loc 1 2106 0
 1982              		@ sp needed
 1983 0040 10BD     		pop	{r4, pc}
 1984              		.cfi_endproc
 1985              	.LFE80:
 1987 0042 C046     		.section	.text.USART_ClearITPendingBit,"ax",%progbits
 1988              		.align	2
 1989              		.global	USART_ClearITPendingBit
 1990              		.code	16
 1991              		.thumb_func
 1993              	USART_ClearITPendingBit:
 1994              	.LFB81:
2107:.\StdPeriphLib\src/stm32f0xx_usart.c **** 
2108:.\StdPeriphLib\src/stm32f0xx_usart.c **** /**
2109:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @brief  Clears the USARTx's interrupt pending bits.
2110:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USARTx: where x can be from 1 to 8 to select the USART peripheral.
2111:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART3 and USART4 are available only for STM32F072 and STM32F091 devices.
2112:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices. 
2113:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note   USART2 is not available for STM32F031 devices.  
2114:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @param  USART_IT: specifies the interrupt pending bit to clear.
2115:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *          This parameter can be one of the following values:
2116:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_WU:  Wake up interrupt, not available for  STM32F030 devices.
2117:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_CM:  Character match interrupt.
2118:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_EOB:  End of block interrupt, not available for  STM32F030 devices.
2119:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_RTO:  Receive time out interrupt.
2120:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt.
2121:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt, not available for  STM32F030 devi
2122:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_TC:  Transmission complete interrupt.
2123:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_IDLE:  IDLE line detected interrupt.
2124:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_ORE:  OverRun Error interrupt.
2125:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_NE:  Noise Error interrupt.
2126:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_FE:  Framing Error interrupt.
2127:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *            @arg USART_IT_PE:  Parity Error interrupt.
2128:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *
2129:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note     RXNE pending bit is cleared by a read to the USART_RDR register 
2130:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           (USART_ReceiveData()) or by writing 1 to the RXFRQ in the register 
2131:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           USART_RQR (USART_RequestCmd()).
2132:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note     TC pending bit can be also cleared by software sequence: a read 
2133:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           operation to USART_SR register (USART_GetITStatus()) followed by  
2134:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           a write operation to USART_TDR register (USART_SendData()).
2135:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @note     TXE pending bit is cleared by a write to the USART_TDR register 
2136:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           (USART_SendData()) or by writing 1 to the TXFRQ in the register 
2137:.\StdPeriphLib\src/stm32f0xx_usart.c ****   *           USART_RQR (USART_RequestCmd()).
2138:.\StdPeriphLib\src/stm32f0xx_usart.c ****   * @retval None
2139:.\StdPeriphLib\src/stm32f0xx_usart.c ****   */
2140:.\StdPeriphLib\src/stm32f0xx_usart.c **** void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint32_t USART_IT)
2141:.\StdPeriphLib\src/stm32f0xx_usart.c **** {
 1995              		.loc 1 2141 0
 1996              		.cfi_startproc
 1997              	.LVL188:
2142:.\StdPeriphLib\src/stm32f0xx_usart.c ****   uint32_t bitpos = 0, itmask = 0;
2143:.\StdPeriphLib\src/stm32f0xx_usart.c ****   /* Check the parameters */
2144:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
2145:.\StdPeriphLib\src/stm32f0xx_usart.c ****   assert_param(IS_USART_CLEAR_IT(USART_IT)); 
2146:.\StdPeriphLib\src/stm32f0xx_usart.c ****   
2147:.\StdPeriphLib\src/stm32f0xx_usart.c ****   bitpos = USART_IT >> 0x10;
 1998              		.loc 1 2147 0
 1999 0000 090C     		lsr	r1, r1, #16
 2000              	.LVL189:
2148:.\StdPeriphLib\src/stm32f0xx_usart.c ****   itmask = ((uint32_t)0x01 << (uint32_t)bitpos);
 2001              		.loc 1 2148 0
 2002 0002 0123     		mov	r3, #1
 2003 0004 8B40     		lsl	r3, r3, r1
 2004              	.LVL190:
2149:.\StdPeriphLib\src/stm32f0xx_usart.c ****   USARTx->ICR = (uint32_t)itmask;
 2005              		.loc 1 2149 0
 2006 0006 0362     		str	r3, [r0, #32]
2150:.\StdPeriphLib\src/stm32f0xx_usart.c **** }
 2007              		.loc 1 2150 0
 2008              		@ sp needed
 2009 0008 7047     		bx	lr
 2010              		.cfi_endproc
 2011              	.LFE81:
 2013 000a C046     		.text
 2014              	.Letext0:
 2015              		.file 2 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 2016              		.file 3 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 2017              		.file 4 ".\\CMSIS/stm32f0xx.h"
 2018              		.file 5 ".\\StdPeriphLib\\inc/stm32f0xx_rcc.h"
 2019              		.file 6 ".\\StdPeriphLib\\inc/stm32f0xx_usart.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f0xx_usart.c
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:18     .text.USART_DeInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:23     .text.USART_DeInit:00000000 USART_DeInit
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:192    .text.USART_DeInit:000000d8 $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:206    .text.USART_Init:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:211    .text.USART_Init:00000000 USART_Init
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:396    .text.USART_Init:000000c0 $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:407    .text.USART_StructInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:412    .text.USART_StructInit:00000000 USART_StructInit
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:440    .text.USART_ClockInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:445    .text.USART_ClockInit:00000000 USART_ClockInit
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:482    .text.USART_ClockInit:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:487    .text.USART_ClockStructInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:492    .text.USART_ClockStructInit:00000000 USART_ClockStructInit
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:513    .text.USART_Cmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:518    .text.USART_Cmd:00000000 USART_Cmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:546    .text.USART_DirectionModeCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:551    .text.USART_DirectionModeCmd:00000000 USART_DirectionModeCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:580    .text.USART_OverSampling8Cmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:585    .text.USART_OverSampling8Cmd:00000000 USART_OverSampling8Cmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:613    .text.USART_OverSampling8Cmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:618    .text.USART_OneBitMethodCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:623    .text.USART_OneBitMethodCmd:00000000 USART_OneBitMethodCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:651    .text.USART_OneBitMethodCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:656    .text.USART_MSBFirstCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:661    .text.USART_MSBFirstCmd:00000000 USART_MSBFirstCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:689    .text.USART_MSBFirstCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:694    .text.USART_DataInvCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:699    .text.USART_DataInvCmd:00000000 USART_DataInvCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:727    .text.USART_DataInvCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:732    .text.USART_InvPinCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:737    .text.USART_InvPinCmd:00000000 USART_InvPinCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:766    .text.USART_SWAPPinCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:771    .text.USART_SWAPPinCmd:00000000 USART_SWAPPinCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:799    .text.USART_SWAPPinCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:804    .text.USART_ReceiverTimeOutCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:809    .text.USART_ReceiverTimeOutCmd:00000000 USART_ReceiverTimeOutCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:837    .text.USART_ReceiverTimeOutCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:842    .text.USART_SetReceiverTimeOut:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:847    .text.USART_SetReceiverTimeOut:00000000 USART_SetReceiverTimeOut
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:869    .text.USART_SetPrescaler:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:874    .text.USART_SetPrescaler:00000000 USART_SetPrescaler
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:896    .text.USART_STOPModeCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:901    .text.USART_STOPModeCmd:00000000 USART_STOPModeCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:929    .text.USART_StopModeWakeUpSourceConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:934    .text.USART_StopModeWakeUpSourceConfig:00000000 USART_StopModeWakeUpSourceConfig
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:955    .text.USART_StopModeWakeUpSourceConfig:00000010 $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:960    .text.USART_AutoBaudRateCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:965    .text.USART_AutoBaudRateCmd:00000000 USART_AutoBaudRateCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:993    .text.USART_AutoBaudRateCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:998    .text.USART_AutoBaudRateConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1003   .text.USART_AutoBaudRateConfig:00000000 USART_AutoBaudRateConfig
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1024   .text.USART_AutoBaudRateConfig:00000010 $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1029   .text.USART_SendData:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1034   .text.USART_SendData:00000000 USART_SendData
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1051   .text.USART_ReceiveData:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1056   .text.USART_ReceiveData:00000000 USART_ReceiveData
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1073   .text.USART_SetAddress:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1078   .text.USART_SetAddress:00000000 USART_SetAddress
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1101   .text.USART_MuteModeCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1106   .text.USART_MuteModeCmd:00000000 USART_MuteModeCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1134   .text.USART_MuteModeCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1139   .text.USART_MuteModeWakeUpConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1144   .text.USART_MuteModeWakeUpConfig:00000000 USART_MuteModeWakeUpConfig
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1165   .text.USART_MuteModeWakeUpConfig:00000010 $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1170   .text.USART_AddressDetectionConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1175   .text.USART_AddressDetectionConfig:00000000 USART_AddressDetectionConfig
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1197   .text.USART_LINBreakDetectLengthConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1202   .text.USART_LINBreakDetectLengthConfig:00000000 USART_LINBreakDetectLengthConfig
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1224   .text.USART_LINCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1229   .text.USART_LINCmd:00000000 USART_LINCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1257   .text.USART_LINCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1262   .text.USART_HalfDuplexCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1267   .text.USART_HalfDuplexCmd:00000000 USART_HalfDuplexCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1295   .text.USART_SetGuardTime:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1300   .text.USART_SetGuardTime:00000000 USART_SetGuardTime
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1323   .text.USART_SmartCardCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1328   .text.USART_SmartCardCmd:00000000 USART_SmartCardCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1356   .text.USART_SmartCardNACKCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1361   .text.USART_SmartCardNACKCmd:00000000 USART_SmartCardNACKCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1389   .text.USART_SetAutoRetryCount:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1394   .text.USART_SetAutoRetryCount:00000000 USART_SetAutoRetryCount
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1416   .text.USART_SetAutoRetryCount:00000014 $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1421   .text.USART_SetBlockLength:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1426   .text.USART_SetBlockLength:00000000 USART_SetBlockLength
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1449   .text.USART_IrDAConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1454   .text.USART_IrDAConfig:00000000 USART_IrDAConfig
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1476   .text.USART_IrDACmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1481   .text.USART_IrDACmd:00000000 USART_IrDACmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1509   .text.USART_DECmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1514   .text.USART_DECmd:00000000 USART_DECmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1542   .text.USART_DECmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1547   .text.USART_DEPolarityConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1552   .text.USART_DEPolarityConfig:00000000 USART_DEPolarityConfig
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1573   .text.USART_DEPolarityConfig:00000010 $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1578   .text.USART_SetDEAssertionTime:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1583   .text.USART_SetDEAssertionTime:00000000 USART_SetDEAssertionTime
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1605   .text.USART_SetDEAssertionTime:00000014 $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1610   .text.USART_SetDEDeassertionTime:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1615   .text.USART_SetDEDeassertionTime:00000000 USART_SetDEDeassertionTime
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1637   .text.USART_SetDEDeassertionTime:00000014 $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1642   .text.USART_DMACmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1647   .text.USART_DMACmd:00000000 USART_DMACmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1676   .text.USART_DMAReceptionErrorConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1681   .text.USART_DMAReceptionErrorConfig:00000000 USART_DMAReceptionErrorConfig
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1702   .text.USART_DMAReceptionErrorConfig:00000010 $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1707   .text.USART_ITConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1712   .text.USART_ITConfig:00000000 USART_ITConfig
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1784   .text.USART_RequestCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1789   .text.USART_RequestCmd:00000000 USART_RequestCmd
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1819   .text.USART_OverrunDetectionConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1824   .text.USART_OverrunDetectionConfig:00000000 USART_OverrunDetectionConfig
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1845   .text.USART_OverrunDetectionConfig:00000010 $d
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1850   .text.USART_GetFlagStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1855   .text.USART_GetFlagStatus:00000000 USART_GetFlagStatus
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1877   .text.USART_ClearFlag:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1882   .text.USART_ClearFlag:00000000 USART_ClearFlag
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1896   .text.USART_GetITStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1901   .text.USART_GetITStatus:00000000 USART_GetITStatus
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1988   .text.USART_ClearITPendingBit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccn1kslX.s:1993   .text.USART_ClearITPendingBit:00000000 USART_ClearITPendingBit
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
RCC_APB2PeriphResetCmd
RCC_APB1PeriphResetCmd
__aeabi_uidiv
__aeabi_uidivmod
RCC_GetClocksFreq
