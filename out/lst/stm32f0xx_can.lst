   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"stm32f0xx_can.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.CAN_DeInit,"ax",%progbits
  18              		.align	2
  19              		.global	CAN_DeInit
  20              		.code	16
  21              		.thumb_func
  23              	CAN_DeInit:
  24              	.LFB33:
  25              		.file 1 ".\\StdPeriphLib\\src/stm32f0xx_can.c"
   1:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
   2:.\StdPeriphLib\src/stm32f0xx_can.c ****   ******************************************************************************
   3:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @file    stm32f0xx_can.c
   4:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @author  MCD Application Team
   5:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @version V1.5.0
   6:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @date    05-December-2014
   7:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief   This file provides firmware functions to manage the following 
   8:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          functionalities of the Controller area network (CAN) peripheral and 
   9:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          applicable only for STM32F072 devices :           
  10:.\StdPeriphLib\src/stm32f0xx_can.c ****   *           + Initialization and Configuration 
  11:.\StdPeriphLib\src/stm32f0xx_can.c ****   *           + CAN Frames Transmission 
  12:.\StdPeriphLib\src/stm32f0xx_can.c ****   *           + CAN Frames Reception    
  13:.\StdPeriphLib\src/stm32f0xx_can.c ****   *           + Operation modes switch  
  14:.\StdPeriphLib\src/stm32f0xx_can.c ****   *           + Error management          
  15:.\StdPeriphLib\src/stm32f0xx_can.c ****   *           + Interrupts and flags        
  16:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         
  17:.\StdPeriphLib\src/stm32f0xx_can.c ****   @verbatim
  18:.\StdPeriphLib\src/stm32f0xx_can.c ****                                
  19:.\StdPeriphLib\src/stm32f0xx_can.c ****  ===============================================================================      
  20:.\StdPeriphLib\src/stm32f0xx_can.c ****                       ##### How to use this driver #####
  21:.\StdPeriphLib\src/stm32f0xx_can.c ****  ===============================================================================                
  22:.\StdPeriphLib\src/stm32f0xx_can.c ****     [..]
  23:.\StdPeriphLib\src/stm32f0xx_can.c ****     (#) Enable the CAN controller interface clock using 
  24:.\StdPeriphLib\src/stm32f0xx_can.c ****         RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN, ENABLE);      
  25:.\StdPeriphLib\src/stm32f0xx_can.c ****     (#) CAN pins configuration:
  26:.\StdPeriphLib\src/stm32f0xx_can.c ****         (++) Enable the clock for the CAN GPIOs using the following function:
  27:.\StdPeriphLib\src/stm32f0xx_can.c ****              RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOx, ENABLE);   
  28:.\StdPeriphLib\src/stm32f0xx_can.c ****         (++) Connect the involved CAN pins to AF0 using the following function 
  29:.\StdPeriphLib\src/stm32f0xx_can.c ****              GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_CANx); 
  30:.\StdPeriphLib\src/stm32f0xx_can.c ****         (++) Configure these CAN pins in alternate function mode by calling
  31:.\StdPeriphLib\src/stm32f0xx_can.c ****              the function  GPIO_Init();
  32:.\StdPeriphLib\src/stm32f0xx_can.c ****     (#) Initialise and configure the CAN using CAN_Init() and 
  33:.\StdPeriphLib\src/stm32f0xx_can.c ****         CAN_FilterInit() functions.   
  34:.\StdPeriphLib\src/stm32f0xx_can.c ****     (#) Transmit the desired CAN frame using CAN_Transmit() function.
  35:.\StdPeriphLib\src/stm32f0xx_can.c ****     (#) Check the transmission of a CAN frame using CAN_TransmitStatus() function.
  36:.\StdPeriphLib\src/stm32f0xx_can.c ****     (#) Cancel the transmission of a CAN frame using CAN_CancelTransmit() function.  
  37:.\StdPeriphLib\src/stm32f0xx_can.c ****     (#) Receive a CAN frame using CAN_Recieve() function.
  38:.\StdPeriphLib\src/stm32f0xx_can.c ****     (#) Release the receive FIFOs using CAN_FIFORelease() function.
  39:.\StdPeriphLib\src/stm32f0xx_can.c ****     (#) Return the number of pending received frames using CAN_MessagePending() function.          
  40:.\StdPeriphLib\src/stm32f0xx_can.c ****     (#) To control CAN events you can use one of the following two methods:
  41:.\StdPeriphLib\src/stm32f0xx_can.c ****         (++) Check on CAN flags using the CAN_GetFlagStatus() function.  
  42:.\StdPeriphLib\src/stm32f0xx_can.c ****         (++) Use CAN interrupts through the function CAN_ITConfig() at initialization 
  43:.\StdPeriphLib\src/stm32f0xx_can.c ****              phase and CAN_GetITStatus() function into interrupt routines to check 
  44:.\StdPeriphLib\src/stm32f0xx_can.c ****              if the event has occurred or not.
  45:.\StdPeriphLib\src/stm32f0xx_can.c ****              After checking on a flag you should clear it using CAN_ClearFlag()
  46:.\StdPeriphLib\src/stm32f0xx_can.c ****              function. And after checking on an interrupt event you should clear it 
  47:.\StdPeriphLib\src/stm32f0xx_can.c ****              using CAN_ClearITPendingBit() function.            
  48:.\StdPeriphLib\src/stm32f0xx_can.c ****                  
  49:.\StdPeriphLib\src/stm32f0xx_can.c ****   @endverbatim
  50:.\StdPeriphLib\src/stm32f0xx_can.c ****   *       
  51:.\StdPeriphLib\src/stm32f0xx_can.c ****   ******************************************************************************
  52:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @attention
  53:.\StdPeriphLib\src/stm32f0xx_can.c ****   *
  54:.\StdPeriphLib\src/stm32f0xx_can.c ****   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  55:.\StdPeriphLib\src/stm32f0xx_can.c ****   *
  56:.\StdPeriphLib\src/stm32f0xx_can.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  57:.\StdPeriphLib\src/stm32f0xx_can.c ****   * You may not use this file except in compliance with the License.
  58:.\StdPeriphLib\src/stm32f0xx_can.c ****   * You may obtain a copy of the License at:
  59:.\StdPeriphLib\src/stm32f0xx_can.c ****   *
  60:.\StdPeriphLib\src/stm32f0xx_can.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  61:.\StdPeriphLib\src/stm32f0xx_can.c ****   *
  62:.\StdPeriphLib\src/stm32f0xx_can.c ****   * Unless required by applicable law or agreed to in writing, software 
  63:.\StdPeriphLib\src/stm32f0xx_can.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  64:.\StdPeriphLib\src/stm32f0xx_can.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  65:.\StdPeriphLib\src/stm32f0xx_can.c ****   * See the License for the specific language governing permissions and
  66:.\StdPeriphLib\src/stm32f0xx_can.c ****   * limitations under the License.
  67:.\StdPeriphLib\src/stm32f0xx_can.c ****   *
  68:.\StdPeriphLib\src/stm32f0xx_can.c ****   ******************************************************************************
  69:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
  70:.\StdPeriphLib\src/stm32f0xx_can.c **** 
  71:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Includes ------------------------------------------------------------------*/
  72:.\StdPeriphLib\src/stm32f0xx_can.c **** #include "stm32f0xx_can.h"
  73:.\StdPeriphLib\src/stm32f0xx_can.c **** #include "stm32f0xx_rcc.h"
  74:.\StdPeriphLib\src/stm32f0xx_can.c **** 
  75:.\StdPeriphLib\src/stm32f0xx_can.c **** /** @addtogroup STM32F0xx_StdPeriph_Driver
  76:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @{
  77:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
  78:.\StdPeriphLib\src/stm32f0xx_can.c **** 
  79:.\StdPeriphLib\src/stm32f0xx_can.c **** /** @defgroup CAN 
  80:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief CAN driver modules
  81:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @{
  82:.\StdPeriphLib\src/stm32f0xx_can.c ****   */ 
  83:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Private typedef -----------------------------------------------------------*/
  84:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Private define ------------------------------------------------------------*/
  85:.\StdPeriphLib\src/stm32f0xx_can.c **** 
  86:.\StdPeriphLib\src/stm32f0xx_can.c **** /* CAN Master Control Register bits */
  87:.\StdPeriphLib\src/stm32f0xx_can.c **** #define MCR_DBF           ((uint32_t)0x00010000) /* software master reset */
  88:.\StdPeriphLib\src/stm32f0xx_can.c **** 
  89:.\StdPeriphLib\src/stm32f0xx_can.c **** /* CAN Mailbox Transmit Request */
  90:.\StdPeriphLib\src/stm32f0xx_can.c **** #define TMIDxR_TXRQ       ((uint32_t)0x00000001) /* Transmit mailbox request */
  91:.\StdPeriphLib\src/stm32f0xx_can.c **** 
  92:.\StdPeriphLib\src/stm32f0xx_can.c **** /* CAN Filter Master Register bits */
  93:.\StdPeriphLib\src/stm32f0xx_can.c **** #define FMR_FINIT         ((uint32_t)0x00000001) /* Filter init mode */
  94:.\StdPeriphLib\src/stm32f0xx_can.c **** 
  95:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Time out for INAK bit */
  96:.\StdPeriphLib\src/stm32f0xx_can.c **** #define INAK_TIMEOUT      ((uint32_t)0x00FFFFFF)
  97:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Time out for SLAK bit */
  98:.\StdPeriphLib\src/stm32f0xx_can.c **** #define SLAK_TIMEOUT      ((uint32_t)0x00FFFFFF)
  99:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 100:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Flags in TSR register */
 101:.\StdPeriphLib\src/stm32f0xx_can.c **** #define CAN_FLAGS_TSR     ((uint32_t)0x08000000) 
 102:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Flags in RF1R register */
 103:.\StdPeriphLib\src/stm32f0xx_can.c **** #define CAN_FLAGS_RF1R    ((uint32_t)0x04000000) 
 104:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Flags in RF0R register */
 105:.\StdPeriphLib\src/stm32f0xx_can.c **** #define CAN_FLAGS_RF0R    ((uint32_t)0x02000000) 
 106:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Flags in MSR register */
 107:.\StdPeriphLib\src/stm32f0xx_can.c **** #define CAN_FLAGS_MSR     ((uint32_t)0x01000000) 
 108:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Flags in ESR register */
 109:.\StdPeriphLib\src/stm32f0xx_can.c **** #define CAN_FLAGS_ESR     ((uint32_t)0x00F00000) 
 110:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 111:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Mailboxes definition */
 112:.\StdPeriphLib\src/stm32f0xx_can.c **** #define CAN_TXMAILBOX_0   ((uint8_t)0x00)
 113:.\StdPeriphLib\src/stm32f0xx_can.c **** #define CAN_TXMAILBOX_1   ((uint8_t)0x01)
 114:.\StdPeriphLib\src/stm32f0xx_can.c **** #define CAN_TXMAILBOX_2   ((uint8_t)0x02) 
 115:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 116:.\StdPeriphLib\src/stm32f0xx_can.c **** #define CAN_MODE_MASK     ((uint32_t) 0x00000003)
 117:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 118:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Private macro -------------------------------------------------------------*/
 119:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Private variables ---------------------------------------------------------*/
 120:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Private function prototypes -----------------------------------------------*/
 121:.\StdPeriphLib\src/stm32f0xx_can.c **** /* Private functions ---------------------------------------------------------*/
 122:.\StdPeriphLib\src/stm32f0xx_can.c **** static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
 123:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 124:.\StdPeriphLib\src/stm32f0xx_can.c **** /** @defgroup CAN_Private_Functions
 125:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @{
 126:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 127:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 128:.\StdPeriphLib\src/stm32f0xx_can.c **** /** @defgroup CAN_Group1 Initialization and Configuration functions
 129:.\StdPeriphLib\src/stm32f0xx_can.c ****  *  @brief    Initialization and Configuration functions 
 130:.\StdPeriphLib\src/stm32f0xx_can.c ****  *
 131:.\StdPeriphLib\src/stm32f0xx_can.c **** @verbatim    
 132:.\StdPeriphLib\src/stm32f0xx_can.c ****  ===============================================================================
 133:.\StdPeriphLib\src/stm32f0xx_can.c ****               ##### Initialization and Configuration functions #####
 134:.\StdPeriphLib\src/stm32f0xx_can.c ****  ===============================================================================  
 135:.\StdPeriphLib\src/stm32f0xx_can.c ****     [..] This section provides functions allowing to: 
 136:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Initialize the CAN peripherals : Prescaler, operating mode, the maximum 
 137:.\StdPeriphLib\src/stm32f0xx_can.c ****              number of time quanta to perform resynchronization, the number of time 
 138:.\StdPeriphLib\src/stm32f0xx_can.c ****              quanta in Bit Segment 1 and 2 and many other modes. 
 139:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Configure the CAN reception filter.                                      
 140:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Select the start bank filter for slave CAN.
 141:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Enable or disable the Debug Freeze mode for CAN.
 142:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Enable or disable the CAN Time Trigger Operation communication mode.
 143:.\StdPeriphLib\src/stm32f0xx_can.c ****    
 144:.\StdPeriphLib\src/stm32f0xx_can.c **** @endverbatim
 145:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @{
 146:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 147:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 148:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 149:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Deinitializes the CAN peripheral registers to their default reset values.
 150:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 to select the CAN peripheral.
 151:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval None.
 152:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 153:.\StdPeriphLib\src/stm32f0xx_can.c **** void CAN_DeInit(CAN_TypeDef* CANx)
 154:.\StdPeriphLib\src/stm32f0xx_can.c **** {
  26              		.loc 1 154 0
  27              		.cfi_startproc
  28              	.LVL0:
  29 0000 10B5     		push	{r4, lr}
  30              	.LCFI0:
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 4, -8
  33              		.cfi_offset 14, -4
 155:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 156:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 157:.\StdPeriphLib\src/stm32f0xx_can.c ****  
 158:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Enable CAN reset state */
 159:.\StdPeriphLib\src/stm32f0xx_can.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, ENABLE);
  34              		.loc 1 159 0
  35 0002 8024     		mov	r4, #128
  36 0004 A404     		lsl	r4, r4, #18
  37 0006 201C     		mov	r0, r4
  38              	.LVL1:
  39 0008 0121     		mov	r1, #1
  40 000a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  41              	.LVL2:
 160:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Release CAN from reset state */
 161:.\StdPeriphLib\src/stm32f0xx_can.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, DISABLE);
  42              		.loc 1 161 0
  43 000e 201C     		mov	r0, r4
  44 0010 0021     		mov	r1, #0
  45 0012 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  46              	.LVL3:
 162:.\StdPeriphLib\src/stm32f0xx_can.c **** }
  47              		.loc 1 162 0
  48              		@ sp needed
  49 0016 10BD     		pop	{r4, pc}
  50              		.cfi_endproc
  51              	.LFE33:
  53              		.section	.text.CAN_Init,"ax",%progbits
  54              		.align	2
  55              		.global	CAN_Init
  56              		.code	16
  57              		.thumb_func
  59              	CAN_Init:
  60              	.LFB34:
 163:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 164:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 165:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Initializes the CAN peripheral according to the specified
 166:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         parameters in the CAN_InitStruct.
 167:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 to select the CAN peripheral.
 168:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that contains
 169:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         the configuration information for the CAN peripheral.
 170:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval Constant indicates initialization succeed which will be 
 171:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
 172:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 173:.\StdPeriphLib\src/stm32f0xx_can.c **** uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
 174:.\StdPeriphLib\src/stm32f0xx_can.c **** {
  61              		.loc 1 174 0
  62              		.cfi_startproc
  63              	.LVL4:
  64 0000 10B5     		push	{r4, lr}
  65              	.LCFI1:
  66              		.cfi_def_cfa_offset 8
  67              		.cfi_offset 4, -8
  68              		.cfi_offset 14, -4
  69 0002 021C     		mov	r2, r0
  70              	.LVL5:
 175:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint8_t InitStatus = CAN_InitStatus_Failed;
 176:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint32_t wait_ack = 0x00000000;
 177:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 178:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 179:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 180:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
 181:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
 182:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
 183:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
 184:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
 185:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
 186:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
 187:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
 188:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
 189:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
 190:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
 191:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 192:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Exit from sleep mode */
 193:.\StdPeriphLib\src/stm32f0xx_can.c ****   CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
  71              		.loc 1 193 0
  72 0004 0368     		ldr	r3, [r0]
  73 0006 0220     		mov	r0, #2
  74              	.LVL6:
  75 0008 8343     		bic	r3, r0
  76 000a 1360     		str	r3, [r2]
 194:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 195:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Request initialisation */
 196:.\StdPeriphLib\src/stm32f0xx_can.c ****   CANx->MCR |= CAN_MCR_INRQ ;
  77              		.loc 1 196 0
  78 000c 1368     		ldr	r3, [r2]
  79 000e 0138     		sub	r0, r0, #1
  80 0010 0343     		orr	r3, r0
  81 0012 1360     		str	r3, [r2]
 197:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 198:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Wait the acknowledge */
 199:.\StdPeriphLib\src/stm32f0xx_can.c ****   while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
  82              		.loc 1 199 0
  83 0014 5368     		ldr	r3, [r2, #4]
  84 0016 1842     		tst	r0, r3
  85 0018 07D1     		bne	.L3
  86 001a 3B4B     		ldr	r3, .L23
  87 001c 0124     		mov	r4, #1
  88              	.LVL7:
  89              	.L4:
  90 001e 5068     		ldr	r0, [r2, #4]
  91 0020 0442     		tst	r4, r0
  92 0022 02D1     		bne	.L3
  93 0024 013B     		sub	r3, r3, #1
  94              	.LVL8:
  95              		.loc 1 199 0 is_stmt 0 discriminator 1
  96 0026 002B     		cmp	r3, #0
  97 0028 F9D1     		bne	.L4
  98              	.LVL9:
  99              	.L3:
 200:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 201:.\StdPeriphLib\src/stm32f0xx_can.c ****     wait_ack++;
 202:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 203:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 204:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check acknowledge */
 205:.\StdPeriphLib\src/stm32f0xx_can.c ****   if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 100              		.loc 1 205 0 is_stmt 1
 101 002a 5368     		ldr	r3, [r2, #4]
 206:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 207:.\StdPeriphLib\src/stm32f0xx_can.c ****     InitStatus = CAN_InitStatus_Failed;
 102              		.loc 1 207 0
 103 002c 0020     		mov	r0, #0
 205:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 104              		.loc 1 205 0
 105 002e DB07     		lsl	r3, r3, #31
 106 0030 69D5     		bpl	.L5
 208:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 209:.\StdPeriphLib\src/stm32f0xx_can.c ****   else 
 210:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 211:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Set the time triggered communication mode */
 212:.\StdPeriphLib\src/stm32f0xx_can.c ****     if (CAN_InitStruct->CAN_TTCM == ENABLE)
 107              		.loc 1 212 0
 108 0032 8B79     		ldrb	r3, [r1, #6]
 109 0034 012B     		cmp	r3, #1
 110 0036 04D1     		bne	.L6
 213:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 214:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MCR |= CAN_MCR_TTCM;
 111              		.loc 1 214 0
 112 0038 1068     		ldr	r0, [r2]
 113 003a 7F33     		add	r3, r3, #127
 114 003c 0343     		orr	r3, r0
 115 003e 1360     		str	r3, [r2]
 116 0040 03E0     		b	.L7
 117              	.L6:
 215:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 216:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
 217:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 218:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
 118              		.loc 1 218 0
 119 0042 1368     		ldr	r3, [r2]
 120 0044 8020     		mov	r0, #128
 121 0046 8343     		bic	r3, r0
 122 0048 1360     		str	r3, [r2]
 123              	.L7:
 219:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 220:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 221:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Set the automatic bus-off management */
 222:.\StdPeriphLib\src/stm32f0xx_can.c ****     if (CAN_InitStruct->CAN_ABOM == ENABLE)
 124              		.loc 1 222 0
 125 004a CB79     		ldrb	r3, [r1, #7]
 126 004c 012B     		cmp	r3, #1
 127 004e 04D1     		bne	.L8
 223:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 224:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MCR |= CAN_MCR_ABOM;
 128              		.loc 1 224 0
 129 0050 1068     		ldr	r0, [r2]
 130 0052 3F33     		add	r3, r3, #63
 131 0054 0343     		orr	r3, r0
 132 0056 1360     		str	r3, [r2]
 133 0058 03E0     		b	.L9
 134              	.L8:
 225:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 226:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
 227:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 228:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
 135              		.loc 1 228 0
 136 005a 1368     		ldr	r3, [r2]
 137 005c 4020     		mov	r0, #64
 138 005e 8343     		bic	r3, r0
 139 0060 1360     		str	r3, [r2]
 140              	.L9:
 229:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 230:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 231:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Set the automatic wake-up mode */
 232:.\StdPeriphLib\src/stm32f0xx_can.c ****     if (CAN_InitStruct->CAN_AWUM == ENABLE)
 141              		.loc 1 232 0
 142 0062 0B7A     		ldrb	r3, [r1, #8]
 143 0064 012B     		cmp	r3, #1
 144 0066 04D1     		bne	.L10
 233:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 234:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MCR |= CAN_MCR_AWUM;
 145              		.loc 1 234 0
 146 0068 1068     		ldr	r0, [r2]
 147 006a 1F33     		add	r3, r3, #31
 148 006c 0343     		orr	r3, r0
 149 006e 1360     		str	r3, [r2]
 150 0070 03E0     		b	.L11
 151              	.L10:
 235:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 236:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
 237:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 238:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
 152              		.loc 1 238 0
 153 0072 1368     		ldr	r3, [r2]
 154 0074 2020     		mov	r0, #32
 155 0076 8343     		bic	r3, r0
 156 0078 1360     		str	r3, [r2]
 157              	.L11:
 239:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 240:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 241:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Set the no automatic retransmission */
 242:.\StdPeriphLib\src/stm32f0xx_can.c ****     if (CAN_InitStruct->CAN_NART == ENABLE)
 158              		.loc 1 242 0
 159 007a 4B7A     		ldrb	r3, [r1, #9]
 160 007c 012B     		cmp	r3, #1
 161 007e 04D1     		bne	.L12
 243:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 244:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MCR |= CAN_MCR_NART;
 162              		.loc 1 244 0
 163 0080 1068     		ldr	r0, [r2]
 164 0082 0F33     		add	r3, r3, #15
 165 0084 0343     		orr	r3, r0
 166 0086 1360     		str	r3, [r2]
 167 0088 03E0     		b	.L13
 168              	.L12:
 245:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 246:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
 247:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 248:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
 169              		.loc 1 248 0
 170 008a 1368     		ldr	r3, [r2]
 171 008c 1020     		mov	r0, #16
 172 008e 8343     		bic	r3, r0
 173 0090 1360     		str	r3, [r2]
 174              	.L13:
 249:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 250:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 251:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Set the receive FIFO locked mode */
 252:.\StdPeriphLib\src/stm32f0xx_can.c ****     if (CAN_InitStruct->CAN_RFLM == ENABLE)
 175              		.loc 1 252 0
 176 0092 8B7A     		ldrb	r3, [r1, #10]
 177 0094 012B     		cmp	r3, #1
 178 0096 04D1     		bne	.L14
 253:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 254:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MCR |= CAN_MCR_RFLM;
 179              		.loc 1 254 0
 180 0098 1068     		ldr	r0, [r2]
 181 009a 0733     		add	r3, r3, #7
 182 009c 0343     		orr	r3, r0
 183 009e 1360     		str	r3, [r2]
 184 00a0 03E0     		b	.L15
 185              	.L14:
 255:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 256:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
 257:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 258:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
 186              		.loc 1 258 0
 187 00a2 1368     		ldr	r3, [r2]
 188 00a4 0820     		mov	r0, #8
 189 00a6 8343     		bic	r3, r0
 190 00a8 1360     		str	r3, [r2]
 191              	.L15:
 259:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 260:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 261:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Set the transmit FIFO priority */
 262:.\StdPeriphLib\src/stm32f0xx_can.c ****     if (CAN_InitStruct->CAN_TXFP == ENABLE)
 192              		.loc 1 262 0
 193 00aa CB7A     		ldrb	r3, [r1, #11]
 194 00ac 012B     		cmp	r3, #1
 195 00ae 04D1     		bne	.L16
 263:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 264:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MCR |= CAN_MCR_TXFP;
 196              		.loc 1 264 0
 197 00b0 1068     		ldr	r0, [r2]
 198 00b2 0333     		add	r3, r3, #3
 199 00b4 0343     		orr	r3, r0
 200 00b6 1360     		str	r3, [r2]
 201 00b8 03E0     		b	.L17
 202              	.L16:
 265:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 266:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
 267:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 268:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
 203              		.loc 1 268 0
 204 00ba 1368     		ldr	r3, [r2]
 205 00bc 0420     		mov	r0, #4
 206 00be 8343     		bic	r3, r0
 207 00c0 1360     		str	r3, [r2]
 208              	.L17:
 269:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 270:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 271:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Set the bit timing register */
 272:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
 273:.\StdPeriphLib\src/stm32f0xx_can.c ****                 ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
 209              		.loc 1 273 0
 210 00c2 CB78     		ldrb	r3, [r1, #3]
 211 00c4 1C06     		lsl	r4, r3, #24
 272:.\StdPeriphLib\src/stm32f0xx_can.c ****                 ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
 212              		.loc 1 272 0
 213 00c6 8878     		ldrb	r0, [r1, #2]
 214 00c8 8307     		lsl	r3, r0, #30
 215 00ca 2343     		orr	r3, r4
 274:.\StdPeriphLib\src/stm32f0xx_can.c ****                 ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
 216              		.loc 1 274 0
 217 00cc 0879     		ldrb	r0, [r1, #4]
 218 00ce 0004     		lsl	r0, r0, #16
 273:.\StdPeriphLib\src/stm32f0xx_can.c ****                 ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
 219              		.loc 1 273 0
 220 00d0 0343     		orr	r3, r0
 275:.\StdPeriphLib\src/stm32f0xx_can.c ****                 ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
 221              		.loc 1 275 0
 222 00d2 4879     		ldrb	r0, [r1, #5]
 223 00d4 0005     		lsl	r0, r0, #20
 274:.\StdPeriphLib\src/stm32f0xx_can.c ****                 ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
 224              		.loc 1 274 0
 225 00d6 0343     		orr	r3, r0
 276:.\StdPeriphLib\src/stm32f0xx_can.c ****                ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
 226              		.loc 1 276 0
 227 00d8 0988     		ldrh	r1, [r1]
 228              	.LVL10:
 229 00da 0139     		sub	r1, r1, #1
 275:.\StdPeriphLib\src/stm32f0xx_can.c ****                 ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
 230              		.loc 1 275 0
 231 00dc 0B43     		orr	r3, r1
 272:.\StdPeriphLib\src/stm32f0xx_can.c ****                 ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
 232              		.loc 1 272 0
 233 00de D361     		str	r3, [r2, #28]
 277:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 278:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Request leave initialisation */
 279:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
 234              		.loc 1 279 0
 235 00e0 1368     		ldr	r3, [r2]
 236 00e2 0121     		mov	r1, #1
 237 00e4 8B43     		bic	r3, r1
 238 00e6 1360     		str	r3, [r2]
 239              	.LVL11:
 280:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 281:.\StdPeriphLib\src/stm32f0xx_can.c ****    /* Wait the acknowledge */
 282:.\StdPeriphLib\src/stm32f0xx_can.c ****    wait_ack = 0;
 283:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 284:.\StdPeriphLib\src/stm32f0xx_can.c ****    while (((CANx->MSR & CAN_MSR_INAK) == (uint16_t)CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 240              		.loc 1 284 0
 241 00e8 5368     		ldr	r3, [r2, #4]
 242 00ea 1942     		tst	r1, r3
 243 00ec 07D0     		beq	.L18
 244 00ee 064B     		ldr	r3, .L23
 245 00f0 0120     		mov	r0, #1
 246              	.LVL12:
 247              	.L19:
 248 00f2 5168     		ldr	r1, [r2, #4]
 249 00f4 0842     		tst	r0, r1
 250 00f6 02D0     		beq	.L18
 251 00f8 013B     		sub	r3, r3, #1
 252              	.LVL13:
 253              		.loc 1 284 0 is_stmt 0 discriminator 1
 254 00fa 002B     		cmp	r3, #0
 255 00fc F9D1     		bne	.L19
 256              	.LVL14:
 257              	.L18:
 285:.\StdPeriphLib\src/stm32f0xx_can.c ****    {
 286:.\StdPeriphLib\src/stm32f0xx_can.c ****      wait_ack++;
 287:.\StdPeriphLib\src/stm32f0xx_can.c ****    }
 288:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 289:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* ...and check acknowledged */
 290:.\StdPeriphLib\src/stm32f0xx_can.c ****     if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 258              		.loc 1 290 0 is_stmt 1
 259 00fe 5068     		ldr	r0, [r2, #4]
 260 0100 0123     		mov	r3, #1
 261 0102 5840     		eor	r0, r3
 207:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 262              		.loc 1 207 0
 263 0104 1840     		and	r0, r3
 264              	.L5:
 265              	.LVL15:
 291:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 292:.\StdPeriphLib\src/stm32f0xx_can.c ****       InitStatus = CAN_InitStatus_Failed;
 293:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 294:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
 295:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 296:.\StdPeriphLib\src/stm32f0xx_can.c ****       InitStatus = CAN_InitStatus_Success ;
 297:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 298:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 299:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 300:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* At this step, return the status of initialization */
 301:.\StdPeriphLib\src/stm32f0xx_can.c ****   return InitStatus;
 302:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 266              		.loc 1 302 0
 267              		@ sp needed
 268 0106 10BD     		pop	{r4, pc}
 269              	.L24:
 270              		.align	2
 271              	.L23:
 272 0108 FFFFFF00 		.word	16777215
 273              		.cfi_endproc
 274              	.LFE34:
 276              		.section	.text.CAN_FilterInit,"ax",%progbits
 277              		.align	2
 278              		.global	CAN_FilterInit
 279              		.code	16
 280              		.thumb_func
 282              	CAN_FilterInit:
 283              	.LFB35:
 303:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 304:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 305:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Configures the CAN reception filter according to the specified
 306:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         parameters in the CAN_FilterInitStruct.
 307:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
 308:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         contains the configuration information.
 309:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval None
 310:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 311:.\StdPeriphLib\src/stm32f0xx_can.c **** void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
 312:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 284              		.loc 1 312 0
 285              		.cfi_startproc
 286              	.LVL16:
 287 0000 70B5     		push	{r4, r5, r6, lr}
 288              	.LCFI2:
 289              		.cfi_def_cfa_offset 16
 290              		.cfi_offset 4, -16
 291              		.cfi_offset 5, -12
 292              		.cfi_offset 6, -8
 293              		.cfi_offset 14, -4
 294              	.LVL17:
 313:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint32_t filter_number_bit_pos = 0;
 314:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 315:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
 316:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
 317:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
 318:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
 319:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
 320:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 321:.\StdPeriphLib\src/stm32f0xx_can.c ****   filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
 295              		.loc 1 321 0
 296 0002 837A     		ldrb	r3, [r0, #10]
 297 0004 0121     		mov	r1, #1
 298 0006 0A1C     		mov	r2, r1
 299 0008 9A40     		lsl	r2, r2, r3
 300 000a 131C     		mov	r3, r2
 301              	.LVL18:
 322:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 323:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Initialisation mode for the filter */
 324:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN->FMR |= FMR_FINIT;
 302              		.loc 1 324 0
 303 000c 394A     		ldr	r2, .L33
 304              	.LVL19:
 305 000e 8024     		mov	r4, #128
 306 0010 A400     		lsl	r4, r4, #2
 307 0012 1559     		ldr	r5, [r2, r4]
 308 0014 2943     		orr	r1, r5
 309 0016 1151     		str	r1, [r2, r4]
 325:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 326:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Filter Deactivation */
 327:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN->FA1R &= ~(uint32_t)filter_number_bit_pos;
 310              		.loc 1 327 0
 311 0018 8725     		mov	r5, #135
 312 001a AD00     		lsl	r5, r5, #2
 313 001c 5459     		ldr	r4, [r2, r5]
 314 001e D943     		mvn	r1, r3
 315 0020 0C40     		and	r4, r1
 316 0022 5451     		str	r4, [r2, r5]
 328:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 329:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Filter Scale */
 330:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
 317              		.loc 1 330 0
 318 0024 027B     		ldrb	r2, [r0, #12]
 319 0026 002A     		cmp	r2, #0
 320 0028 16D1     		bne	.L26
 331:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 332:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* 16-bit scale for the filter */
 333:.\StdPeriphLib\src/stm32f0xx_can.c ****     CAN->FS1R &= ~(uint32_t)filter_number_bit_pos;
 321              		.loc 1 333 0
 322 002a 324C     		ldr	r4, .L33
 323 002c 103D     		sub	r5, r5, #16
 324 002e 6259     		ldr	r2, [r4, r5]
 325 0030 0A40     		and	r2, r1
 326 0032 6251     		str	r2, [r4, r5]
 334:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 335:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* First 16-bit identifier and First 16-bit mask */
 336:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Or First 16-bit identifier and Second 16-bit identifier */
 337:.\StdPeriphLib\src/stm32f0xx_can.c ****     CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 327              		.loc 1 337 0
 328 0034 827A     		ldrb	r2, [r0, #10]
 338:.\StdPeriphLib\src/stm32f0xx_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
 329              		.loc 1 338 0
 330 0036 C588     		ldrh	r5, [r0, #6]
 331 0038 2D04     		lsl	r5, r5, #16
 339:.\StdPeriphLib\src/stm32f0xx_can.c ****         (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
 332              		.loc 1 339 0
 333 003a 4688     		ldrh	r6, [r0, #2]
 338:.\StdPeriphLib\src/stm32f0xx_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
 334              		.loc 1 338 0
 335 003c 3543     		orr	r5, r6
 337:.\StdPeriphLib\src/stm32f0xx_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
 336              		.loc 1 337 0
 337 003e 4832     		add	r2, r2, #72
 338 0040 D200     		lsl	r2, r2, #3
 339 0042 1551     		str	r5, [r2, r4]
 340:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 341:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Second 16-bit identifier and Second 16-bit mask */
 342:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Or Third 16-bit identifier and Fourth 16-bit identifier */
 343:.\StdPeriphLib\src/stm32f0xx_can.c ****     CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 340              		.loc 1 343 0
 341 0044 827A     		ldrb	r2, [r0, #10]
 344:.\StdPeriphLib\src/stm32f0xx_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 342              		.loc 1 344 0
 343 0046 8488     		ldrh	r4, [r0, #4]
 344 0048 2404     		lsl	r4, r4, #16
 345:.\StdPeriphLib\src/stm32f0xx_can.c ****         (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
 345              		.loc 1 345 0
 346 004a 0588     		ldrh	r5, [r0]
 344:.\StdPeriphLib\src/stm32f0xx_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 347              		.loc 1 344 0
 348 004c 2C43     		orr	r4, r5
 343:.\StdPeriphLib\src/stm32f0xx_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 349              		.loc 1 343 0
 350 004e D200     		lsl	r2, r2, #3
 351 0050 294D     		ldr	r5, .L33+4
 352 0052 AC46     		mov	ip, r5
 353 0054 6244     		add	r2, r2, ip
 354 0056 5460     		str	r4, [r2, #4]
 355              	.L26:
 346:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 347:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 348:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
 356              		.loc 1 348 0
 357 0058 027B     		ldrb	r2, [r0, #12]
 358 005a 012A     		cmp	r2, #1
 359 005c 17D1     		bne	.L27
 349:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 350:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* 32-bit scale for the filter */
 351:.\StdPeriphLib\src/stm32f0xx_can.c ****     CAN->FS1R |= filter_number_bit_pos;
 360              		.loc 1 351 0
 361 005e 254C     		ldr	r4, .L33
 362 0060 8325     		mov	r5, #131
 363 0062 AD00     		lsl	r5, r5, #2
 364 0064 6259     		ldr	r2, [r4, r5]
 365 0066 1A43     		orr	r2, r3
 366 0068 6251     		str	r2, [r4, r5]
 352:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* 32-bit identifier or First 32-bit identifier */
 353:.\StdPeriphLib\src/stm32f0xx_can.c ****     CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 367              		.loc 1 353 0
 368 006a 827A     		ldrb	r2, [r0, #10]
 354:.\StdPeriphLib\src/stm32f0xx_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
 369              		.loc 1 354 0
 370 006c 0588     		ldrh	r5, [r0]
 371 006e 2D04     		lsl	r5, r5, #16
 355:.\StdPeriphLib\src/stm32f0xx_can.c ****         (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
 372              		.loc 1 355 0
 373 0070 4688     		ldrh	r6, [r0, #2]
 354:.\StdPeriphLib\src/stm32f0xx_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
 374              		.loc 1 354 0
 375 0072 3543     		orr	r5, r6
 353:.\StdPeriphLib\src/stm32f0xx_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
 376              		.loc 1 353 0
 377 0074 4832     		add	r2, r2, #72
 378 0076 D200     		lsl	r2, r2, #3
 379 0078 1551     		str	r5, [r2, r4]
 356:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* 32-bit mask or Second 32-bit identifier */
 357:.\StdPeriphLib\src/stm32f0xx_can.c ****     CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 380              		.loc 1 357 0
 381 007a 827A     		ldrb	r2, [r0, #10]
 358:.\StdPeriphLib\src/stm32f0xx_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 382              		.loc 1 358 0
 383 007c 8488     		ldrh	r4, [r0, #4]
 384 007e 2404     		lsl	r4, r4, #16
 359:.\StdPeriphLib\src/stm32f0xx_can.c ****         (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
 385              		.loc 1 359 0
 386 0080 C588     		ldrh	r5, [r0, #6]
 358:.\StdPeriphLib\src/stm32f0xx_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 387              		.loc 1 358 0
 388 0082 2C43     		orr	r4, r5
 357:.\StdPeriphLib\src/stm32f0xx_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 389              		.loc 1 357 0
 390 0084 D200     		lsl	r2, r2, #3
 391 0086 1C4D     		ldr	r5, .L33+4
 392 0088 AC46     		mov	ip, r5
 393 008a 6244     		add	r2, r2, ip
 394 008c 5460     		str	r4, [r2, #4]
 395              	.L27:
 360:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 361:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 362:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Filter Mode */
 363:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
 396              		.loc 1 363 0
 397 008e C27A     		ldrb	r2, [r0, #11]
 398 0090 002A     		cmp	r2, #0
 399 0092 06D1     		bne	.L28
 364:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 365:.\StdPeriphLib\src/stm32f0xx_can.c ****     /*Id/Mask mode for the filter*/
 366:.\StdPeriphLib\src/stm32f0xx_can.c ****     CAN->FM1R &= ~(uint32_t)filter_number_bit_pos;
 400              		.loc 1 366 0
 401 0094 174D     		ldr	r5, .L33
 402 0096 8124     		mov	r4, #129
 403 0098 A400     		lsl	r4, r4, #2
 404 009a 2A59     		ldr	r2, [r5, r4]
 405 009c 0A40     		and	r2, r1
 406 009e 2A51     		str	r2, [r5, r4]
 407 00a0 05E0     		b	.L29
 408              	.L28:
 367:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 368:.\StdPeriphLib\src/stm32f0xx_can.c ****   else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
 369:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 370:.\StdPeriphLib\src/stm32f0xx_can.c ****     /*Identifier list mode for the filter*/
 371:.\StdPeriphLib\src/stm32f0xx_can.c ****     CAN->FM1R |= (uint32_t)filter_number_bit_pos;
 409              		.loc 1 371 0
 410 00a2 144D     		ldr	r5, .L33
 411 00a4 8124     		mov	r4, #129
 412 00a6 A400     		lsl	r4, r4, #2
 413 00a8 2A59     		ldr	r2, [r5, r4]
 414 00aa 1A43     		orr	r2, r3
 415 00ac 2A51     		str	r2, [r5, r4]
 416              	.L29:
 372:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 373:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 374:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Filter FIFO assignment */
 375:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
 417              		.loc 1 375 0
 418 00ae 0289     		ldrh	r2, [r0, #8]
 419 00b0 002A     		cmp	r2, #0
 420 00b2 05D1     		bne	.L30
 376:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 377:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* FIFO 0 assignation for the filter */
 378:.\StdPeriphLib\src/stm32f0xx_can.c ****     CAN->FFA1R &= ~(uint32_t)filter_number_bit_pos;
 421              		.loc 1 378 0
 422 00b4 0F4C     		ldr	r4, .L33
 423 00b6 8522     		mov	r2, #133
 424 00b8 9200     		lsl	r2, r2, #2
 425 00ba A558     		ldr	r5, [r4, r2]
 426 00bc 2940     		and	r1, r5
 427 00be A150     		str	r1, [r4, r2]
 428              	.L30:
 379:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 380:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 381:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
 429              		.loc 1 381 0
 430 00c0 0289     		ldrh	r2, [r0, #8]
 431 00c2 012A     		cmp	r2, #1
 432 00c4 05D1     		bne	.L31
 382:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 383:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* FIFO 1 assignation for the filter */
 384:.\StdPeriphLib\src/stm32f0xx_can.c ****     CAN->FFA1R |= (uint32_t)filter_number_bit_pos;
 433              		.loc 1 384 0
 434 00c6 0B4C     		ldr	r4, .L33
 435 00c8 8521     		mov	r1, #133
 436 00ca 8900     		lsl	r1, r1, #2
 437 00cc 6258     		ldr	r2, [r4, r1]
 438 00ce 1A43     		orr	r2, r3
 439 00d0 6250     		str	r2, [r4, r1]
 440              	.L31:
 385:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 386:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 387:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Filter activation */
 388:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
 441              		.loc 1 388 0
 442 00d2 427B     		ldrb	r2, [r0, #13]
 443 00d4 012A     		cmp	r2, #1
 444 00d6 05D1     		bne	.L32
 389:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 390:.\StdPeriphLib\src/stm32f0xx_can.c ****     CAN->FA1R |= filter_number_bit_pos;
 445              		.loc 1 390 0
 446 00d8 0648     		ldr	r0, .L33
 447              	.LVL20:
 448 00da 8721     		mov	r1, #135
 449 00dc 8900     		lsl	r1, r1, #2
 450 00de 4258     		ldr	r2, [r0, r1]
 451 00e0 1343     		orr	r3, r2
 452              	.LVL21:
 453 00e2 4350     		str	r3, [r0, r1]
 454              	.L32:
 391:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 392:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 393:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Leave the initialisation mode for the filter */
 394:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN->FMR &= ~FMR_FINIT;
 455              		.loc 1 394 0
 456 00e4 0349     		ldr	r1, .L33
 457 00e6 8022     		mov	r2, #128
 458 00e8 9200     		lsl	r2, r2, #2
 459 00ea 8B58     		ldr	r3, [r1, r2]
 460 00ec 0120     		mov	r0, #1
 461 00ee 8343     		bic	r3, r0
 462 00f0 8B50     		str	r3, [r1, r2]
 395:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 463              		.loc 1 395 0
 464              		@ sp needed
 465 00f2 70BD     		pop	{r4, r5, r6, pc}
 466              	.L34:
 467              		.align	2
 468              	.L33:
 469 00f4 00640040 		.word	1073767424
 470 00f8 40660040 		.word	1073768000
 471              		.cfi_endproc
 472              	.LFE35:
 474              		.section	.text.CAN_StructInit,"ax",%progbits
 475              		.align	2
 476              		.global	CAN_StructInit
 477              		.code	16
 478              		.thumb_func
 480              	CAN_StructInit:
 481              	.LFB36:
 396:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 397:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 398:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Fills each CAN_InitStruct member with its default value.
 399:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which ill be initialized.
 400:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval None
 401:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 402:.\StdPeriphLib\src/stm32f0xx_can.c **** void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
 403:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 482              		.loc 1 403 0
 483              		.cfi_startproc
 484              	.LVL22:
 404:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Reset CAN init structure parameters values */
 405:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 406:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Initialize the time triggered communication mode */
 407:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN_InitStruct->CAN_TTCM = DISABLE;
 485              		.loc 1 407 0
 486 0000 0023     		mov	r3, #0
 487 0002 8371     		strb	r3, [r0, #6]
 408:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 409:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Initialize the automatic bus-off management */
 410:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN_InitStruct->CAN_ABOM = DISABLE;
 488              		.loc 1 410 0
 489 0004 C371     		strb	r3, [r0, #7]
 411:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 412:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Initialize the automatic wake-up mode */
 413:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN_InitStruct->CAN_AWUM = DISABLE;
 490              		.loc 1 413 0
 491 0006 0372     		strb	r3, [r0, #8]
 414:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 415:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Initialize the no automatic retransmission */
 416:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN_InitStruct->CAN_NART = DISABLE;
 492              		.loc 1 416 0
 493 0008 4372     		strb	r3, [r0, #9]
 417:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 418:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Initialize the receive FIFO locked mode */
 419:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN_InitStruct->CAN_RFLM = DISABLE;
 494              		.loc 1 419 0
 495 000a 8372     		strb	r3, [r0, #10]
 420:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 421:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Initialize the transmit FIFO priority */
 422:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN_InitStruct->CAN_TXFP = DISABLE;
 496              		.loc 1 422 0
 497 000c C372     		strb	r3, [r0, #11]
 423:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 424:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Initialize the CAN_Mode member */
 425:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
 498              		.loc 1 425 0
 499 000e 8370     		strb	r3, [r0, #2]
 426:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 427:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Initialize the CAN_SJW member */
 428:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
 500              		.loc 1 428 0
 501 0010 C370     		strb	r3, [r0, #3]
 429:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 430:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Initialize the CAN_BS1 member */
 431:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
 502              		.loc 1 431 0
 503 0012 0333     		add	r3, r3, #3
 504 0014 0371     		strb	r3, [r0, #4]
 432:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 433:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Initialize the CAN_BS2 member */
 434:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
 505              		.loc 1 434 0
 506 0016 013B     		sub	r3, r3, #1
 507 0018 4371     		strb	r3, [r0, #5]
 435:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 436:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Initialize the CAN_Prescaler member */
 437:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN_InitStruct->CAN_Prescaler = 1;
 508              		.loc 1 437 0
 509 001a 013B     		sub	r3, r3, #1
 510 001c 0380     		strh	r3, [r0]
 438:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 511              		.loc 1 438 0
 512              		@ sp needed
 513 001e 7047     		bx	lr
 514              		.cfi_endproc
 515              	.LFE36:
 517              		.section	.text.CAN_SlaveStartBank,"ax",%progbits
 518              		.align	2
 519              		.global	CAN_SlaveStartBank
 520              		.code	16
 521              		.thumb_func
 523              	CAN_SlaveStartBank:
 524              	.LFB37:
 439:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 440:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 441:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Select the start bank filter for slave CAN.
 442:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
 443:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval None
 444:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 445:.\StdPeriphLib\src/stm32f0xx_can.c **** void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
 446:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 525              		.loc 1 446 0
 526              		.cfi_startproc
 527              	.LVL23:
 528 0000 30B5     		push	{r4, r5, lr}
 529              	.LCFI3:
 530              		.cfi_def_cfa_offset 12
 531              		.cfi_offset 4, -12
 532              		.cfi_offset 5, -8
 533              		.cfi_offset 14, -4
 447:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 448:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
 449:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 450:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Enter Initialisation mode for the filter */
 451:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN->FMR |= FMR_FINIT;
 534              		.loc 1 451 0
 535 0002 094A     		ldr	r2, .L37
 536 0004 8023     		mov	r3, #128
 537 0006 9B00     		lsl	r3, r3, #2
 538 0008 D158     		ldr	r1, [r2, r3]
 539 000a 0124     		mov	r4, #1
 540 000c 2143     		orr	r1, r4
 541 000e D150     		str	r1, [r2, r3]
 452:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 453:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Select the start slave bank */
 454:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN->FMR &= (uint32_t)0xFFFFC0F1 ;
 542              		.loc 1 454 0
 543 0010 D558     		ldr	r5, [r2, r3]
 544 0012 0649     		ldr	r1, .L37+4
 545 0014 2940     		and	r1, r5
 546 0016 D150     		str	r1, [r2, r3]
 455:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN->FMR |= (uint32_t)(CAN_BankNumber)<<8;
 547              		.loc 1 455 0
 548 0018 D158     		ldr	r1, [r2, r3]
 549 001a 0002     		lsl	r0, r0, #8
 550              	.LVL24:
 551 001c 0843     		orr	r0, r1
 552 001e D050     		str	r0, [r2, r3]
 456:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 457:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Leave Initialisation mode for the filter */
 458:.\StdPeriphLib\src/stm32f0xx_can.c ****   CAN->FMR &= ~FMR_FINIT;
 553              		.loc 1 458 0
 554 0020 D158     		ldr	r1, [r2, r3]
 555 0022 A143     		bic	r1, r4
 556 0024 D150     		str	r1, [r2, r3]
 459:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 557              		.loc 1 459 0
 558              		@ sp needed
 559 0026 30BD     		pop	{r4, r5, pc}
 560              	.L38:
 561              		.align	2
 562              	.L37:
 563 0028 00640040 		.word	1073767424
 564 002c F1C0FFFF 		.word	-16143
 565              		.cfi_endproc
 566              	.LFE37:
 568              		.section	.text.CAN_DBGFreeze,"ax",%progbits
 569              		.align	2
 570              		.global	CAN_DBGFreeze
 571              		.code	16
 572              		.thumb_func
 574              	CAN_DBGFreeze:
 575              	.LFB38:
 460:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 461:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 462:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Enables or disables the DBG Freeze for CAN.
 463:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
 464:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  NewState: new state of the CAN peripheral. 
 465:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          This parameter can be: ENABLE (CAN reception/transmission is frozen
 466:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          during debug. Reception FIFOs can still be accessed/controlled normally) 
 467:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          or DISABLE (CAN is working during debug).
 468:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval None
 469:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 470:.\StdPeriphLib\src/stm32f0xx_can.c **** void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
 471:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 576              		.loc 1 471 0
 577              		.cfi_startproc
 578              	.LVL25:
 472:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 473:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 474:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 475:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 476:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (NewState != DISABLE)
 579              		.loc 1 476 0
 580 0000 0029     		cmp	r1, #0
 581 0002 05D0     		beq	.L40
 477:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 478:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Enable Debug Freeze  */
 479:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->MCR |= MCR_DBF;
 582              		.loc 1 479 0
 583 0004 0368     		ldr	r3, [r0]
 584 0006 8022     		mov	r2, #128
 585 0008 5202     		lsl	r2, r2, #9
 586 000a 1343     		orr	r3, r2
 587 000c 0360     		str	r3, [r0]
 588 000e 03E0     		b	.L39
 589              	.L40:
 480:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 481:.\StdPeriphLib\src/stm32f0xx_can.c ****   else
 482:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 483:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Disable Debug Freeze */
 484:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->MCR &= ~MCR_DBF;
 590              		.loc 1 484 0
 591 0010 0268     		ldr	r2, [r0]
 592 0012 024B     		ldr	r3, .L42
 593 0014 1340     		and	r3, r2
 594 0016 0360     		str	r3, [r0]
 595              	.L39:
 485:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 486:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 596              		.loc 1 486 0
 597              		@ sp needed
 598 0018 7047     		bx	lr
 599              	.L43:
 600 001a C046     		.align	2
 601              	.L42:
 602 001c FFFFFEFF 		.word	-65537
 603              		.cfi_endproc
 604              	.LFE38:
 606              		.section	.text.CAN_TTComModeCmd,"ax",%progbits
 607              		.align	2
 608              		.global	CAN_TTComModeCmd
 609              		.code	16
 610              		.thumb_func
 612              	CAN_TTComModeCmd:
 613              	.LFB39:
 487:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 488:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 489:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Enables or disables the CAN Time TriggerOperation communication mode.
 490:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
 491:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         sent over the CAN bus.  
 492:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
 493:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  NewState: Mode new state. This parameter can be: ENABLE or DISABLE.
 494:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         When enabled, Time stamp (TIME[15:0]) value is  sent in the last two
 495:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         data bytes of the 8-byte message: TIME[7:0] in data byte 6 and TIME[15:8] 
 496:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         in data byte 7. 
 497:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval None
 498:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 499:.\StdPeriphLib\src/stm32f0xx_can.c **** void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
 500:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 614              		.loc 1 500 0
 615              		.cfi_startproc
 616              	.LVL26:
 501:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 502:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 503:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 504:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (NewState != DISABLE)
 617              		.loc 1 504 0
 618 0000 0029     		cmp	r1, #0
 619 0002 13D0     		beq	.L45
 505:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 506:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Enable the TTCM mode */
 507:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->MCR |= CAN_MCR_TTCM;
 620              		.loc 1 507 0
 621 0004 0268     		ldr	r2, [r0]
 622 0006 8023     		mov	r3, #128
 623 0008 1343     		orr	r3, r2
 624 000a 0360     		str	r3, [r0]
 508:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 509:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Set TGT bits */
 510:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
 625              		.loc 1 510 0
 626 000c C221     		mov	r1, #194
 627              	.LVL27:
 628 000e 4900     		lsl	r1, r1, #1
 629 0010 4358     		ldr	r3, [r0, r1]
 630 0012 8022     		mov	r2, #128
 631 0014 5200     		lsl	r2, r2, #1
 632 0016 1343     		orr	r3, r2
 633 0018 4350     		str	r3, [r0, r1]
 511:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
 634              		.loc 1 511 0
 635 001a 1031     		add	r1, r1, #16
 636 001c 4358     		ldr	r3, [r0, r1]
 637 001e 1343     		orr	r3, r2
 638 0020 4350     		str	r3, [r0, r1]
 512:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
 639              		.loc 1 512 0
 640 0022 1031     		add	r1, r1, #16
 641 0024 4358     		ldr	r3, [r0, r1]
 642 0026 1343     		orr	r3, r2
 643 0028 4350     		str	r3, [r0, r1]
 644 002a 12E0     		b	.L44
 645              	.LVL28:
 646              	.L45:
 513:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 514:.\StdPeriphLib\src/stm32f0xx_can.c ****   else
 515:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 516:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Disable the TTCM mode */
 517:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
 647              		.loc 1 517 0
 648 002c 0368     		ldr	r3, [r0]
 649 002e 8022     		mov	r2, #128
 650 0030 9343     		bic	r3, r2
 651 0032 0360     		str	r3, [r0]
 518:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 519:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Reset TGT bits */
 520:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
 652              		.loc 1 520 0
 653 0034 C221     		mov	r1, #194
 654              	.LVL29:
 655 0036 4900     		lsl	r1, r1, #1
 656 0038 4258     		ldr	r2, [r0, r1]
 657 003a 064B     		ldr	r3, .L47
 658 003c 1A40     		and	r2, r3
 659 003e 4250     		str	r2, [r0, r1]
 521:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
 660              		.loc 1 521 0
 661 0040 1031     		add	r1, r1, #16
 662 0042 4258     		ldr	r2, [r0, r1]
 663 0044 1A40     		and	r2, r3
 664 0046 4250     		str	r2, [r0, r1]
 522:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
 665              		.loc 1 522 0
 666 0048 D222     		mov	r2, #210
 667 004a 5200     		lsl	r2, r2, #1
 668 004c 8158     		ldr	r1, [r0, r2]
 669 004e 0B40     		and	r3, r1
 670 0050 8350     		str	r3, [r0, r2]
 671              	.L44:
 523:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 524:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 672              		.loc 1 524 0
 673              		@ sp needed
 674 0052 7047     		bx	lr
 675              	.L48:
 676              		.align	2
 677              	.L47:
 678 0054 FFFEFFFF 		.word	-257
 679              		.cfi_endproc
 680              	.LFE39:
 682              		.section	.text.CAN_Transmit,"ax",%progbits
 683              		.align	2
 684              		.global	CAN_Transmit
 685              		.code	16
 686              		.thumb_func
 688              	CAN_Transmit:
 689              	.LFB40:
 525:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 526:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @}
 527:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 528:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 529:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 530:.\StdPeriphLib\src/stm32f0xx_can.c **** /** @defgroup CAN_Group2 CAN Frames Transmission functions
 531:.\StdPeriphLib\src/stm32f0xx_can.c ****  *  @brief    CAN Frames Transmission functions 
 532:.\StdPeriphLib\src/stm32f0xx_can.c ****  *
 533:.\StdPeriphLib\src/stm32f0xx_can.c **** @verbatim    
 534:.\StdPeriphLib\src/stm32f0xx_can.c ****  ===============================================================================
 535:.\StdPeriphLib\src/stm32f0xx_can.c ****                 ##### CAN Frames Transmission functions #####
 536:.\StdPeriphLib\src/stm32f0xx_can.c ****  ===============================================================================  
 537:.\StdPeriphLib\src/stm32f0xx_can.c ****     [..] This section provides functions allowing to 
 538:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Initiate and transmit a CAN frame message (if there is an empty mailbox).
 539:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Check the transmission status of a CAN Frame.
 540:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Cancel a transmit request.
 541:.\StdPeriphLib\src/stm32f0xx_can.c ****    
 542:.\StdPeriphLib\src/stm32f0xx_can.c **** @endverbatim
 543:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @{
 544:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 545:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 546:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 547:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Initiates and transmits a CAN frame message.
 548:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
 549:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
 550:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval The number of the mailbox that is used for transmission or
 551:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
 552:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 553:.\StdPeriphLib\src/stm32f0xx_can.c **** uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
 554:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 690              		.loc 1 554 0
 691              		.cfi_startproc
 692              	.LVL30:
 693 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 694              	.LCFI4:
 695              		.cfi_def_cfa_offset 20
 696              		.cfi_offset 4, -20
 697              		.cfi_offset 5, -16
 698              		.cfi_offset 6, -12
 699              		.cfi_offset 7, -8
 700              		.cfi_offset 14, -4
 701              	.LVL31:
 555:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint8_t transmit_mailbox = 0;
 556:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 557:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 558:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
 559:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_RTR(TxMessage->RTR));
 560:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_DLC(TxMessage->DLC));
 561:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 562:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Select one empty transmit mailbox */
 563:.\StdPeriphLib\src/stm32f0xx_can.c ****   if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
 702              		.loc 1 563 0
 703 0002 8368     		ldr	r3, [r0, #8]
 704 0004 5B01     		lsl	r3, r3, #5
 705 0006 4FD4     		bmi	.L55
 564:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 565:.\StdPeriphLib\src/stm32f0xx_can.c ****     transmit_mailbox = 0;
 566:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 567:.\StdPeriphLib\src/stm32f0xx_can.c ****   else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
 706              		.loc 1 567 0
 707 0008 8368     		ldr	r3, [r0, #8]
 708 000a 1B01     		lsl	r3, r3, #4
 709 000c 4ED4     		bmi	.L56
 568:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 569:.\StdPeriphLib\src/stm32f0xx_can.c ****     transmit_mailbox = 1;
 570:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 571:.\StdPeriphLib\src/stm32f0xx_can.c ****   else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
 710              		.loc 1 571 0
 711 000e 8368     		ldr	r3, [r0, #8]
 572:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 573:.\StdPeriphLib\src/stm32f0xx_can.c ****     transmit_mailbox = 2;
 574:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 575:.\StdPeriphLib\src/stm32f0xx_can.c ****   else
 576:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 577:.\StdPeriphLib\src/stm32f0xx_can.c ****     transmit_mailbox = CAN_TxStatus_NoMailBox;
 712              		.loc 1 577 0
 713 0010 0425     		mov	r5, #4
 571:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 714              		.loc 1 571 0
 715 0012 DB00     		lsl	r3, r3, #3
 716 0014 5AD5     		bpl	.L58
 717 0016 4BE0     		b	.L57
 718              	.LVL32:
 719              	.L53:
 578:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 579:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 580:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (transmit_mailbox != CAN_TxStatus_NoMailBox)
 581:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 582:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Set up the Id */
 583:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
 584:.\StdPeriphLib\src/stm32f0xx_can.c ****     if (TxMessage->IDE == CAN_Id_Standard)
 585:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 586:.\StdPeriphLib\src/stm32f0xx_can.c ****       assert_param(IS_CAN_STDID(TxMessage->StdId));  
 587:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
 720              		.loc 1 587 0
 721 0018 C024     		mov	r4, #192
 722 001a 6400     		lsl	r4, r4, #1
 723 001c A446     		mov	ip, r4
 724 001e 1E59     		ldr	r6, [r3, r4]
 725 0020 0C68     		ldr	r4, [r1]
 726 0022 6705     		lsl	r7, r4, #21
 727 0024 4C7A     		ldrb	r4, [r1, #9]
 728 0026 3C43     		orr	r4, r7
 729 0028 3443     		orr	r4, r6
 730 002a 6646     		mov	r6, ip
 731 002c 9C51     		str	r4, [r3, r6]
 732 002e 0BE0     		b	.L52
 733              	.L59:
 588:.\StdPeriphLib\src/stm32f0xx_can.c ****                                                   TxMessage->RTR);
 589:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 590:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
 591:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 592:.\StdPeriphLib\src/stm32f0xx_can.c ****       assert_param(IS_CAN_EXTID(TxMessage->ExtId));
 593:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
 734              		.loc 1 593 0
 735 0030 C026     		mov	r6, #192
 736 0032 7600     		lsl	r6, r6, #1
 737 0034 B446     		mov	ip, r6
 738 0036 9E59     		ldr	r6, [r3, r6]
 739 0038 4F68     		ldr	r7, [r1, #4]
 740 003a FF00     		lsl	r7, r7, #3
 741 003c 3C43     		orr	r4, r7
 742 003e 3443     		orr	r4, r6
 594:.\StdPeriphLib\src/stm32f0xx_can.c ****                                                   TxMessage->IDE | \
 743              		.loc 1 594 0
 744 0040 4E7A     		ldrb	r6, [r1, #9]
 593:.\StdPeriphLib\src/stm32f0xx_can.c ****                                                   TxMessage->IDE | \
 745              		.loc 1 593 0
 746 0042 3443     		orr	r4, r6
 747 0044 6646     		mov	r6, ip
 748 0046 9C51     		str	r4, [r3, r6]
 749              	.L52:
 595:.\StdPeriphLib\src/stm32f0xx_can.c ****                                                   TxMessage->RTR);
 596:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 597:.\StdPeriphLib\src/stm32f0xx_can.c ****     
 598:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Set up the DLC */
 599:.\StdPeriphLib\src/stm32f0xx_can.c ****     TxMessage->DLC &= (uint8_t)0x0000000F;
 750              		.loc 1 599 0
 751 0048 8C7A     		ldrb	r4, [r1, #10]
 752 004a 0F26     		mov	r6, #15
 753 004c 3440     		and	r4, r6
 754 004e 8C72     		strb	r4, [r1, #10]
 600:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
 755              		.loc 1 600 0
 756 0050 C224     		mov	r4, #194
 757 0052 6400     		lsl	r4, r4, #1
 758 0054 1E59     		ldr	r6, [r3, r4]
 759 0056 0F27     		mov	r7, #15
 760 0058 BE43     		bic	r6, r7
 761 005a 1E51     		str	r6, [r3, r4]
 601:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
 762              		.loc 1 601 0
 763 005c 1E59     		ldr	r6, [r3, r4]
 764 005e 8F7A     		ldrb	r7, [r1, #10]
 765 0060 3E43     		orr	r6, r7
 766 0062 1E51     		str	r6, [r3, r4]
 602:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 603:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Set up the data field */
 604:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
 767              		.loc 1 604 0
 768 0064 8C7B     		ldrb	r4, [r1, #14]
 769 0066 2606     		lsl	r6, r4, #24
 605:.\StdPeriphLib\src/stm32f0xx_can.c ****                                              ((uint32_t)TxMessage->Data[2] << 16) |
 770              		.loc 1 605 0
 771 0068 4C7B     		ldrb	r4, [r1, #13]
 772 006a 2404     		lsl	r4, r4, #16
 604:.\StdPeriphLib\src/stm32f0xx_can.c ****                                              ((uint32_t)TxMessage->Data[2] << 16) |
 773              		.loc 1 604 0
 774 006c 3443     		orr	r4, r6
 606:.\StdPeriphLib\src/stm32f0xx_can.c ****                                              ((uint32_t)TxMessage->Data[1] << 8) | 
 607:.\StdPeriphLib\src/stm32f0xx_can.c ****                                              ((uint32_t)TxMessage->Data[0]));
 775              		.loc 1 607 0
 776 006e CE7A     		ldrb	r6, [r1, #11]
 777 0070 3443     		orr	r4, r6
 606:.\StdPeriphLib\src/stm32f0xx_can.c ****                                              ((uint32_t)TxMessage->Data[1] << 8) | 
 778              		.loc 1 606 0
 779 0072 0E7B     		ldrb	r6, [r1, #12]
 780 0074 3602     		lsl	r6, r6, #8
 781 0076 3443     		orr	r4, r6
 604:.\StdPeriphLib\src/stm32f0xx_can.c ****                                              ((uint32_t)TxMessage->Data[2] << 16) |
 782              		.loc 1 604 0
 783 0078 1201     		lsl	r2, r2, #4
 784 007a 8218     		add	r2, r0, r2
 785 007c 8932     		add	r2, r2, #137
 786 007e FF32     		add	r2, r2, #255
 787 0080 1460     		str	r4, [r2]
 608:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
 788              		.loc 1 608 0
 789 0082 887C     		ldrb	r0, [r1, #18]
 790              	.LVL33:
 791 0084 0406     		lsl	r4, r0, #24
 609:.\StdPeriphLib\src/stm32f0xx_can.c ****                                              ((uint32_t)TxMessage->Data[6] << 16) |
 792              		.loc 1 609 0
 793 0086 487C     		ldrb	r0, [r1, #17]
 794 0088 0004     		lsl	r0, r0, #16
 608:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
 795              		.loc 1 608 0
 796 008a 2043     		orr	r0, r4
 610:.\StdPeriphLib\src/stm32f0xx_can.c ****                                              ((uint32_t)TxMessage->Data[5] << 8) |
 611:.\StdPeriphLib\src/stm32f0xx_can.c ****                                              ((uint32_t)TxMessage->Data[4]));
 797              		.loc 1 611 0
 798 008c CC7B     		ldrb	r4, [r1, #15]
 799 008e 2043     		orr	r0, r4
 610:.\StdPeriphLib\src/stm32f0xx_can.c ****                                              ((uint32_t)TxMessage->Data[5] << 8) |
 800              		.loc 1 610 0
 801 0090 0C7C     		ldrb	r4, [r1, #16]
 802 0092 2402     		lsl	r4, r4, #8
 803 0094 011C     		mov	r1, r0
 804              	.LVL34:
 805 0096 2143     		orr	r1, r4
 608:.\StdPeriphLib\src/stm32f0xx_can.c ****                                              ((uint32_t)TxMessage->Data[6] << 16) |
 806              		.loc 1 608 0
 807 0098 5160     		str	r1, [r2, #4]
 612:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Request transmission */
 613:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
 808              		.loc 1 613 0
 809 009a C021     		mov	r1, #192
 810 009c 4900     		lsl	r1, r1, #1
 811 009e 5858     		ldr	r0, [r3, r1]
 812 00a0 0122     		mov	r2, #1
 813 00a2 0243     		orr	r2, r0
 814 00a4 5A50     		str	r2, [r3, r1]
 815 00a6 11E0     		b	.L58
 816              	.LVL35:
 817              	.L55:
 565:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 818              		.loc 1 565 0
 819 00a8 0025     		mov	r5, #0
 820 00aa 02E0     		b	.L50
 821              	.L56:
 569:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 822              		.loc 1 569 0
 823 00ac 0125     		mov	r5, #1
 824 00ae 00E0     		b	.L50
 825              	.L57:
 573:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 826              		.loc 1 573 0
 827 00b0 0225     		mov	r5, #2
 828              	.L50:
 829              	.LVL36:
 583:.\StdPeriphLib\src/stm32f0xx_can.c ****     if (TxMessage->IDE == CAN_Id_Standard)
 830              		.loc 1 583 0
 831 00b2 2A1C     		mov	r2, r5
 832 00b4 2B01     		lsl	r3, r5, #4
 833 00b6 C318     		add	r3, r0, r3
 834 00b8 C026     		mov	r6, #192
 835 00ba 7600     		lsl	r6, r6, #1
 836 00bc 9C59     		ldr	r4, [r3, r6]
 837 00be 0127     		mov	r7, #1
 838 00c0 3C40     		and	r4, r7
 839 00c2 9C51     		str	r4, [r3, r6]
 584:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 840              		.loc 1 584 0
 841 00c4 0C7A     		ldrb	r4, [r1, #8]
 842 00c6 002C     		cmp	r4, #0
 843 00c8 A6D0     		beq	.L53
 844 00ca B1E7     		b	.L59
 845              	.LVL37:
 846              	.L58:
 614:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 615:.\StdPeriphLib\src/stm32f0xx_can.c ****   return transmit_mailbox;
 616:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 847              		.loc 1 616 0
 848 00cc 281C     		mov	r0, r5
 849              		@ sp needed
 850 00ce F0BD     		pop	{r4, r5, r6, r7, pc}
 851              		.cfi_endproc
 852              	.LFE40:
 854              		.section	.text.CAN_TransmitStatus,"ax",%progbits
 855              		.align	2
 856              		.global	CAN_TransmitStatus
 857              		.code	16
 858              		.thumb_func
 860              	CAN_TransmitStatus:
 861              	.LFB41:
 617:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 618:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 619:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Checks the transmission status of a CAN Frame.
 620:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 to select the CAN peripheral.
 621:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
 622:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, 
 623:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         CAN_TxStatus_Failed in an other case.
 624:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 625:.\StdPeriphLib\src/stm32f0xx_can.c **** uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
 626:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 862              		.loc 1 626 0
 863              		.cfi_startproc
 864              	.LVL38:
 627:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint32_t state = 0;
 628:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 629:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 630:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 631:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
 632:.\StdPeriphLib\src/stm32f0xx_can.c ****  
 633:.\StdPeriphLib\src/stm32f0xx_can.c ****   switch (TransmitMailbox)
 865              		.loc 1 633 0
 866 0000 0129     		cmp	r1, #1
 867 0002 08D0     		beq	.L62
 868 0004 0029     		cmp	r1, #0
 869 0006 02D0     		beq	.L63
 870 0008 0229     		cmp	r1, #2
 871 000a 08D0     		beq	.L64
 872 000c 0BE0     		b	.L73
 873              	.L63:
 634:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 635:.\StdPeriphLib\src/stm32f0xx_can.c ****     case (CAN_TXMAILBOX_0): 
 636:.\StdPeriphLib\src/stm32f0xx_can.c ****       state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
 874              		.loc 1 636 0
 875 000e 8268     		ldr	r2, [r0, #8]
 876 0010 0F4B     		ldr	r3, .L74
 877 0012 1340     		and	r3, r2
 878              	.LVL39:
 637:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 879              		.loc 1 637 0
 880 0014 08E0     		b	.L61
 881              	.LVL40:
 882              	.L62:
 638:.\StdPeriphLib\src/stm32f0xx_can.c ****     case (CAN_TXMAILBOX_1): 
 639:.\StdPeriphLib\src/stm32f0xx_can.c ****       state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
 883              		.loc 1 639 0
 884 0016 8268     		ldr	r2, [r0, #8]
 885 0018 0E4B     		ldr	r3, .L74+4
 886 001a 1340     		and	r3, r2
 887              	.LVL41:
 640:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 888              		.loc 1 640 0
 889 001c 04E0     		b	.L61
 890              	.LVL42:
 891              	.L64:
 641:.\StdPeriphLib\src/stm32f0xx_can.c ****     case (CAN_TXMAILBOX_2): 
 642:.\StdPeriphLib\src/stm32f0xx_can.c ****       state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
 892              		.loc 1 642 0
 893 001e 8268     		ldr	r2, [r0, #8]
 894 0020 0D4B     		ldr	r3, .L74+8
 895 0022 1340     		and	r3, r2
 896              	.LVL43:
 643:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 897              		.loc 1 643 0
 898 0024 00E0     		b	.L61
 899              	.LVL44:
 900              	.L73:
 644:.\StdPeriphLib\src/stm32f0xx_can.c ****     default:
 645:.\StdPeriphLib\src/stm32f0xx_can.c ****       state = CAN_TxStatus_Failed;
 901              		.loc 1 645 0
 902 0026 0023     		mov	r3, #0
 903              	.LVL45:
 904              	.L61:
 646:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 647:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 648:.\StdPeriphLib\src/stm32f0xx_can.c ****   switch (state)
 905              		.loc 1 648 0
 906 0028 094A     		ldr	r2, .L74
 907 002a 9342     		cmp	r3, r2
 908 002c 0DD0     		beq	.L66
 909 002e 03D8     		bhi	.L67
 649:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 650:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* transmit pending  */
 651:.\StdPeriphLib\src/stm32f0xx_can.c ****     case (0x0): state = CAN_TxStatus_Pending;
 910              		.loc 1 651 0
 911 0030 0220     		mov	r0, #2
 912              	.LVL46:
 648:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 913              		.loc 1 648 0
 914 0032 002B     		cmp	r3, #0
 915 0034 0AD0     		beq	.L68
 916 0036 06E0     		b	.L65
 917              	.LVL47:
 918              	.L67:
 652:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 653:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* transmit failed  */
 654:.\StdPeriphLib\src/stm32f0xx_can.c ****      case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
 655:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 656:.\StdPeriphLib\src/stm32f0xx_can.c ****      case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
 657:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 658:.\StdPeriphLib\src/stm32f0xx_can.c ****      case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
 659:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 660:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* transmit succeeded  */
 661:.\StdPeriphLib\src/stm32f0xx_can.c ****     case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
 662:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 663:.\StdPeriphLib\src/stm32f0xx_can.c ****     case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
 919              		.loc 1 663 0
 920 0038 0120     		mov	r0, #1
 921              	.LVL48:
 648:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 922              		.loc 1 648 0
 923 003a 064A     		ldr	r2, .L74+4
 924 003c 9342     		cmp	r3, r2
 925 003e 05D0     		beq	.L68
 926 0040 054A     		ldr	r2, .L74+8
 927 0042 9342     		cmp	r3, r2
 928 0044 02D0     		beq	.L68
 929              	.L65:
 654:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 930              		.loc 1 654 0
 931 0046 0020     		mov	r0, #0
 932 0048 00E0     		b	.L68
 933              	.LVL49:
 934              	.L66:
 661:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 935              		.loc 1 661 0
 936 004a 0120     		mov	r0, #1
 937              	.LVL50:
 938              	.L68:
 664:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 665:.\StdPeriphLib\src/stm32f0xx_can.c ****     case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
 666:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 667:.\StdPeriphLib\src/stm32f0xx_can.c ****     default: state = CAN_TxStatus_Failed;
 668:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 669:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 670:.\StdPeriphLib\src/stm32f0xx_can.c ****   return (uint8_t) state;
 939              		.loc 1 670 0
 940 004c C0B2     		uxtb	r0, r0
 941              	.LVL51:
 671:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 942              		.loc 1 671 0
 943              		@ sp needed
 944 004e 7047     		bx	lr
 945              	.L75:
 946              		.align	2
 947              	.L74:
 948 0050 03000004 		.word	67108867
 949 0054 00030008 		.word	134218496
 950 0058 00000310 		.word	268632064
 951              		.cfi_endproc
 952              	.LFE41:
 954              		.section	.text.CAN_CancelTransmit,"ax",%progbits
 955              		.align	2
 956              		.global	CAN_CancelTransmit
 957              		.code	16
 958              		.thumb_func
 960              	CAN_CancelTransmit:
 961              	.LFB42:
 672:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 673:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 674:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Cancels a transmit request.
 675:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 to select the CAN peripheral.
 676:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  Mailbox: Mailbox number.
 677:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval None
 678:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 679:.\StdPeriphLib\src/stm32f0xx_can.c **** void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
 680:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 962              		.loc 1 680 0
 963              		.cfi_startproc
 964              	.LVL52:
 681:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 682:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 683:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
 684:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* abort transmission */
 685:.\StdPeriphLib\src/stm32f0xx_can.c ****   switch (Mailbox)
 965              		.loc 1 685 0
 966 0000 0129     		cmp	r1, #1
 967 0002 09D0     		beq	.L78
 968 0004 0029     		cmp	r1, #0
 969 0006 02D0     		beq	.L79
 970 0008 0229     		cmp	r1, #2
 971 000a 0BD0     		beq	.L80
 972 000c 0FE0     		b	.L76
 973              	.L79:
 686:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 687:.\StdPeriphLib\src/stm32f0xx_can.c ****     case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
 974              		.loc 1 687 0
 975 000e 8268     		ldr	r2, [r0, #8]
 976 0010 8023     		mov	r3, #128
 977 0012 1343     		orr	r3, r2
 978 0014 8360     		str	r3, [r0, #8]
 688:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 979              		.loc 1 688 0
 980 0016 0AE0     		b	.L76
 981              	.L78:
 689:.\StdPeriphLib\src/stm32f0xx_can.c ****     case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
 982              		.loc 1 689 0
 983 0018 8368     		ldr	r3, [r0, #8]
 984 001a 8022     		mov	r2, #128
 985 001c 1202     		lsl	r2, r2, #8
 986 001e 1343     		orr	r3, r2
 987 0020 8360     		str	r3, [r0, #8]
 690:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 988              		.loc 1 690 0
 989 0022 04E0     		b	.L76
 990              	.L80:
 691:.\StdPeriphLib\src/stm32f0xx_can.c ****     case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
 991              		.loc 1 691 0
 992 0024 8368     		ldr	r3, [r0, #8]
 993 0026 8022     		mov	r2, #128
 994 0028 1204     		lsl	r2, r2, #16
 995 002a 1343     		orr	r3, r2
 996 002c 8360     		str	r3, [r0, #8]
 997              	.L76:
 692:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 693:.\StdPeriphLib\src/stm32f0xx_can.c ****     default:
 694:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 695:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 696:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 998              		.loc 1 696 0
 999              		@ sp needed
 1000 002e 7047     		bx	lr
 1001              		.cfi_endproc
 1002              	.LFE42:
 1004              		.section	.text.CAN_Receive,"ax",%progbits
 1005              		.align	2
 1006              		.global	CAN_Receive
 1007              		.code	16
 1008              		.thumb_func
 1010              	CAN_Receive:
 1011              	.LFB43:
 697:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 698:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @}
 699:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 700:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 701:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 702:.\StdPeriphLib\src/stm32f0xx_can.c **** /** @defgroup CAN_Group3 CAN Frames Reception functions
 703:.\StdPeriphLib\src/stm32f0xx_can.c ****  *  @brief    CAN Frames Reception functions 
 704:.\StdPeriphLib\src/stm32f0xx_can.c ****  *
 705:.\StdPeriphLib\src/stm32f0xx_can.c **** @verbatim    
 706:.\StdPeriphLib\src/stm32f0xx_can.c ****  ===============================================================================
 707:.\StdPeriphLib\src/stm32f0xx_can.c ****                   ##### CAN Frames Reception functions #####
 708:.\StdPeriphLib\src/stm32f0xx_can.c ****  ===============================================================================  
 709:.\StdPeriphLib\src/stm32f0xx_can.c ****     [..] This section provides functions allowing to 
 710:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Receive a correct CAN frame.
 711:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Release a specified receive FIFO (2 FIFOs are available).
 712:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Return the number of the pending received CAN frames.
 713:.\StdPeriphLib\src/stm32f0xx_can.c ****    
 714:.\StdPeriphLib\src/stm32f0xx_can.c **** @endverbatim
 715:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @{
 716:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 717:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 718:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 719:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Receives a correct CAN frame.
 720:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 to select the CAN peripheral.
 721:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
 722:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
 723:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         CAN DLC, CAN data and FMI number.
 724:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval None
 725:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 726:.\StdPeriphLib\src/stm32f0xx_can.c **** void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
 727:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 1012              		.loc 1 727 0
 1013              		.cfi_startproc
 1014              	.LVL53:
 1015 0000 70B5     		push	{r4, r5, r6, lr}
 1016              	.LCFI5:
 1017              		.cfi_def_cfa_offset 16
 1018              		.cfi_offset 4, -16
 1019              		.cfi_offset 5, -12
 1020              		.cfi_offset 6, -8
 1021              		.cfi_offset 14, -4
 1022 0002 0B01     		lsl	r3, r1, #4
 1023 0004 C318     		add	r3, r0, r3
 728:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 729:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 730:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_FIFO(FIFONumber));
 731:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Get the Id */
 732:.\StdPeriphLib\src/stm32f0xx_can.c ****   RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
 1024              		.loc 1 732 0
 1025 0006 D824     		mov	r4, #216
 1026 0008 6400     		lsl	r4, r4, #1
 1027 000a 1C59     		ldr	r4, [r3, r4]
 1028 000c 0425     		mov	r5, #4
 1029 000e 2C40     		and	r4, r5
 1030 0010 1472     		strb	r4, [r2, #8]
 733:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (RxMessage->IDE == CAN_Id_Standard)
 1031              		.loc 1 733 0
 1032 0012 05D1     		bne	.L82
 734:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 735:.\StdPeriphLib\src/stm32f0xx_can.c ****     RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
 1033              		.loc 1 735 0
 1034 0014 B134     		add	r4, r4, #177
 1035 0016 FF34     		add	r4, r4, #255
 1036 0018 1C59     		ldr	r4, [r3, r4]
 1037 001a 640D     		lsr	r4, r4, #21
 1038 001c 1460     		str	r4, [r2]
 1039 001e 04E0     		b	.L83
 1040              	.L82:
 736:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 737:.\StdPeriphLib\src/stm32f0xx_can.c ****   else
 738:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 739:.\StdPeriphLib\src/stm32f0xx_can.c ****     RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
 1041              		.loc 1 739 0
 1042 0020 D824     		mov	r4, #216
 1043 0022 6400     		lsl	r4, r4, #1
 1044 0024 1C59     		ldr	r4, [r3, r4]
 1045 0026 E408     		lsr	r4, r4, #3
 1046 0028 5460     		str	r4, [r2, #4]
 1047              	.L83:
 740:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 741:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 742:.\StdPeriphLib\src/stm32f0xx_can.c ****   RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
 1048              		.loc 1 742 0
 1049 002a D824     		mov	r4, #216
 1050 002c 6400     		lsl	r4, r4, #1
 1051 002e 1C59     		ldr	r4, [r3, r4]
 1052 0030 0225     		mov	r5, #2
 1053 0032 2C40     		and	r4, r5
 1054 0034 5472     		strb	r4, [r2, #9]
 743:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Get the DLC */
 744:.\StdPeriphLib\src/stm32f0xx_can.c ****   RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
 1055              		.loc 1 744 0
 1056 0036 B335     		add	r5, r5, #179
 1057 0038 FF35     		add	r5, r5, #255
 1058 003a 5C59     		ldr	r4, [r3, r5]
 1059 003c 0F26     		mov	r6, #15
 1060 003e 3440     		and	r4, r6
 1061 0040 9472     		strb	r4, [r2, #10]
 745:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Get the FMI */
 746:.\StdPeriphLib\src/stm32f0xx_can.c ****   RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
 1062              		.loc 1 746 0
 1063 0042 5B59     		ldr	r3, [r3, r5]
 1064 0044 1B0A     		lsr	r3, r3, #8
 1065 0046 D374     		strb	r3, [r2, #19]
 747:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Get the data field */
 748:.\StdPeriphLib\src/stm32f0xx_can.c ****   RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
 1066              		.loc 1 748 0
 1067 0048 0B01     		lsl	r3, r1, #4
 1068 004a C318     		add	r3, r0, r3
 1069 004c B933     		add	r3, r3, #185
 1070 004e FF33     		add	r3, r3, #255
 1071 0050 1C68     		ldr	r4, [r3]
 1072 0052 D472     		strb	r4, [r2, #11]
 749:.\StdPeriphLib\src/stm32f0xx_can.c ****   RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
 1073              		.loc 1 749 0
 1074 0054 1C68     		ldr	r4, [r3]
 1075 0056 240A     		lsr	r4, r4, #8
 1076 0058 1473     		strb	r4, [r2, #12]
 750:.\StdPeriphLib\src/stm32f0xx_can.c ****   RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
 1077              		.loc 1 750 0
 1078 005a 1C68     		ldr	r4, [r3]
 1079 005c 240C     		lsr	r4, r4, #16
 1080 005e 5473     		strb	r4, [r2, #13]
 751:.\StdPeriphLib\src/stm32f0xx_can.c ****   RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
 1081              		.loc 1 751 0
 1082 0060 1C68     		ldr	r4, [r3]
 1083 0062 240E     		lsr	r4, r4, #24
 1084 0064 9473     		strb	r4, [r2, #14]
 752:.\StdPeriphLib\src/stm32f0xx_can.c ****   RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
 1085              		.loc 1 752 0
 1086 0066 5C68     		ldr	r4, [r3, #4]
 1087 0068 D473     		strb	r4, [r2, #15]
 753:.\StdPeriphLib\src/stm32f0xx_can.c ****   RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
 1088              		.loc 1 753 0
 1089 006a 5C68     		ldr	r4, [r3, #4]
 1090 006c 240A     		lsr	r4, r4, #8
 1091 006e 1474     		strb	r4, [r2, #16]
 754:.\StdPeriphLib\src/stm32f0xx_can.c ****   RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
 1092              		.loc 1 754 0
 1093 0070 5C68     		ldr	r4, [r3, #4]
 1094 0072 240C     		lsr	r4, r4, #16
 1095 0074 5474     		strb	r4, [r2, #17]
 755:.\StdPeriphLib\src/stm32f0xx_can.c ****   RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
 1096              		.loc 1 755 0
 1097 0076 5B68     		ldr	r3, [r3, #4]
 1098 0078 1B0E     		lsr	r3, r3, #24
 1099 007a 9374     		strb	r3, [r2, #18]
 756:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Release the FIFO */
 757:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Release FIFO0 */
 758:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (FIFONumber == CAN_FIFO0)
 1100              		.loc 1 758 0
 1101 007c 0029     		cmp	r1, #0
 1102 007e 04D1     		bne	.L84
 759:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 760:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->RF0R |= CAN_RF0R_RFOM0;
 1103              		.loc 1 760 0
 1104 0080 C268     		ldr	r2, [r0, #12]
 1105              	.LVL54:
 1106 0082 2023     		mov	r3, #32
 1107 0084 1343     		orr	r3, r2
 1108 0086 C360     		str	r3, [r0, #12]
 1109 0088 03E0     		b	.L81
 1110              	.LVL55:
 1111              	.L84:
 761:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 762:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Release FIFO1 */
 763:.\StdPeriphLib\src/stm32f0xx_can.c ****   else /* FIFONumber == CAN_FIFO1 */
 764:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 765:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->RF1R |= CAN_RF1R_RFOM1;
 1112              		.loc 1 765 0
 1113 008a 0269     		ldr	r2, [r0, #16]
 1114              	.LVL56:
 1115 008c 2023     		mov	r3, #32
 1116 008e 1343     		orr	r3, r2
 1117 0090 0361     		str	r3, [r0, #16]
 1118              	.L81:
 766:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 767:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 1119              		.loc 1 767 0
 1120              		@ sp needed
 1121 0092 70BD     		pop	{r4, r5, r6, pc}
 1122              		.cfi_endproc
 1123              	.LFE43:
 1125              		.section	.text.CAN_FIFORelease,"ax",%progbits
 1126              		.align	2
 1127              		.global	CAN_FIFORelease
 1128              		.code	16
 1129              		.thumb_func
 1131              	CAN_FIFORelease:
 1132              	.LFB44:
 768:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 769:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 770:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Releases the specified receive FIFO.
 771:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 to select the CAN peripheral.
 772:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
 773:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval None
 774:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 775:.\StdPeriphLib\src/stm32f0xx_can.c **** void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
 776:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 1133              		.loc 1 776 0
 1134              		.cfi_startproc
 1135              	.LVL57:
 777:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 778:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 779:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_FIFO(FIFONumber));
 780:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Release FIFO0 */
 781:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (FIFONumber == CAN_FIFO0)
 1136              		.loc 1 781 0
 1137 0000 0029     		cmp	r1, #0
 1138 0002 04D1     		bne	.L87
 782:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 783:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->RF0R |= CAN_RF0R_RFOM0;
 1139              		.loc 1 783 0
 1140 0004 C268     		ldr	r2, [r0, #12]
 1141 0006 2023     		mov	r3, #32
 1142 0008 1343     		orr	r3, r2
 1143 000a C360     		str	r3, [r0, #12]
 1144 000c 03E0     		b	.L86
 1145              	.L87:
 784:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 785:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Release FIFO1 */
 786:.\StdPeriphLib\src/stm32f0xx_can.c ****   else /* FIFONumber == CAN_FIFO1 */
 787:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 788:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->RF1R |= CAN_RF1R_RFOM1;
 1146              		.loc 1 788 0
 1147 000e 0269     		ldr	r2, [r0, #16]
 1148 0010 2023     		mov	r3, #32
 1149 0012 1343     		orr	r3, r2
 1150 0014 0361     		str	r3, [r0, #16]
 1151              	.L86:
 789:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 790:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 1152              		.loc 1 790 0
 1153              		@ sp needed
 1154 0016 7047     		bx	lr
 1155              		.cfi_endproc
 1156              	.LFE44:
 1158              		.section	.text.CAN_MessagePending,"ax",%progbits
 1159              		.align	2
 1160              		.global	CAN_MessagePending
 1161              		.code	16
 1162              		.thumb_func
 1164              	CAN_MessagePending:
 1165              	.LFB45:
 791:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 792:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 793:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Returns the number of pending received messages.
 794:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 to select the CAN peripheral.
 795:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
 796:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval NbMessage : which is the number of pending message.
 797:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 798:.\StdPeriphLib\src/stm32f0xx_can.c **** uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
 799:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 1166              		.loc 1 799 0
 1167              		.cfi_startproc
 1168              	.LVL58:
 1169 0000 031C     		mov	r3, r0
 1170              	.LVL59:
 800:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint8_t message_pending=0;
 801:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 802:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 803:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_FIFO(FIFONumber));
 804:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (FIFONumber == CAN_FIFO0)
 1171              		.loc 1 804 0
 1172 0002 0029     		cmp	r1, #0
 1173 0004 03D1     		bne	.L90
 805:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 806:.\StdPeriphLib\src/stm32f0xx_can.c ****     message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
 1174              		.loc 1 806 0
 1175 0006 C368     		ldr	r3, [r0, #12]
 1176 0008 0320     		mov	r0, #3
 1177              	.LVL60:
 1178 000a 1840     		and	r0, r3
 1179              	.LVL61:
 1180 000c 05E0     		b	.L91
 1181              	.LVL62:
 1182              	.L90:
 807:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 808:.\StdPeriphLib\src/stm32f0xx_can.c ****   else if (FIFONumber == CAN_FIFO1)
 809:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 810:.\StdPeriphLib\src/stm32f0xx_can.c ****     message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
 811:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 812:.\StdPeriphLib\src/stm32f0xx_can.c ****   else
 813:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 814:.\StdPeriphLib\src/stm32f0xx_can.c ****     message_pending = 0;
 1183              		.loc 1 814 0
 1184 000e 0020     		mov	r0, #0
 1185              	.LVL63:
 808:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 1186              		.loc 1 808 0
 1187 0010 0129     		cmp	r1, #1
 1188 0012 02D1     		bne	.L91
 810:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 1189              		.loc 1 810 0
 1190 0014 1B69     		ldr	r3, [r3, #16]
 1191              	.LVL64:
 1192 0016 0330     		add	r0, r0, #3
 1193 0018 1840     		and	r0, r3
 1194              	.LVL65:
 1195              	.L91:
 815:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 816:.\StdPeriphLib\src/stm32f0xx_can.c ****   return message_pending;
 817:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 1196              		.loc 1 817 0
 1197              		@ sp needed
 1198 001a 7047     		bx	lr
 1199              		.cfi_endproc
 1200              	.LFE45:
 1202              		.section	.text.CAN_OperatingModeRequest,"ax",%progbits
 1203              		.align	2
 1204              		.global	CAN_OperatingModeRequest
 1205              		.code	16
 1206              		.thumb_func
 1208              	CAN_OperatingModeRequest:
 1209              	.LFB46:
 818:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 819:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @}
 820:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 821:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 822:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 823:.\StdPeriphLib\src/stm32f0xx_can.c **** /** @defgroup CAN_Group4 CAN Operation modes functions
 824:.\StdPeriphLib\src/stm32f0xx_can.c ****  *  @brief    CAN Operation modes functions 
 825:.\StdPeriphLib\src/stm32f0xx_can.c ****  *
 826:.\StdPeriphLib\src/stm32f0xx_can.c **** @verbatim    
 827:.\StdPeriphLib\src/stm32f0xx_can.c ****  ===============================================================================
 828:.\StdPeriphLib\src/stm32f0xx_can.c ****                     ##### CAN Operation modes functions #####
 829:.\StdPeriphLib\src/stm32f0xx_can.c ****  ===============================================================================  
 830:.\StdPeriphLib\src/stm32f0xx_can.c ****     [..] This section provides functions allowing to select the CAN Operation modes:
 831:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) sleep mode.
 832:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) normal mode. 
 833:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) initialization mode.
 834:.\StdPeriphLib\src/stm32f0xx_can.c ****    
 835:.\StdPeriphLib\src/stm32f0xx_can.c **** @endverbatim
 836:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @{
 837:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 838:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 839:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 840:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 841:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Selects the CAN Operation mode.
 842:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CAN_OperatingMode: CAN Operating Mode.
 843:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         This parameter can be one of @ref CAN_OperatingMode_TypeDef enumeration.
 844:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval status of the requested mode which can be: 
 845:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         - CAN_ModeStatus_Failed:  CAN failed entering the specific mode 
 846:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         - CAN_ModeStatus_Success: CAN Succeed entering the specific mode 
 847:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 848:.\StdPeriphLib\src/stm32f0xx_can.c **** uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
 849:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 1210              		.loc 1 849 0
 1211              		.cfi_startproc
 1212              	.LVL66:
 1213 0000 10B5     		push	{r4, lr}
 1214              	.LCFI6:
 1215              		.cfi_def_cfa_offset 8
 1216              		.cfi_offset 4, -8
 1217              		.cfi_offset 14, -4
 1218              	.LVL67:
 850:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint8_t status = CAN_ModeStatus_Failed;
 851:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 852:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Timeout for INAK or also for SLAK bits*/
 853:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint32_t timeout = INAK_TIMEOUT; 
 854:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 855:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 856:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 857:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
 858:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 859:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
 1219              		.loc 1 859 0
 1220 0002 0029     		cmp	r1, #0
 1221 0004 1AD1     		bne	.L94
 860:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 861:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Request initialisation */
 862:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
 1222              		.loc 1 862 0
 1223 0006 0268     		ldr	r2, [r0]
 1224 0008 0324     		mov	r4, #3
 1225 000a A243     		bic	r2, r4
 1226 000c 0131     		add	r1, r1, #1
 1227              	.LVL68:
 1228 000e 0A43     		orr	r2, r1
 1229 0010 0260     		str	r2, [r0]
 863:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 864:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Wait the acknowledge */
 865:.\StdPeriphLib\src/stm32f0xx_can.c ****     while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
 1230              		.loc 1 865 0
 1231 0012 4368     		ldr	r3, [r0, #4]
 1232 0014 2340     		and	r3, r4
 1233 0016 012B     		cmp	r3, #1
 1234 0018 08D0     		beq	.L95
 1235 001a 234A     		ldr	r2, .L107
 1236 001c 0231     		add	r1, r1, #2
 1237              	.LVL69:
 1238              	.L96:
 1239 001e 4368     		ldr	r3, [r0, #4]
 1240 0020 0B40     		and	r3, r1
 1241 0022 012B     		cmp	r3, #1
 1242 0024 02D0     		beq	.L95
 1243 0026 013A     		sub	r2, r2, #1
 1244              	.LVL70:
 1245              		.loc 1 865 0 is_stmt 0 discriminator 1
 1246 0028 002A     		cmp	r2, #0
 1247 002a F8D1     		bne	.L96
 1248              	.LVL71:
 1249              	.L95:
 866:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 867:.\StdPeriphLib\src/stm32f0xx_can.c ****       timeout--;
 868:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 869:.\StdPeriphLib\src/stm32f0xx_can.c ****     if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
 1250              		.loc 1 869 0 is_stmt 1
 1251 002c 4368     		ldr	r3, [r0, #4]
 1252 002e 0322     		mov	r2, #3
 1253 0030 1340     		and	r3, r2
 1254 0032 013B     		sub	r3, r3, #1
 1255 0034 5842     		neg	r0, r3
 1256 0036 4341     		adc	r3, r3, r0
 1257              	.LVL72:
 870:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 871:.\StdPeriphLib\src/stm32f0xx_can.c ****       status = CAN_ModeStatus_Failed;
 872:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 873:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
 874:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 875:.\StdPeriphLib\src/stm32f0xx_can.c ****       status = CAN_ModeStatus_Success;
 1258              		.loc 1 875 0
 1259 0038 DBB2     		uxtb	r3, r3
 1260 003a 33E0     		b	.L97
 1261              	.LVL73:
 1262              	.L94:
 876:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 877:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 878:.\StdPeriphLib\src/stm32f0xx_can.c ****   else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
 1263              		.loc 1 878 0
 1264 003c 0129     		cmp	r1, #1
 1265 003e 15D1     		bne	.L98
 879:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 880:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Request leave initialisation and sleep mode  and enter Normal mode */
 881:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
 1266              		.loc 1 881 0
 1267 0040 0368     		ldr	r3, [r0]
 1268 0042 0322     		mov	r2, #3
 1269 0044 9343     		bic	r3, r2
 1270 0046 0360     		str	r3, [r0]
 882:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 883:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Wait the acknowledge */
 884:.\StdPeriphLib\src/stm32f0xx_can.c ****     while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
 1271              		.loc 1 884 0
 1272 0048 4368     		ldr	r3, [r0, #4]
 1273 004a 1A42     		tst	r2, r3
 1274 004c 07D0     		beq	.L99
 1275 004e 164B     		ldr	r3, .L107
 1276 0050 0231     		add	r1, r1, #2
 1277              	.LVL74:
 1278              	.L100:
 1279 0052 4268     		ldr	r2, [r0, #4]
 1280 0054 1142     		tst	r1, r2
 1281 0056 02D0     		beq	.L99
 1282 0058 013B     		sub	r3, r3, #1
 1283              	.LVL75:
 1284              		.loc 1 884 0 is_stmt 0 discriminator 1
 1285 005a 002B     		cmp	r3, #0
 1286 005c F9D1     		bne	.L100
 1287              	.LVL76:
 1288              	.L99:
 885:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 886:.\StdPeriphLib\src/stm32f0xx_can.c ****       timeout--;
 887:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 888:.\StdPeriphLib\src/stm32f0xx_can.c ****     if ((CANx->MSR & CAN_MODE_MASK) != 0)
 1289              		.loc 1 888 0 is_stmt 1
 1290 005e 4368     		ldr	r3, [r0, #4]
 1291 0060 0322     		mov	r2, #3
 1292 0062 1340     		and	r3, r2
 1293 0064 5A42     		neg	r2, r3
 1294 0066 5341     		adc	r3, r3, r2
 875:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 1295              		.loc 1 875 0
 1296 0068 DBB2     		uxtb	r3, r3
 1297 006a 1BE0     		b	.L97
 1298              	.LVL77:
 1299              	.L98:
 889:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 890:.\StdPeriphLib\src/stm32f0xx_can.c ****       status = CAN_ModeStatus_Failed;
 891:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 892:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
 893:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 894:.\StdPeriphLib\src/stm32f0xx_can.c ****       status = CAN_ModeStatus_Success;
 895:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 896:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 897:.\StdPeriphLib\src/stm32f0xx_can.c ****   else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
 898:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 899:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Request Sleep mode */
 900:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
 901:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 902:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Wait the acknowledge */
 903:.\StdPeriphLib\src/stm32f0xx_can.c ****     while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
 904:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 905:.\StdPeriphLib\src/stm32f0xx_can.c ****       timeout--;
 906:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 907:.\StdPeriphLib\src/stm32f0xx_can.c ****     if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
 908:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 909:.\StdPeriphLib\src/stm32f0xx_can.c ****       status = CAN_ModeStatus_Failed;
 910:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 911:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
 912:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 913:.\StdPeriphLib\src/stm32f0xx_can.c ****       status = CAN_ModeStatus_Success;
 914:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 915:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 916:.\StdPeriphLib\src/stm32f0xx_can.c ****   else
 917:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 918:.\StdPeriphLib\src/stm32f0xx_can.c ****     status = CAN_ModeStatus_Failed;
 1300              		.loc 1 918 0
 1301 006c 0023     		mov	r3, #0
 897:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 1302              		.loc 1 897 0
 1303 006e 0229     		cmp	r1, #2
 1304 0070 18D1     		bne	.L97
 900:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 1305              		.loc 1 900 0
 1306 0072 0268     		ldr	r2, [r0]
 1307 0074 0324     		mov	r4, #3
 1308 0076 A243     		bic	r2, r4
 1309 0078 0A43     		orr	r2, r1
 1310 007a 0260     		str	r2, [r0]
 903:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 1311              		.loc 1 903 0
 1312 007c 4368     		ldr	r3, [r0, #4]
 1313 007e 2340     		and	r3, r4
 1314 0080 022B     		cmp	r3, #2
 1315 0082 08D0     		beq	.L101
 1316 0084 084A     		ldr	r2, .L107
 1317 0086 0131     		add	r1, r1, #1
 1318              	.LVL78:
 1319              	.L102:
 1320 0088 4368     		ldr	r3, [r0, #4]
 1321 008a 0B40     		and	r3, r1
 1322 008c 022B     		cmp	r3, #2
 1323 008e 02D0     		beq	.L101
 1324 0090 013A     		sub	r2, r2, #1
 1325              	.LVL79:
 903:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 1326              		.loc 1 903 0 is_stmt 0 discriminator 1
 1327 0092 002A     		cmp	r2, #0
 1328 0094 F8D1     		bne	.L102
 1329              	.LVL80:
 1330              	.L101:
 907:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 1331              		.loc 1 907 0 is_stmt 1
 1332 0096 4368     		ldr	r3, [r0, #4]
 1333 0098 0322     		mov	r2, #3
 1334 009a 1340     		and	r3, r2
 1335 009c 023B     		sub	r3, r3, #2
 1336 009e 5A42     		neg	r2, r3
 1337 00a0 5341     		adc	r3, r3, r2
 875:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 1338              		.loc 1 875 0
 1339 00a2 DBB2     		uxtb	r3, r3
 1340              	.LVL81:
 1341              	.L97:
 919:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 920:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 921:.\StdPeriphLib\src/stm32f0xx_can.c ****   return  (uint8_t) status;
 922:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 1342              		.loc 1 922 0
 1343 00a4 181C     		mov	r0, r3
 1344              		@ sp needed
 1345 00a6 10BD     		pop	{r4, pc}
 1346              	.L108:
 1347              		.align	2
 1348              	.L107:
 1349 00a8 FFFFFF00 		.word	16777215
 1350              		.cfi_endproc
 1351              	.LFE46:
 1353              		.section	.text.CAN_Sleep,"ax",%progbits
 1354              		.align	2
 1355              		.global	CAN_Sleep
 1356              		.code	16
 1357              		.thumb_func
 1359              	CAN_Sleep:
 1360              	.LFB47:
 923:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 924:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 925:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Enters the Sleep (low power) mode.
 926:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 to select the CAN peripheral.
 927:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed otherwise.
 928:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 929:.\StdPeriphLib\src/stm32f0xx_can.c **** uint8_t CAN_Sleep(CAN_TypeDef* CANx)
 930:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 1361              		.loc 1 930 0
 1362              		.cfi_startproc
 1363              	.LVL82:
 1364 0000 031C     		mov	r3, r0
 1365              	.LVL83:
 931:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint8_t sleepstatus = CAN_Sleep_Failed;
 932:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 933:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 934:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 935:.\StdPeriphLib\src/stm32f0xx_can.c ****     
 936:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Request Sleep mode */
 937:.\StdPeriphLib\src/stm32f0xx_can.c ****    CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
 1366              		.loc 1 937 0
 1367 0002 0268     		ldr	r2, [r0]
 1368 0004 0320     		mov	r0, #3
 1369              	.LVL84:
 1370 0006 8243     		bic	r2, r0
 1371 0008 0221     		mov	r1, #2
 1372 000a 0A43     		orr	r2, r1
 1373 000c 1A60     		str	r2, [r3]
 938:.\StdPeriphLib\src/stm32f0xx_can.c ****    
 939:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Sleep mode status */
 940:.\StdPeriphLib\src/stm32f0xx_can.c ****   if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
 1374              		.loc 1 940 0
 1375 000e 5B68     		ldr	r3, [r3, #4]
 1376              	.LVL85:
 1377 0010 1840     		and	r0, r3
 1378 0012 0238     		sub	r0, r0, #2
 1379 0014 4342     		neg	r3, r0
 1380 0016 5841     		adc	r0, r0, r3
 1381              	.LVL86:
 941:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 942:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Sleep mode not entered */
 943:.\StdPeriphLib\src/stm32f0xx_can.c ****     sleepstatus =  CAN_Sleep_Ok;
 944:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 945:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* return sleep mode status */
 946:.\StdPeriphLib\src/stm32f0xx_can.c ****    return (uint8_t)sleepstatus;
 1382              		.loc 1 946 0
 1383 0018 C0B2     		uxtb	r0, r0
 947:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 1384              		.loc 1 947 0
 1385              		@ sp needed
 1386 001a 7047     		bx	lr
 1387              		.cfi_endproc
 1388              	.LFE47:
 1390              		.section	.text.CAN_WakeUp,"ax",%progbits
 1391              		.align	2
 1392              		.global	CAN_WakeUp
 1393              		.code	16
 1394              		.thumb_func
 1396              	CAN_WakeUp:
 1397              	.LFB48:
 948:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 949:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 950:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Wakes up the CAN peripheral from sleep mode .
 951:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 to select the CAN peripheral.
 952:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed otherwise.
 953:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 954:.\StdPeriphLib\src/stm32f0xx_can.c **** uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
 955:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 1398              		.loc 1 955 0
 1399              		.cfi_startproc
 1400              	.LVL87:
 956:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint32_t wait_slak = SLAK_TIMEOUT;
 957:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint8_t wakeupstatus = CAN_WakeUp_Failed;
 958:.\StdPeriphLib\src/stm32f0xx_can.c ****   
 959:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 960:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 961:.\StdPeriphLib\src/stm32f0xx_can.c ****     
 962:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Wake up request */
 963:.\StdPeriphLib\src/stm32f0xx_can.c ****   CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
 1401              		.loc 1 963 0
 1402 0000 0368     		ldr	r3, [r0]
 1403 0002 0222     		mov	r2, #2
 1404 0004 9343     		bic	r3, r2
 1405 0006 0360     		str	r3, [r0]
 964:.\StdPeriphLib\src/stm32f0xx_can.c ****     
 965:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Sleep mode status */
 966:.\StdPeriphLib\src/stm32f0xx_can.c ****   while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
 1406              		.loc 1 966 0
 1407 0008 4368     		ldr	r3, [r0, #4]
 1408 000a 1A42     		tst	r2, r3
 1409 000c 07D0     		beq	.L111
 1410 000e 074B     		ldr	r3, .L114
 1411 0010 0221     		mov	r1, #2
 1412              	.LVL88:
 1413              	.L112:
 1414 0012 4268     		ldr	r2, [r0, #4]
 1415 0014 1142     		tst	r1, r2
 1416 0016 02D0     		beq	.L111
 1417 0018 013B     		sub	r3, r3, #1
 1418              	.LVL89:
 1419              		.loc 1 966 0 is_stmt 0 discriminator 1
 1420 001a 002B     		cmp	r3, #0
 1421 001c F9D1     		bne	.L112
 1422              	.LVL90:
 1423              	.L111:
 967:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 968:.\StdPeriphLib\src/stm32f0xx_can.c ****    wait_slak--;
 969:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 970:.\StdPeriphLib\src/stm32f0xx_can.c ****   if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
 1424              		.loc 1 970 0 is_stmt 1
 1425 001e 4068     		ldr	r0, [r0, #4]
 1426              	.LVL91:
 1427 0020 4008     		lsr	r0, r0, #1
 1428              	.LVL92:
 1429 0022 0123     		mov	r3, #1
 1430 0024 5840     		eor	r0, r3
 971:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 972:.\StdPeriphLib\src/stm32f0xx_can.c ****    /* wake up done : Sleep mode exited */
 973:.\StdPeriphLib\src/stm32f0xx_can.c ****     wakeupstatus = CAN_WakeUp_Ok;
 974:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
 975:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* return wakeup status */
 976:.\StdPeriphLib\src/stm32f0xx_can.c ****   return (uint8_t)wakeupstatus;
 1431              		.loc 1 976 0
 1432 0026 1840     		and	r0, r3
 977:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 1433              		.loc 1 977 0
 1434              		@ sp needed
 1435 0028 7047     		bx	lr
 1436              	.L115:
 1437 002a C046     		.align	2
 1438              	.L114:
 1439 002c FFFFFF00 		.word	16777215
 1440              		.cfi_endproc
 1441              	.LFE48:
 1443              		.section	.text.CAN_GetLastErrorCode,"ax",%progbits
 1444              		.align	2
 1445              		.global	CAN_GetLastErrorCode
 1446              		.code	16
 1447              		.thumb_func
 1449              	CAN_GetLastErrorCode:
 1450              	.LFB49:
 978:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
 979:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @}
 980:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
 981:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 982:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 983:.\StdPeriphLib\src/stm32f0xx_can.c **** /** @defgroup CAN_Group5 CAN Bus Error management functions
 984:.\StdPeriphLib\src/stm32f0xx_can.c ****  *  @brief    CAN Bus Error management functions 
 985:.\StdPeriphLib\src/stm32f0xx_can.c ****  *
 986:.\StdPeriphLib\src/stm32f0xx_can.c **** @verbatim    
 987:.\StdPeriphLib\src/stm32f0xx_can.c ****  ===============================================================================
 988:.\StdPeriphLib\src/stm32f0xx_can.c ****                   ##### CAN Bus Error management functions #####
 989:.\StdPeriphLib\src/stm32f0xx_can.c ****  ===============================================================================  
 990:.\StdPeriphLib\src/stm32f0xx_can.c ****     [..] This section provides functions allowing to 
 991:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Return the CANx's last error code (LEC).
 992:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Return the CANx Receive Error Counter (REC).
 993:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Return the LSB of the 9-bit CANx Transmit Error Counter(TEC).
 994:.\StdPeriphLib\src/stm32f0xx_can.c ****     [..]
 995:.\StdPeriphLib\src/stm32f0xx_can.c ****          (@) If TEC is greater than 255, The CAN is in bus-off state.
 996:.\StdPeriphLib\src/stm32f0xx_can.c ****          (@) If REC or TEC are greater than 96, an Error warning flag occurs.
 997:.\StdPeriphLib\src/stm32f0xx_can.c ****          (@) If REC or TEC are greater than 127, an Error Passive Flag occurs.
 998:.\StdPeriphLib\src/stm32f0xx_can.c ****                         
 999:.\StdPeriphLib\src/stm32f0xx_can.c **** @endverbatim
1000:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @{
1001:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
1002:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1003:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
1004:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Returns the CANx's last error code (LEC).
1005:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 to select the CAN peripheral.
1006:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval Error code: 
1007:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          - CAN_ERRORCODE_NoErr: No Error  
1008:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          - CAN_ERRORCODE_StuffErr: Stuff Error
1009:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          - CAN_ERRORCODE_FormErr: Form Error
1010:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          - CAN_ERRORCODE_ACKErr : Acknowledgment Error
1011:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          - CAN_ERRORCODE_BitRecessiveErr: Bit Recessive Error
1012:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          - CAN_ERRORCODE_BitDominantErr: Bit Dominant Error
1013:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          - CAN_ERRORCODE_CRCErr: CRC Error
1014:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          - CAN_ERRORCODE_SoftwareSetErr: Software Set Error  
1015:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
1016:.\StdPeriphLib\src/stm32f0xx_can.c **** uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
1017:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 1451              		.loc 1 1017 0
 1452              		.cfi_startproc
 1453              	.LVL93:
1018:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint8_t errorcode=0;
1019:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1020:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
1021:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1022:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1023:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Get the error code*/
1024:.\StdPeriphLib\src/stm32f0xx_can.c ****   errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
 1454              		.loc 1 1024 0
 1455 0000 8369     		ldr	r3, [r0, #24]
 1456              	.LVL94:
1025:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1026:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Return the error code*/
1027:.\StdPeriphLib\src/stm32f0xx_can.c ****   return errorcode;
 1457              		.loc 1 1027 0
 1458 0002 7020     		mov	r0, #112
 1459              	.LVL95:
 1460 0004 1840     		and	r0, r3
1028:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 1461              		.loc 1 1028 0
 1462              		@ sp needed
 1463 0006 7047     		bx	lr
 1464              		.cfi_endproc
 1465              	.LFE49:
 1467              		.section	.text.CAN_GetReceiveErrorCounter,"ax",%progbits
 1468              		.align	2
 1469              		.global	CAN_GetReceiveErrorCounter
 1470              		.code	16
 1471              		.thumb_func
 1473              	CAN_GetReceiveErrorCounter:
 1474              	.LFB50:
1029:.\StdPeriphLib\src/stm32f0xx_can.c **** 
1030:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
1031:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Returns the CANx Receive Error Counter (REC).
1032:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @note   In case of an error during reception, this counter is incremented 
1033:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         by 1 or by 8 depending on the error condition as defined by the CAN 
1034:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         standard. After every successful reception, the counter is 
1035:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         decremented by 1 or reset to 120 if its value was higher than 128. 
1036:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         When the counter value exceeds 127, the CAN controller enters the 
1037:.\StdPeriphLib\src/stm32f0xx_can.c ****   *         error passive state.  
1038:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
1039:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval CAN Receive Error Counter. 
1040:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
1041:.\StdPeriphLib\src/stm32f0xx_can.c **** uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
1042:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 1475              		.loc 1 1042 0
 1476              		.cfi_startproc
 1477              	.LVL96:
1043:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint8_t counter=0;
1044:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1045:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
1046:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1047:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1048:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Get the Receive Error Counter*/
1049:.\StdPeriphLib\src/stm32f0xx_can.c ****   counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
 1478              		.loc 1 1049 0
 1479 0000 8069     		ldr	r0, [r0, #24]
 1480              	.LVL97:
1050:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1051:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Return the Receive Error Counter*/
1052:.\StdPeriphLib\src/stm32f0xx_can.c ****   return counter;
 1481              		.loc 1 1052 0
 1482 0002 000E     		lsr	r0, r0, #24
 1483              	.LVL98:
1053:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 1484              		.loc 1 1053 0
 1485              		@ sp needed
 1486 0004 7047     		bx	lr
 1487              		.cfi_endproc
 1488              	.LFE50:
 1490 0006 C046     		.section	.text.CAN_GetLSBTransmitErrorCounter,"ax",%progbits
 1491              		.align	2
 1492              		.global	CAN_GetLSBTransmitErrorCounter
 1493              		.code	16
 1494              		.thumb_func
 1496              	CAN_GetLSBTransmitErrorCounter:
 1497              	.LFB51:
1054:.\StdPeriphLib\src/stm32f0xx_can.c **** 
1055:.\StdPeriphLib\src/stm32f0xx_can.c **** 
1056:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
1057:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
1058:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
1059:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval LSB of the 9-bit CAN Transmit Error Counter. 
1060:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
1061:.\StdPeriphLib\src/stm32f0xx_can.c **** uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
1062:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 1498              		.loc 1 1062 0
 1499              		.cfi_startproc
 1500              	.LVL99:
1063:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint8_t counter=0;
1064:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1065:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
1066:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1067:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1068:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
1069:.\StdPeriphLib\src/stm32f0xx_can.c ****   counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
 1501              		.loc 1 1069 0
 1502 0000 8069     		ldr	r0, [r0, #24]
 1503              	.LVL100:
 1504 0002 0002     		lsl	r0, r0, #8
 1505              	.LVL101:
1070:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1071:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
1072:.\StdPeriphLib\src/stm32f0xx_can.c ****   return counter;
 1506              		.loc 1 1072 0
 1507 0004 000E     		lsr	r0, r0, #24
1073:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 1508              		.loc 1 1073 0
 1509              		@ sp needed
 1510 0006 7047     		bx	lr
 1511              		.cfi_endproc
 1512              	.LFE51:
 1514              		.section	.text.CAN_ITConfig,"ax",%progbits
 1515              		.align	2
 1516              		.global	CAN_ITConfig
 1517              		.code	16
 1518              		.thumb_func
 1520              	CAN_ITConfig:
 1521              	.LFB52:
1074:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
1075:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @}
1076:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
1077:.\StdPeriphLib\src/stm32f0xx_can.c **** 
1078:.\StdPeriphLib\src/stm32f0xx_can.c **** /** @defgroup CAN_Group6 Interrupts and flags management functions
1079:.\StdPeriphLib\src/stm32f0xx_can.c ****  *  @brief   Interrupts and flags management functions
1080:.\StdPeriphLib\src/stm32f0xx_can.c ****  *
1081:.\StdPeriphLib\src/stm32f0xx_can.c **** @verbatim   
1082:.\StdPeriphLib\src/stm32f0xx_can.c ****  ===============================================================================
1083:.\StdPeriphLib\src/stm32f0xx_can.c ****               ##### Interrupts and flags management functions #####
1084:.\StdPeriphLib\src/stm32f0xx_can.c ****  ===============================================================================  
1085:.\StdPeriphLib\src/stm32f0xx_can.c ****     [..] This section provides functions allowing to configure the CAN Interrupts 
1086:.\StdPeriphLib\src/stm32f0xx_can.c ****          and to get the status and clear flags and Interrupts pending bits.
1087:.\StdPeriphLib\src/stm32f0xx_can.c ****     [..] The CAN provides 14 Interrupts sources and 15 Flags:
1088:.\StdPeriphLib\src/stm32f0xx_can.c ****    
1089:.\StdPeriphLib\src/stm32f0xx_can.c ****   *** Flags ***
1090:.\StdPeriphLib\src/stm32f0xx_can.c ****   =============
1091:.\StdPeriphLib\src/stm32f0xx_can.c ****     [..] The 15 flags can be divided on 4 groups: 
1092:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Transmit Flags:
1093:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_RQCP0. 
1094:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_RQCP1. 
1095:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_RQCP2: Request completed MailBoxes 0, 1 and 2  Flags
1096:.\StdPeriphLib\src/stm32f0xx_can.c ****                   Set when when the last request (transmit or abort) has 
1097:.\StdPeriphLib\src/stm32f0xx_can.c ****                   been performed. 
1098:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Receive Flags:
1099:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_FMP0.
1100:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_FMP1: FIFO 0 and 1 Message Pending Flags; 
1101:.\StdPeriphLib\src/stm32f0xx_can.c ****                   Set to signal that messages are pending in the receive FIFO.
1102:.\StdPeriphLib\src/stm32f0xx_can.c ****                   These Flags are cleared only by hardware. 
1103:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_FF0.
1104:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_FF1: FIFO 0 and 1 Full Flags; 
1105:.\StdPeriphLib\src/stm32f0xx_can.c ****                   Set when three messages are stored in the selected FIFO.                        
1106:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_FOV0.              
1107:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_FOV1: FIFO 0 and 1 Overrun Flags; 
1108:.\StdPeriphLib\src/stm32f0xx_can.c ****                   Set when a new message has been received and passed the filter 
1109:.\StdPeriphLib\src/stm32f0xx_can.c ****                   while the FIFO was full.         
1110:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Operating Mode Flags: 
1111:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_WKU: Wake up Flag; 
1112:.\StdPeriphLib\src/stm32f0xx_can.c ****                   Set to signal that a SOF bit has been detected while the CAN 
1113:.\StdPeriphLib\src/stm32f0xx_can.c ****                   hardware was in Sleep mode. 
1114:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_SLAK: Sleep acknowledge Flag;
1115:.\StdPeriphLib\src/stm32f0xx_can.c ****                   Set to signal that the CAN has entered Sleep Mode. 
1116:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Error Flags:  
1117:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_EWG: Error Warning Flag;
1118:.\StdPeriphLib\src/stm32f0xx_can.c ****                   Set when the warning limit has been reached (Receive Error Counter 
1119:.\StdPeriphLib\src/stm32f0xx_can.c ****                   or Transmit Error Counter greater than 96). 
1120:.\StdPeriphLib\src/stm32f0xx_can.c ****                   This Flag is cleared only by hardware.
1121:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_EPV: Error Passive Flag;
1122:.\StdPeriphLib\src/stm32f0xx_can.c ****                   Set when the Error Passive limit has been reached (Receive Error 
1123:.\StdPeriphLib\src/stm32f0xx_can.c ****                   Counter or Transmit Error Counter greater than 127).
1124:.\StdPeriphLib\src/stm32f0xx_can.c ****                   This Flag is cleared only by hardware.
1125:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_BOF: Bus-Off Flag;
1126:.\StdPeriphLib\src/stm32f0xx_can.c ****                   Set when CAN enters the bus-off state. The bus-off state is 
1127:.\StdPeriphLib\src/stm32f0xx_can.c ****                   entered on TEC overflow, greater than 255.
1128:.\StdPeriphLib\src/stm32f0xx_can.c ****                   This Flag is cleared only by hardware.
1129:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_FLAG_LEC: Last error code Flag;
1130:.\StdPeriphLib\src/stm32f0xx_can.c ****                   Set If a message has been transferred (reception or transmission) 
1131:.\StdPeriphLib\src/stm32f0xx_can.c ****                   with error, and the error code is hold.                      
1132:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1133:.\StdPeriphLib\src/stm32f0xx_can.c ****   *** Interrupts ***
1134:.\StdPeriphLib\src/stm32f0xx_can.c ****   ==================
1135:.\StdPeriphLib\src/stm32f0xx_can.c ****     [..] The 14 interrupts can be divided on 4 groups: 
1136:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Transmit interrupt:   
1137:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_IT_TME: Transmit mailbox empty Interrupt;
1138:.\StdPeriphLib\src/stm32f0xx_can.c ****                   If enabled, this interrupt source is pending when no transmit 
1139:.\StdPeriphLib\src/stm32f0xx_can.c ****                   request are pending for Tx mailboxes.      
1140:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Receive Interrupts:   
1141:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_IT_FMP0.
1142:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_IT_FMP1: FIFO 0 and FIFO1 message pending Interrupts;
1143:.\StdPeriphLib\src/stm32f0xx_can.c ****                   If enabled, these interrupt sources are pending when messages 
1144:.\StdPeriphLib\src/stm32f0xx_can.c ****                   are pending in the receive FIFO.
1145:.\StdPeriphLib\src/stm32f0xx_can.c ****                   The corresponding interrupt pending bits are cleared only by hardware.
1146:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_IT_FF0.              
1147:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_IT_FF1: FIFO 0 and FIFO1 full Interrupts;
1148:.\StdPeriphLib\src/stm32f0xx_can.c ****                   If enabled, these interrupt sources are pending when three messages 
1149:.\StdPeriphLib\src/stm32f0xx_can.c ****                   are stored in the selected FIFO.
1150:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_IT_FOV0.        
1151:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_IT_FOV1: FIFO 0 and FIFO1 overrun Interrupts;        
1152:.\StdPeriphLib\src/stm32f0xx_can.c ****                   If enabled, these interrupt sources are pending when a new message 
1153:.\StdPeriphLib\src/stm32f0xx_can.c ****                   has been received and passed the filter while the FIFO was full.
1154:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Operating Mode Interrupts:    
1155:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_IT_WKU: Wake-up Interrupt;
1156:.\StdPeriphLib\src/stm32f0xx_can.c ****                   If enabled, this interrupt source is pending when a SOF bit has 
1157:.\StdPeriphLib\src/stm32f0xx_can.c ****                   been detected while the CAN hardware was in Sleep mode.
1158:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_IT_SLK: Sleep acknowledge Interrupt:
1159:.\StdPeriphLib\src/stm32f0xx_can.c ****                   If enabled, this interrupt source is pending when the CAN has 
1160:.\StdPeriphLib\src/stm32f0xx_can.c ****                   entered Sleep Mode.       
1161:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) Error Interrupts:     
1162:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_IT_EWG: Error warning Interrupt; 
1163:.\StdPeriphLib\src/stm32f0xx_can.c ****                   If enabled, this interrupt source is pending when the warning limit 
1164:.\StdPeriphLib\src/stm32f0xx_can.c ****                   has been reached (Receive Error Counter or Transmit Error Counter=96). 
1165:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_IT_EPV: Error passive Interrupt;        
1166:.\StdPeriphLib\src/stm32f0xx_can.c ****                   If enabled, this interrupt source is pending when the Error Passive 
1167:.\StdPeriphLib\src/stm32f0xx_can.c ****                   limit has been reached (Receive Error Counter or Transmit Error Counter>127).
1168:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_IT_BOF: Bus-off Interrupt;
1169:.\StdPeriphLib\src/stm32f0xx_can.c ****                   If enabled, this interrupt source is pending when CAN enters 
1170:.\StdPeriphLib\src/stm32f0xx_can.c ****                   the bus-off state. The bus-off state is entered on TEC overflow, 
1171:.\StdPeriphLib\src/stm32f0xx_can.c ****                   greater than 255.
1172:.\StdPeriphLib\src/stm32f0xx_can.c ****                   This Flag is cleared only by hardware.
1173:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_IT_LEC: Last error code Interrupt;        
1174:.\StdPeriphLib\src/stm32f0xx_can.c ****                   If enabled, this interrupt source is pending when a message has 
1175:.\StdPeriphLib\src/stm32f0xx_can.c ****                   been transferred (reception or transmission) with error and the 
1176:.\StdPeriphLib\src/stm32f0xx_can.c ****                   error code is hold.
1177:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_IT_ERR: Error Interrupt;
1178:.\StdPeriphLib\src/stm32f0xx_can.c ****                   If enabled, this interrupt source is pending when an error condition 
1179:.\StdPeriphLib\src/stm32f0xx_can.c ****                   is pending.      
1180:.\StdPeriphLib\src/stm32f0xx_can.c ****     [..] Managing the CAN controller events: 
1181:.\StdPeriphLib\src/stm32f0xx_can.c ****          The user should identify which mode will be used in his application to manage 
1182:.\StdPeriphLib\src/stm32f0xx_can.c ****          the CAN controller events: Polling mode or Interrupt mode.
1183:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) In the Polling Mode it is advised to use the following functions:
1184:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_GetFlagStatus() : to check if flags events occur. 
1185:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_ClearFlag()     : to clear the flags events.
1186:.\StdPeriphLib\src/stm32f0xx_can.c ****          (+) In the Interrupt Mode it is advised to use the following functions:
1187:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_ITConfig()       : to enable or disable the interrupt source.
1188:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_GetITStatus()    : to check if Interrupt occurs.
1189:.\StdPeriphLib\src/stm32f0xx_can.c ****              (++) CAN_ClearITPendingBit() : to clear the Interrupt pending Bit 
1190:.\StdPeriphLib\src/stm32f0xx_can.c ****                   (corresponding Flag).
1191:.\StdPeriphLib\src/stm32f0xx_can.c ****                   This function has no impact on CAN_IT_FMP0 and CAN_IT_FMP1 Interrupts 
1192:.\StdPeriphLib\src/stm32f0xx_can.c ****                   pending bits since there are cleared only by hardware. 
1193:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1194:.\StdPeriphLib\src/stm32f0xx_can.c **** @endverbatim
1195:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @{
1196:.\StdPeriphLib\src/stm32f0xx_can.c ****   */ 
1197:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
1198:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Enables or disables the specified CANx interrupts.
1199:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
1200:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
1201:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          This parameter can be: 
1202:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
1203:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
1204:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
1205:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
1206:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
1207:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
1208:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
1209:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_WKU: Wake-up Interrupt
1210:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
1211:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_EWG: Error warning Interrupt
1212:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_EPV: Error passive Interrupt
1213:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_BOF: Bus-off Interrupt  
1214:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_LEC: Last error code Interrupt
1215:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_ERR: Error Interrupt
1216:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  NewState: new state of the CAN interrupts.
1217:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          This parameter can be: ENABLE or DISABLE.
1218:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval None
1219:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
1220:.\StdPeriphLib\src/stm32f0xx_can.c **** void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
1221:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 1522              		.loc 1 1221 0
 1523              		.cfi_startproc
 1524              	.LVL102:
1222:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
1223:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1224:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_IT(CAN_IT));
1225:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1226:.\StdPeriphLib\src/stm32f0xx_can.c **** 
1227:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (NewState != DISABLE)
 1525              		.loc 1 1227 0
 1526 0000 002A     		cmp	r2, #0
 1527 0002 03D0     		beq	.L120
1228:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
1229:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Enable the selected CANx interrupt */
1230:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->IER |= CAN_IT;
 1528              		.loc 1 1230 0
 1529 0004 4369     		ldr	r3, [r0, #20]
 1530 0006 1943     		orr	r1, r3
 1531              	.LVL103:
 1532 0008 4161     		str	r1, [r0, #20]
 1533 000a 02E0     		b	.L119
 1534              	.LVL104:
 1535              	.L120:
1231:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
1232:.\StdPeriphLib\src/stm32f0xx_can.c ****   else
1233:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
1234:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Disable the selected CANx interrupt */
1235:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->IER &= ~CAN_IT;
 1536              		.loc 1 1235 0
 1537 000c 4369     		ldr	r3, [r0, #20]
 1538 000e 8B43     		bic	r3, r1
 1539 0010 4361     		str	r3, [r0, #20]
 1540              	.LVL105:
 1541              	.L119:
1236:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
1237:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 1542              		.loc 1 1237 0
 1543              		@ sp needed
 1544 0012 7047     		bx	lr
 1545              		.cfi_endproc
 1546              	.LFE52:
 1548              		.section	.text.CAN_GetFlagStatus,"ax",%progbits
 1549              		.align	2
 1550              		.global	CAN_GetFlagStatus
 1551              		.code	16
 1552              		.thumb_func
 1554              	CAN_GetFlagStatus:
 1555              	.LFB53:
1238:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
1239:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Checks whether the specified CAN flag is set or not.
1240:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
1241:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CAN_FLAG: specifies the flag to check.
1242:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          This parameter can be one of the following values:
1243:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
1244:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
1245:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag
1246:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag   
1247:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
1248:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag 
1249:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag   
1250:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
1251:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
1252:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_WKU: Wake up Flag
1253:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag 
1254:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_EWG: Error Warning Flag
1255:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_EPV: Error Passive Flag  
1256:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_BOF: Bus-Off Flag    
1257:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_LEC: Last error code Flag      
1258:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval The new state of CAN_FLAG (SET or RESET).
1259:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
1260:.\StdPeriphLib\src/stm32f0xx_can.c **** FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
1261:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 1556              		.loc 1 1261 0
 1557              		.cfi_startproc
 1558              	.LVL106:
1262:.\StdPeriphLib\src/stm32f0xx_can.c ****   FlagStatus bitstatus = RESET;
1263:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1264:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
1265:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1266:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
1267:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1268:.\StdPeriphLib\src/stm32f0xx_can.c **** 
1269:.\StdPeriphLib\src/stm32f0xx_can.c ****   if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
 1559              		.loc 1 1269 0
 1560 0000 F023     		mov	r3, #240
 1561 0002 1B04     		lsl	r3, r3, #16
 1562 0004 1942     		tst	r1, r3
 1563 0006 08D0     		beq	.L123
1270:.\StdPeriphLib\src/stm32f0xx_can.c ****   { 
1271:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Check the status of the specified CAN flag */
1272:.\StdPeriphLib\src/stm32f0xx_can.c ****     if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 1564              		.loc 1 1272 0
 1565 0008 8369     		ldr	r3, [r0, #24]
 1566 000a 1B03     		lsl	r3, r3, #12
 1567 000c 1B0B     		lsr	r3, r3, #12
 1568 000e 1940     		and	r1, r3
 1569              	.LVL107:
 1570 0010 081C     		mov	r0, r1
 1571              	.LVL108:
 1572 0012 411E     		sub	r1, r0, #1
 1573 0014 8841     		sbc	r0, r0, r1
1273:.\StdPeriphLib\src/stm32f0xx_can.c ****     { 
1274:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* CAN_FLAG is set */
1275:.\StdPeriphLib\src/stm32f0xx_can.c ****       bitstatus = SET;
1276:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1277:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
1278:.\StdPeriphLib\src/stm32f0xx_can.c ****     { 
1279:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* CAN_FLAG is reset */
1280:.\StdPeriphLib\src/stm32f0xx_can.c ****       bitstatus = RESET;
 1574              		.loc 1 1280 0
 1575 0016 C0B2     		uxtb	r0, r0
 1576 0018 27E0     		b	.L124
 1577              	.LVL109:
 1578              	.L123:
1281:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1282:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
1283:.\StdPeriphLib\src/stm32f0xx_can.c ****   else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
 1579              		.loc 1 1283 0
 1580 001a CB01     		lsl	r3, r1, #7
 1581 001c 08D5     		bpl	.L125
1284:.\StdPeriphLib\src/stm32f0xx_can.c ****   { 
1285:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Check the status of the specified CAN flag */
1286:.\StdPeriphLib\src/stm32f0xx_can.c ****     if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 1582              		.loc 1 1286 0
 1583 001e 4368     		ldr	r3, [r0, #4]
 1584 0020 1B03     		lsl	r3, r3, #12
 1585 0022 1B0B     		lsr	r3, r3, #12
 1586 0024 1940     		and	r1, r3
 1587              	.LVL110:
 1588 0026 081C     		mov	r0, r1
 1589              	.LVL111:
 1590 0028 411E     		sub	r1, r0, #1
 1591 002a 8841     		sbc	r0, r0, r1
1280:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 1592              		.loc 1 1280 0
 1593 002c C0B2     		uxtb	r0, r0
 1594 002e 1CE0     		b	.L124
 1595              	.LVL112:
 1596              	.L125:
1287:.\StdPeriphLib\src/stm32f0xx_can.c ****     { 
1288:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* CAN_FLAG is set */
1289:.\StdPeriphLib\src/stm32f0xx_can.c ****       bitstatus = SET;
1290:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1291:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
1292:.\StdPeriphLib\src/stm32f0xx_can.c ****     { 
1293:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* CAN_FLAG is reset */
1294:.\StdPeriphLib\src/stm32f0xx_can.c ****       bitstatus = RESET;
1295:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1296:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
1297:.\StdPeriphLib\src/stm32f0xx_can.c ****   else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
 1597              		.loc 1 1297 0
 1598 0030 0B01     		lsl	r3, r1, #4
 1599 0032 08D5     		bpl	.L126
1298:.\StdPeriphLib\src/stm32f0xx_can.c ****   { 
1299:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Check the status of the specified CAN flag */
1300:.\StdPeriphLib\src/stm32f0xx_can.c ****     if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 1600              		.loc 1 1300 0
 1601 0034 8368     		ldr	r3, [r0, #8]
 1602 0036 1B03     		lsl	r3, r3, #12
 1603 0038 1B0B     		lsr	r3, r3, #12
 1604 003a 1940     		and	r1, r3
 1605              	.LVL113:
 1606 003c 081C     		mov	r0, r1
 1607              	.LVL114:
 1608 003e 411E     		sub	r1, r0, #1
 1609 0040 8841     		sbc	r0, r0, r1
1280:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 1610              		.loc 1 1280 0
 1611 0042 C0B2     		uxtb	r0, r0
 1612 0044 11E0     		b	.L124
 1613              	.LVL115:
 1614              	.L126:
1301:.\StdPeriphLib\src/stm32f0xx_can.c ****     { 
1302:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* CAN_FLAG is set */
1303:.\StdPeriphLib\src/stm32f0xx_can.c ****       bitstatus = SET;
1304:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1305:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
1306:.\StdPeriphLib\src/stm32f0xx_can.c ****     { 
1307:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* CAN_FLAG is reset */
1308:.\StdPeriphLib\src/stm32f0xx_can.c ****       bitstatus = RESET;
1309:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1310:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
1311:.\StdPeriphLib\src/stm32f0xx_can.c ****   else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
 1615              		.loc 1 1311 0
 1616 0046 8B01     		lsl	r3, r1, #6
 1617 0048 07D5     		bpl	.L127
1312:.\StdPeriphLib\src/stm32f0xx_can.c ****   { 
1313:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Check the status of the specified CAN flag */
1314:.\StdPeriphLib\src/stm32f0xx_can.c ****     if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 1618              		.loc 1 1314 0
 1619 004a C068     		ldr	r0, [r0, #12]
 1620              	.LVL116:
 1621 004c 0003     		lsl	r0, r0, #12
 1622 004e 000B     		lsr	r0, r0, #12
 1623 0050 0840     		and	r0, r1
 1624 0052 411E     		sub	r1, r0, #1
 1625 0054 8841     		sbc	r0, r0, r1
 1626              	.LVL117:
1280:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 1627              		.loc 1 1280 0
 1628 0056 C0B2     		uxtb	r0, r0
 1629 0058 07E0     		b	.L124
 1630              	.LVL118:
 1631              	.L127:
1315:.\StdPeriphLib\src/stm32f0xx_can.c ****     { 
1316:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* CAN_FLAG is set */
1317:.\StdPeriphLib\src/stm32f0xx_can.c ****       bitstatus = SET;
1318:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1319:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
1320:.\StdPeriphLib\src/stm32f0xx_can.c ****     { 
1321:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* CAN_FLAG is reset */
1322:.\StdPeriphLib\src/stm32f0xx_can.c ****       bitstatus = RESET;
1323:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1324:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
1325:.\StdPeriphLib\src/stm32f0xx_can.c ****   else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
1326:.\StdPeriphLib\src/stm32f0xx_can.c ****   { 
1327:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Check the status of the specified CAN flag */
1328:.\StdPeriphLib\src/stm32f0xx_can.c ****     if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 1632              		.loc 1 1328 0
 1633 005a 0369     		ldr	r3, [r0, #16]
 1634 005c 1B03     		lsl	r3, r3, #12
 1635 005e 1B0B     		lsr	r3, r3, #12
 1636 0060 1940     		and	r1, r3
 1637              	.LVL119:
 1638 0062 081C     		mov	r0, r1
 1639              	.LVL120:
 1640 0064 411E     		sub	r1, r0, #1
 1641 0066 8841     		sbc	r0, r0, r1
1280:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
 1642              		.loc 1 1280 0
 1643 0068 C0B2     		uxtb	r0, r0
 1644              	.L124:
 1645              	.LVL121:
1329:.\StdPeriphLib\src/stm32f0xx_can.c ****     { 
1330:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* CAN_FLAG is set */
1331:.\StdPeriphLib\src/stm32f0xx_can.c ****       bitstatus = SET;
1332:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1333:.\StdPeriphLib\src/stm32f0xx_can.c ****     else
1334:.\StdPeriphLib\src/stm32f0xx_can.c ****     { 
1335:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* CAN_FLAG is reset */
1336:.\StdPeriphLib\src/stm32f0xx_can.c ****       bitstatus = RESET;
1337:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1338:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
1339:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Return the CAN_FLAG status */
1340:.\StdPeriphLib\src/stm32f0xx_can.c ****   return  bitstatus;
1341:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 1646              		.loc 1 1341 0
 1647              		@ sp needed
 1648 006a 7047     		bx	lr
 1649              		.cfi_endproc
 1650              	.LFE53:
 1652              		.section	.text.CAN_ClearFlag,"ax",%progbits
 1653              		.align	2
 1654              		.global	CAN_ClearFlag
 1655              		.code	16
 1656              		.thumb_func
 1658              	CAN_ClearFlag:
 1659              	.LFB54:
1342:.\StdPeriphLib\src/stm32f0xx_can.c **** 
1343:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
1344:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Clears the CAN's pending flags.
1345:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
1346:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CAN_FLAG: specifies the flag to clear.
1347:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          This parameter can be one of the following values:
1348:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
1349:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
1350:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag 
1351:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
1352:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag  
1353:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
1354:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
1355:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_WKU: Wake up Flag
1356:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag    
1357:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_FLAG_LEC: Last error code Flag        
1358:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval None
1359:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
1360:.\StdPeriphLib\src/stm32f0xx_can.c **** void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
1361:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 1660              		.loc 1 1361 0
 1661              		.cfi_startproc
 1662              	.LVL122:
1362:.\StdPeriphLib\src/stm32f0xx_can.c ****   uint32_t flagtmp=0;
1363:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
1364:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1365:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
1366:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1367:.\StdPeriphLib\src/stm32f0xx_can.c ****   if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
 1663              		.loc 1 1367 0
 1664 0000 0A4B     		ldr	r3, .L134
 1665 0002 9942     		cmp	r1, r3
 1666 0004 02D1     		bne	.L129
1368:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
1369:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* Clear the selected CAN flags */
1370:.\StdPeriphLib\src/stm32f0xx_can.c ****     CANx->ESR = (uint32_t)RESET;
 1667              		.loc 1 1370 0
 1668 0006 0023     		mov	r3, #0
 1669 0008 8361     		str	r3, [r0, #24]
 1670 000a 0EE0     		b	.L128
 1671              	.L129:
1371:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
1372:.\StdPeriphLib\src/stm32f0xx_can.c ****   else /* MSR or TSR or RF0R or RF1R */
1373:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
1374:.\StdPeriphLib\src/stm32f0xx_can.c ****     flagtmp = CAN_FLAG & 0x000FFFFF;
 1672              		.loc 1 1374 0
 1673 000c 0B03     		lsl	r3, r1, #12
 1674 000e 1B0B     		lsr	r3, r3, #12
 1675              	.LVL123:
1375:.\StdPeriphLib\src/stm32f0xx_can.c **** 
1376:.\StdPeriphLib\src/stm32f0xx_can.c ****     if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
 1676              		.loc 1 1376 0
 1677 0010 8A01     		lsl	r2, r1, #6
 1678 0012 01D5     		bpl	.L131
1377:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
1378:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Receive Flags */
1379:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->RF0R = (uint32_t)(flagtmp);
 1679              		.loc 1 1379 0
 1680 0014 C360     		str	r3, [r0, #12]
 1681 0016 08E0     		b	.L128
 1682              	.L131:
1380:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1381:.\StdPeriphLib\src/stm32f0xx_can.c ****     else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
 1683              		.loc 1 1381 0
 1684 0018 4A01     		lsl	r2, r1, #5
 1685 001a 01D5     		bpl	.L132
1382:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
1383:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Receive Flags */
1384:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->RF1R = (uint32_t)(flagtmp);
 1686              		.loc 1 1384 0
 1687 001c 0361     		str	r3, [r0, #16]
 1688 001e 04E0     		b	.L128
 1689              	.L132:
1385:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1386:.\StdPeriphLib\src/stm32f0xx_can.c ****     else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
 1690              		.loc 1 1386 0
 1691 0020 0A01     		lsl	r2, r1, #4
 1692 0022 01D5     		bpl	.L133
1387:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
1388:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Transmit Flags */
1389:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->TSR = (uint32_t)(flagtmp);
 1693              		.loc 1 1389 0
 1694 0024 8360     		str	r3, [r0, #8]
 1695 0026 00E0     		b	.L128
 1696              	.L133:
1390:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1391:.\StdPeriphLib\src/stm32f0xx_can.c ****     else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
1392:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
1393:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Operating mode Flags */
1394:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MSR = (uint32_t)(flagtmp);
 1697              		.loc 1 1394 0
 1698 0028 4360     		str	r3, [r0, #4]
 1699              	.LVL124:
 1700              	.L128:
1395:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1396:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
1397:.\StdPeriphLib\src/stm32f0xx_can.c **** }
 1701              		.loc 1 1397 0
 1702              		@ sp needed
 1703 002a 7047     		bx	lr
 1704              	.L135:
 1705              		.align	2
 1706              	.L134:
 1707 002c 7000F030 		.word	821035120
 1708              		.cfi_endproc
 1709              	.LFE54:
 1711              		.section	.text.CAN_GetITStatus,"ax",%progbits
 1712              		.align	2
 1713              		.global	CAN_GetITStatus
 1714              		.code	16
 1715              		.thumb_func
 1717              	CAN_GetITStatus:
 1718              	.LFB55:
1398:.\StdPeriphLib\src/stm32f0xx_can.c **** 
1399:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
1400:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Checks whether the specified CANx interrupt has occurred or not.
1401:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
1402:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CAN_IT: specifies the CAN interrupt source to check.
1403:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          This parameter can be one of the following values:
1404:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
1405:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
1406:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
1407:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
1408:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
1409:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
1410:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
1411:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_WKU: Wake-up Interrupt
1412:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
1413:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_EWG: Error warning Interrupt
1414:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_EPV: Error passive Interrupt
1415:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_BOF: Bus-off Interrupt  
1416:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_LEC: Last error code Interrupt
1417:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_ERR: Error Interrupt
1418:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval The current state of CAN_IT (SET or RESET).
1419:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
1420:.\StdPeriphLib\src/stm32f0xx_can.c **** ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
1421:.\StdPeriphLib\src/stm32f0xx_can.c **** {
 1719              		.loc 1 1421 0
 1720              		.cfi_startproc
 1721              	.LVL125:
 1722 0000 031C     		mov	r3, r0
 1723              	.LVL126:
1422:.\StdPeriphLib\src/stm32f0xx_can.c ****   ITStatus itstatus = RESET;
1423:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
1424:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1425:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_IT(CAN_IT));
1426:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1427:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* check the interrupt enable bit */
1428:.\StdPeriphLib\src/stm32f0xx_can.c ****  if((CANx->IER & CAN_IT) != RESET)
 1724              		.loc 1 1428 0
 1725 0002 4269     		ldr	r2, [r0, #20]
1429:.\StdPeriphLib\src/stm32f0xx_can.c ****  {
1430:.\StdPeriphLib\src/stm32f0xx_can.c ****    /* in case the Interrupt is enabled, .... */
1431:.\StdPeriphLib\src/stm32f0xx_can.c ****     switch (CAN_IT)
1432:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
1433:.\StdPeriphLib\src/stm32f0xx_can.c ****       case CAN_IT_TME:
1434:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* Check CAN_TSR_RQCPx bits */
1435:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
1436:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1437:.\StdPeriphLib\src/stm32f0xx_can.c ****       case CAN_IT_FMP0:
1438:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* Check CAN_RF0R_FMP0 bit */
1439:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
1440:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1441:.\StdPeriphLib\src/stm32f0xx_can.c ****       case CAN_IT_FF0:
1442:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* Check CAN_RF0R_FULL0 bit */
1443:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
1444:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1445:.\StdPeriphLib\src/stm32f0xx_can.c ****       case CAN_IT_FOV0:
1446:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* Check CAN_RF0R_FOVR0 bit */
1447:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
1448:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1449:.\StdPeriphLib\src/stm32f0xx_can.c ****       case CAN_IT_FMP1:
1450:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* Check CAN_RF1R_FMP1 bit */
1451:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
1452:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1453:.\StdPeriphLib\src/stm32f0xx_can.c ****       case CAN_IT_FF1:
1454:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* Check CAN_RF1R_FULL1 bit */
1455:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
1456:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1457:.\StdPeriphLib\src/stm32f0xx_can.c ****       case CAN_IT_FOV1:
1458:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* Check CAN_RF1R_FOVR1 bit */
1459:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
1460:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1461:.\StdPeriphLib\src/stm32f0xx_can.c ****       case CAN_IT_WKU:
1462:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* Check CAN_MSR_WKUI bit */
1463:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
1464:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1465:.\StdPeriphLib\src/stm32f0xx_can.c ****       case CAN_IT_SLK:
1466:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* Check CAN_MSR_SLAKI bit */
1467:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
1468:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1469:.\StdPeriphLib\src/stm32f0xx_can.c ****       case CAN_IT_EWG:
1470:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* Check CAN_ESR_EWGF bit */
1471:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
1472:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1473:.\StdPeriphLib\src/stm32f0xx_can.c ****       case CAN_IT_EPV:
1474:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* Check CAN_ESR_EPVF bit */
1475:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
1476:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1477:.\StdPeriphLib\src/stm32f0xx_can.c ****       case CAN_IT_BOF:
1478:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* Check CAN_ESR_BOFF bit */
1479:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
1480:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1481:.\StdPeriphLib\src/stm32f0xx_can.c ****       case CAN_IT_LEC:
1482:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* Check CAN_ESR_LEC bit */
1483:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
1484:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1485:.\StdPeriphLib\src/stm32f0xx_can.c ****       case CAN_IT_ERR:
1486:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* Check CAN_MSR_ERRI bit */ 
1487:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
1488:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1489:.\StdPeriphLib\src/stm32f0xx_can.c ****       default:
1490:.\StdPeriphLib\src/stm32f0xx_can.c ****         /* in case of error, return RESET */
1491:.\StdPeriphLib\src/stm32f0xx_can.c ****         itstatus = RESET;
1492:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
1493:.\StdPeriphLib\src/stm32f0xx_can.c ****     }
1494:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
1495:.\StdPeriphLib\src/stm32f0xx_can.c ****   else
1496:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
1497:.\StdPeriphLib\src/stm32f0xx_can.c ****    /* in case the Interrupt is not enabled, return RESET */
1498:.\StdPeriphLib\src/stm32f0xx_can.c ****     itstatus  = RESET;
 1726              		.loc 1 1498 0
 1727 0004 0020     		mov	r0, #0
 1728              	.LVL127:
1428:.\StdPeriphLib\src/stm32f0xx_can.c ****  {
 1729              		.loc 1 1428 0
 1730 0006 0A42     		tst	r2, r1
 1731 0008 75D0     		beq	.L137
1431:.\StdPeriphLib\src/stm32f0xx_can.c ****     {
 1732              		.loc 1 1431 0
 1733 000a 4029     		cmp	r1, #64
 1734 000c 4FD0     		beq	.L138
 1735 000e 0ED8     		bhi	.L139
 1736 0010 0429     		cmp	r1, #4
 1737 0012 39D0     		beq	.L140
 1738 0014 04D8     		bhi	.L141
 1739 0016 0129     		cmp	r1, #1
 1740 0018 28D0     		beq	.L142
 1741 001a 0229     		cmp	r1, #2
 1742 001c 2DD0     		beq	.L143
 1743 001e 69E0     		b	.L156
 1744              	.L141:
 1745 0020 1029     		cmp	r1, #16
 1746 0022 39D0     		beq	.L144
 1747 0024 2029     		cmp	r1, #32
 1748 0026 3ED0     		beq	.L145
 1749 0028 0829     		cmp	r1, #8
 1750 002a 63D1     		bne	.L156
 1751 002c 30E0     		b	.L146
 1752              	.L139:
 1753 002e 8022     		mov	r2, #128
 1754 0030 1201     		lsl	r2, r2, #4
 1755 0032 9142     		cmp	r1, r2
 1756 0034 53D0     		beq	.L147
 1757 0036 0CD8     		bhi	.L148
 1758 0038 8022     		mov	r2, #128
 1759 003a 9200     		lsl	r2, r2, #2
 1760 003c 9142     		cmp	r1, r2
 1761 003e 46D0     		beq	.L149
 1762 0040 8022     		mov	r2, #128
 1763 0042 D200     		lsl	r2, r2, #3
 1764 0044 9142     		cmp	r1, r2
 1765 0046 46D0     		beq	.L150
 1766 0048 8022     		mov	r2, #128
 1767 004a 5200     		lsl	r2, r2, #1
 1768 004c 9142     		cmp	r1, r2
 1769 004e 51D1     		bne	.L156
 1770 0050 39E0     		b	.L151
 1771              	.L148:
 1772 0052 8022     		mov	r2, #128
 1773 0054 5202     		lsl	r2, r2, #9
 1774 0056 9142     		cmp	r1, r2
 1775 0058 2DD0     		beq	.L152
 1776 005a 8022     		mov	r2, #128
 1777 005c 9202     		lsl	r2, r2, #10
 1778 005e 9142     		cmp	r1, r2
 1779 0060 2DD0     		beq	.L153
 1780 0062 8022     		mov	r2, #128
 1781 0064 1202     		lsl	r2, r2, #8
 1782 0066 9142     		cmp	r1, r2
 1783 0068 44D1     		bne	.L156
 1784 006a 3FE0     		b	.L154
 1785              	.L142:
1435:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 1786              		.loc 1 1435 0
 1787 006c 9868     		ldr	r0, [r3, #8]
 1788              	.LVL128:
 1789              	.LBB30:
 1790              	.LBB31:
1499:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
1500:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1501:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Return the CAN_IT status */
1502:.\StdPeriphLib\src/stm32f0xx_can.c ****   return  itstatus;
1503:.\StdPeriphLib\src/stm32f0xx_can.c **** }
1504:.\StdPeriphLib\src/stm32f0xx_can.c **** 
1505:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
1506:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Clears the CANx's interrupt pending bits.
1507:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
1508:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CAN_IT: specifies the interrupt pending bit to clear.
1509:.\StdPeriphLib\src/stm32f0xx_can.c ****   *          This parameter can be one of the following values:
1510:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt
1511:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
1512:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
1513:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
1514:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
1515:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_WKU: Wake-up Interrupt
1516:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
1517:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_EWG: Error warning Interrupt
1518:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_EPV: Error passive Interrupt
1519:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_BOF: Bus-off Interrupt  
1520:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_LEC: Last error code Interrupt
1521:.\StdPeriphLib\src/stm32f0xx_can.c ****   *            @arg CAN_IT_ERR: Error Interrupt 
1522:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval None
1523:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
1524:.\StdPeriphLib\src/stm32f0xx_can.c **** void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
1525:.\StdPeriphLib\src/stm32f0xx_can.c **** {
1526:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
1527:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1528:.\StdPeriphLib\src/stm32f0xx_can.c ****   assert_param(IS_CAN_CLEAR_IT(CAN_IT));
1529:.\StdPeriphLib\src/stm32f0xx_can.c **** 
1530:.\StdPeriphLib\src/stm32f0xx_can.c ****   switch (CAN_IT)
1531:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
1532:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_TME:
1533:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Clear CAN_TSR_RQCPx (rc_w1)*/
1534:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
1535:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
1536:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_FF0:
1537:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Clear CAN_RF0R_FULL0 (rc_w1)*/
1538:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->RF0R = CAN_RF0R_FULL0; 
1539:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
1540:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_FOV0:
1541:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
1542:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->RF0R = CAN_RF0R_FOVR0; 
1543:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
1544:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_FF1:
1545:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Clear CAN_RF1R_FULL1 (rc_w1)*/
1546:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->RF1R = CAN_RF1R_FULL1;  
1547:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
1548:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_FOV1:
1549:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
1550:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->RF1R = CAN_RF1R_FOVR1; 
1551:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
1552:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_WKU:
1553:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Clear CAN_MSR_WKUI (rc_w1)*/
1554:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MSR = CAN_MSR_WKUI;  
1555:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
1556:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_SLK:
1557:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
1558:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MSR = CAN_MSR_SLAKI;   
1559:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
1560:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_EWG:
1561:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Clear CAN_MSR_ERRI (rc_w1) */
1562:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MSR = CAN_MSR_ERRI;
1563:.\StdPeriphLib\src/stm32f0xx_can.c ****        /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
1564:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
1565:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_EPV:
1566:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Clear CAN_MSR_ERRI (rc_w1) */
1567:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MSR = CAN_MSR_ERRI; 
1568:.\StdPeriphLib\src/stm32f0xx_can.c ****        /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
1569:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
1570:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_BOF:
1571:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Clear CAN_MSR_ERRI (rc_w1) */ 
1572:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MSR = CAN_MSR_ERRI; 
1573:.\StdPeriphLib\src/stm32f0xx_can.c ****        /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
1574:.\StdPeriphLib\src/stm32f0xx_can.c ****        break;
1575:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_LEC:
1576:.\StdPeriphLib\src/stm32f0xx_can.c ****       /*  Clear LEC bits */
1577:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->ESR = RESET; 
1578:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Clear CAN_MSR_ERRI (rc_w1) */
1579:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MSR = CAN_MSR_ERRI; 
1580:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
1581:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_ERR:
1582:.\StdPeriphLib\src/stm32f0xx_can.c ****       /*Clear LEC bits */
1583:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->ESR = RESET; 
1584:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Clear CAN_MSR_ERRI (rc_w1) */
1585:.\StdPeriphLib\src/stm32f0xx_can.c ****       CANx->MSR = CAN_MSR_ERRI; 
1586:.\StdPeriphLib\src/stm32f0xx_can.c ****        /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
1587:.\StdPeriphLib\src/stm32f0xx_can.c ****        break;
1588:.\StdPeriphLib\src/stm32f0xx_can.c ****     default:
1589:.\StdPeriphLib\src/stm32f0xx_can.c ****        break;
1590:.\StdPeriphLib\src/stm32f0xx_can.c ****    }
1591:.\StdPeriphLib\src/stm32f0xx_can.c **** }
1592:.\StdPeriphLib\src/stm32f0xx_can.c ****  /**
1593:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @}
1594:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
1595:.\StdPeriphLib\src/stm32f0xx_can.c **** 
1596:.\StdPeriphLib\src/stm32f0xx_can.c **** /**
1597:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @brief  Checks whether the CAN interrupt has occurred or not.
1598:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  CAN_Reg: specifies the CAN interrupt register to check.
1599:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @param  It_Bit: specifies the interrupt source bit to check.
1600:.\StdPeriphLib\src/stm32f0xx_can.c ****   * @retval The new state of the CAN Interrupt (SET or RESET).
1601:.\StdPeriphLib\src/stm32f0xx_can.c ****   */
1602:.\StdPeriphLib\src/stm32f0xx_can.c **** static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
1603:.\StdPeriphLib\src/stm32f0xx_can.c **** {
1604:.\StdPeriphLib\src/stm32f0xx_can.c ****   ITStatus pendingbitstatus = RESET;
1605:.\StdPeriphLib\src/stm32f0xx_can.c ****   
1606:.\StdPeriphLib\src/stm32f0xx_can.c ****   if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
 1791              		.loc 1 1606 0
 1792 006e 224B     		ldr	r3, .L157
 1793              	.LVL129:
 1794 0070 1840     		and	r0, r3
 1795              	.LVL130:
 1796 0072 431E     		sub	r3, r0, #1
 1797 0074 9841     		sbc	r0, r0, r3
 1798              	.LBE31:
 1799              	.LBE30:
 1800              	.LBB32:
 1801              	.LBB33:
1607:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
1608:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* CAN_IT is set */
1609:.\StdPeriphLib\src/stm32f0xx_can.c ****     pendingbitstatus = SET;
 1802              		.loc 1 1609 0
 1803 0076 C0B2     		uxtb	r0, r0
 1804 0078 3DE0     		b	.L137
 1805              	.LVL131:
 1806              	.L143:
 1807              	.LBE33:
 1808              	.LBE32:
1439:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 1809              		.loc 1 1439 0
 1810 007a DB68     		ldr	r3, [r3, #12]
 1811              	.LVL132:
 1812              	.LBB35:
 1813              	.LBB36:
1606:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 1814              		.loc 1 1606 0
 1815 007c 0320     		mov	r0, #3
 1816 007e 1840     		and	r0, r3
 1817 0080 431E     		sub	r3, r0, #1
 1818 0082 9841     		sbc	r0, r0, r3
 1819              	.LVL133:
1610:.\StdPeriphLib\src/stm32f0xx_can.c ****   }
1611:.\StdPeriphLib\src/stm32f0xx_can.c ****   else
1612:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
1613:.\StdPeriphLib\src/stm32f0xx_can.c ****     /* CAN_IT is reset */
1614:.\StdPeriphLib\src/stm32f0xx_can.c ****     pendingbitstatus = RESET;
 1820              		.loc 1 1614 0
 1821 0084 C0B2     		uxtb	r0, r0
 1822 0086 36E0     		b	.L137
 1823              	.LVL134:
 1824              	.L140:
 1825              	.LBE36:
 1826              	.LBE35:
1443:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 1827              		.loc 1 1443 0
 1828 0088 D868     		ldr	r0, [r3, #12]
 1829              	.LVL135:
 1830              	.LBB49:
 1831              	.LBB50:
1606:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 1832              		.loc 1 1606 0
 1833 008a 0007     		lsl	r0, r0, #28
 1834              	.LVL136:
 1835              	.LBE50:
 1836              	.LBE49:
 1837              	.LBB51:
 1838              	.LBB37:
 1839              		.loc 1 1614 0
 1840 008c C00F     		lsr	r0, r0, #31
 1841 008e 32E0     		b	.L137
 1842              	.LVL137:
 1843              	.L146:
 1844              	.LBE37:
 1845              	.LBE51:
1447:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 1846              		.loc 1 1447 0
 1847 0090 D868     		ldr	r0, [r3, #12]
 1848              	.LVL138:
 1849              	.LBB52:
 1850              	.LBB53:
1606:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 1851              		.loc 1 1606 0
 1852 0092 C006     		lsl	r0, r0, #27
 1853              	.LVL139:
 1854              	.LBE53:
 1855              	.LBE52:
 1856              	.LBB54:
 1857              	.LBB38:
 1858              		.loc 1 1614 0
 1859 0094 C00F     		lsr	r0, r0, #31
 1860 0096 2EE0     		b	.L137
 1861              	.LVL140:
 1862              	.L144:
 1863              	.LBE38:
 1864              	.LBE54:
1451:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 1865              		.loc 1 1451 0
 1866 0098 1B69     		ldr	r3, [r3, #16]
 1867              	.LVL141:
 1868              	.LBB55:
 1869              	.LBB56:
1606:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 1870              		.loc 1 1606 0
 1871 009a 0320     		mov	r0, #3
 1872 009c 1840     		and	r0, r3
 1873 009e 431E     		sub	r3, r0, #1
 1874 00a0 9841     		sbc	r0, r0, r3
 1875              	.LVL142:
 1876              	.LBE56:
 1877              	.LBE55:
 1878              	.LBB57:
 1879              	.LBB39:
 1880              		.loc 1 1614 0
 1881 00a2 C0B2     		uxtb	r0, r0
 1882 00a4 27E0     		b	.L137
 1883              	.LVL143:
 1884              	.L145:
 1885              	.LBE39:
 1886              	.LBE57:
1455:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 1887              		.loc 1 1455 0
 1888 00a6 1869     		ldr	r0, [r3, #16]
 1889              	.LVL144:
 1890              	.LBB58:
 1891              	.LBB59:
1606:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 1892              		.loc 1 1606 0
 1893 00a8 0007     		lsl	r0, r0, #28
 1894              	.LVL145:
 1895              	.LBE59:
 1896              	.LBE58:
 1897              	.LBB60:
 1898              	.LBB40:
 1899              		.loc 1 1614 0
 1900 00aa C00F     		lsr	r0, r0, #31
 1901 00ac 23E0     		b	.L137
 1902              	.LVL146:
 1903              	.L138:
 1904              	.LBE40:
 1905              	.LBE60:
1459:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 1906              		.loc 1 1459 0
 1907 00ae 1869     		ldr	r0, [r3, #16]
 1908              	.LVL147:
 1909              	.LBB61:
 1910              	.LBB62:
1606:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 1911              		.loc 1 1606 0
 1912 00b0 C006     		lsl	r0, r0, #27
 1913              	.LVL148:
 1914              	.LBE62:
 1915              	.LBE61:
 1916              	.LBB63:
 1917              	.LBB41:
 1918              		.loc 1 1614 0
 1919 00b2 C00F     		lsr	r0, r0, #31
 1920 00b4 1FE0     		b	.L137
 1921              	.LVL149:
 1922              	.L152:
 1923              	.LBE41:
 1924              	.LBE63:
1463:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 1925              		.loc 1 1463 0
 1926 00b6 5868     		ldr	r0, [r3, #4]
 1927              	.LVL150:
 1928              	.LBB64:
 1929              	.LBB65:
1606:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 1930              		.loc 1 1606 0
 1931 00b8 0007     		lsl	r0, r0, #28
 1932              	.LVL151:
 1933              	.LBE65:
 1934              	.LBE64:
 1935              	.LBB66:
 1936              	.LBB42:
 1937              		.loc 1 1614 0
 1938 00ba C00F     		lsr	r0, r0, #31
 1939 00bc 1BE0     		b	.L137
 1940              	.LVL152:
 1941              	.L153:
 1942              	.LBE42:
 1943              	.LBE66:
1467:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 1944              		.loc 1 1467 0
 1945 00be 5868     		ldr	r0, [r3, #4]
 1946              	.LVL153:
 1947              	.LBB67:
 1948              	.LBB68:
1606:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 1949              		.loc 1 1606 0
 1950 00c0 C006     		lsl	r0, r0, #27
 1951              	.LVL154:
 1952              	.LBE68:
 1953              	.LBE67:
 1954              	.LBB69:
 1955              	.LBB43:
 1956              		.loc 1 1614 0
 1957 00c2 C00F     		lsr	r0, r0, #31
 1958 00c4 17E0     		b	.L137
 1959              	.LVL155:
 1960              	.L151:
 1961              	.LBE43:
 1962              	.LBE69:
1471:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 1963              		.loc 1 1471 0
 1964 00c6 9B69     		ldr	r3, [r3, #24]
 1965              	.LVL156:
 1966              	.LBB70:
 1967              	.LBB44:
 1968              		.loc 1 1614 0
 1969 00c8 0120     		mov	r0, #1
 1970 00ca 1840     		and	r0, r3
 1971 00cc 13E0     		b	.L137
 1972              	.LVL157:
 1973              	.L149:
 1974              	.LBE44:
 1975              	.LBE70:
1475:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 1976              		.loc 1 1475 0
 1977 00ce 9869     		ldr	r0, [r3, #24]
 1978              	.LVL158:
 1979              	.LBB71:
 1980              	.LBB72:
1606:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 1981              		.loc 1 1606 0
 1982 00d0 8007     		lsl	r0, r0, #30
 1983              	.LVL159:
 1984              	.LBE72:
 1985              	.LBE71:
 1986              	.LBB73:
 1987              	.LBB45:
 1988              		.loc 1 1614 0
 1989 00d2 C00F     		lsr	r0, r0, #31
 1990 00d4 0FE0     		b	.L137
 1991              	.LVL160:
 1992              	.L150:
 1993              	.LBE45:
 1994              	.LBE73:
1479:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 1995              		.loc 1 1479 0
 1996 00d6 9869     		ldr	r0, [r3, #24]
 1997              	.LVL161:
 1998              	.LBB74:
 1999              	.LBB75:
1606:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 2000              		.loc 1 1606 0
 2001 00d8 4007     		lsl	r0, r0, #29
 2002              	.LVL162:
 2003              	.LBE75:
 2004              	.LBE74:
 2005              	.LBB76:
 2006              	.LBB46:
 2007              		.loc 1 1614 0
 2008 00da C00F     		lsr	r0, r0, #31
 2009 00dc 0BE0     		b	.L137
 2010              	.LVL163:
 2011              	.L147:
 2012              	.LBE46:
 2013              	.LBE76:
1483:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 2014              		.loc 1 1483 0
 2015 00de 9B69     		ldr	r3, [r3, #24]
 2016              	.LVL164:
 2017              	.LBB77:
 2018              	.LBB34:
1606:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 2019              		.loc 1 1606 0
 2020 00e0 7020     		mov	r0, #112
 2021 00e2 1840     		and	r0, r3
 2022 00e4 431E     		sub	r3, r0, #1
 2023 00e6 9841     		sbc	r0, r0, r3
 2024              	.LVL165:
 2025              	.LBE34:
 2026              	.LBE77:
 2027              	.LBB78:
 2028              	.LBB47:
 2029              		.loc 1 1614 0
 2030 00e8 C0B2     		uxtb	r0, r0
 2031 00ea 04E0     		b	.L137
 2032              	.LVL166:
 2033              	.L154:
 2034              	.LBE47:
 2035              	.LBE78:
1487:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 2036              		.loc 1 1487 0
 2037 00ec 5868     		ldr	r0, [r3, #4]
 2038              	.LVL167:
 2039              	.LBB79:
 2040              	.LBB80:
1606:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 2041              		.loc 1 1606 0
 2042 00ee 4007     		lsl	r0, r0, #29
 2043              	.LVL168:
 2044              	.LBE80:
 2045              	.LBE79:
 2046              	.LBB81:
 2047              	.LBB48:
 2048              		.loc 1 1614 0
 2049 00f0 C00F     		lsr	r0, r0, #31
 2050 00f2 00E0     		b	.L137
 2051              	.LVL169:
 2052              	.L156:
 2053              	.LBE48:
 2054              	.LBE81:
1491:.\StdPeriphLib\src/stm32f0xx_can.c ****         break;
 2055              		.loc 1 1491 0
 2056 00f4 0020     		mov	r0, #0
 2057              	.LVL170:
 2058              	.L137:
1503:.\StdPeriphLib\src/stm32f0xx_can.c **** 
 2059              		.loc 1 1503 0
 2060              		@ sp needed
 2061 00f6 7047     		bx	lr
 2062              	.L158:
 2063              		.align	2
 2064              	.L157:
 2065 00f8 01010100 		.word	65793
 2066              		.cfi_endproc
 2067              	.LFE55:
 2069              		.section	.text.CAN_ClearITPendingBit,"ax",%progbits
 2070              		.align	2
 2071              		.global	CAN_ClearITPendingBit
 2072              		.code	16
 2073              		.thumb_func
 2075              	CAN_ClearITPendingBit:
 2076              	.LFB56:
1525:.\StdPeriphLib\src/stm32f0xx_can.c ****   /* Check the parameters */
 2077              		.loc 1 1525 0
 2078              		.cfi_startproc
 2079              	.LVL171:
1530:.\StdPeriphLib\src/stm32f0xx_can.c ****   {
 2080              		.loc 1 1530 0
 2081 0000 8023     		mov	r3, #128
 2082 0002 5B00     		lsl	r3, r3, #1
 2083 0004 9942     		cmp	r1, r3
 2084 0006 3DD0     		beq	.L161
 2085 0008 0CD8     		bhi	.L162
 2086 000a 0829     		cmp	r1, #8
 2087 000c 2BD0     		beq	.L163
 2088 000e 04D8     		bhi	.L164
 2089 0010 0129     		cmp	r1, #1
 2090 0012 22D0     		beq	.L165
 2091 0014 0429     		cmp	r1, #4
 2092 0016 23D0     		beq	.L166
 2093 0018 46E0     		b	.L159
 2094              	.L164:
 2095 001a 2029     		cmp	r1, #32
 2096 001c 26D0     		beq	.L167
 2097 001e 4029     		cmp	r1, #64
 2098 0020 27D0     		beq	.L168
 2099 0022 41E0     		b	.L159
 2100              	.L162:
 2101 0024 8023     		mov	r3, #128
 2102 0026 1B01     		lsl	r3, r3, #4
 2103 0028 9942     		cmp	r1, r3
 2104 002a 34D0     		beq	.L169
 2105 002c 08D8     		bhi	.L170
 2106 002e 8023     		mov	r3, #128
 2107 0030 9B00     		lsl	r3, r3, #2
 2108 0032 9942     		cmp	r1, r3
 2109 0034 29D0     		beq	.L171
 2110 0036 8023     		mov	r3, #128
 2111 0038 DB00     		lsl	r3, r3, #3
 2112 003a 9942     		cmp	r1, r3
 2113 003c 28D0     		beq	.L172
 2114 003e 33E0     		b	.L159
 2115              	.L170:
 2116 0040 8023     		mov	r3, #128
 2117 0042 5B02     		lsl	r3, r3, #9
 2118 0044 9942     		cmp	r1, r3
 2119 0046 17D0     		beq	.L173
 2120 0048 8023     		mov	r3, #128
 2121 004a 9B02     		lsl	r3, r3, #10
 2122 004c 9942     		cmp	r1, r3
 2123 004e 16D0     		beq	.L174
 2124 0050 8023     		mov	r3, #128
 2125 0052 1B02     		lsl	r3, r3, #8
 2126 0054 9942     		cmp	r1, r3
 2127 0056 27D1     		bne	.L159
 2128 0058 22E0     		b	.L175
 2129              	.L165:
1534:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 2130              		.loc 1 1534 0
 2131 005a 144B     		ldr	r3, .L176
 2132 005c 8360     		str	r3, [r0, #8]
1535:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_FF0:
 2133              		.loc 1 1535 0
 2134 005e 23E0     		b	.L159
 2135              	.L166:
1538:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 2136              		.loc 1 1538 0
 2137 0060 0823     		mov	r3, #8
 2138 0062 C360     		str	r3, [r0, #12]
1539:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_FOV0:
 2139              		.loc 1 1539 0
 2140 0064 20E0     		b	.L159
 2141              	.L163:
1542:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 2142              		.loc 1 1542 0
 2143 0066 1023     		mov	r3, #16
 2144 0068 C360     		str	r3, [r0, #12]
1543:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_FF1:
 2145              		.loc 1 1543 0
 2146 006a 1DE0     		b	.L159
 2147              	.L167:
1546:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 2148              		.loc 1 1546 0
 2149 006c 0823     		mov	r3, #8
 2150 006e 0361     		str	r3, [r0, #16]
1547:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_FOV1:
 2151              		.loc 1 1547 0
 2152 0070 1AE0     		b	.L159
 2153              	.L168:
1550:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 2154              		.loc 1 1550 0
 2155 0072 1023     		mov	r3, #16
 2156 0074 0361     		str	r3, [r0, #16]
1551:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_WKU:
 2157              		.loc 1 1551 0
 2158 0076 17E0     		b	.L159
 2159              	.L173:
1554:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 2160              		.loc 1 1554 0
 2161 0078 0823     		mov	r3, #8
 2162 007a 4360     		str	r3, [r0, #4]
1555:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_SLK:
 2163              		.loc 1 1555 0
 2164 007c 14E0     		b	.L159
 2165              	.L174:
1558:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 2166              		.loc 1 1558 0
 2167 007e 1023     		mov	r3, #16
 2168 0080 4360     		str	r3, [r0, #4]
1559:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_EWG:
 2169              		.loc 1 1559 0
 2170 0082 11E0     		b	.L159
 2171              	.L161:
1562:.\StdPeriphLib\src/stm32f0xx_can.c ****        /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
 2172              		.loc 1 1562 0
 2173 0084 0423     		mov	r3, #4
 2174 0086 4360     		str	r3, [r0, #4]
1564:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_EPV:
 2175              		.loc 1 1564 0
 2176 0088 0EE0     		b	.L159
 2177              	.L171:
1567:.\StdPeriphLib\src/stm32f0xx_can.c ****        /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
 2178              		.loc 1 1567 0
 2179 008a 0423     		mov	r3, #4
 2180 008c 4360     		str	r3, [r0, #4]
1569:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_BOF:
 2181              		.loc 1 1569 0
 2182 008e 0BE0     		b	.L159
 2183              	.L172:
1572:.\StdPeriphLib\src/stm32f0xx_can.c ****        /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
 2184              		.loc 1 1572 0
 2185 0090 0423     		mov	r3, #4
 2186 0092 4360     		str	r3, [r0, #4]
1574:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_LEC:
 2187              		.loc 1 1574 0
 2188 0094 08E0     		b	.L159
 2189              	.L169:
1577:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Clear CAN_MSR_ERRI (rc_w1) */
 2190              		.loc 1 1577 0
 2191 0096 0023     		mov	r3, #0
 2192 0098 8361     		str	r3, [r0, #24]
1579:.\StdPeriphLib\src/stm32f0xx_can.c ****       break;
 2193              		.loc 1 1579 0
 2194 009a 0433     		add	r3, r3, #4
 2195 009c 4360     		str	r3, [r0, #4]
1580:.\StdPeriphLib\src/stm32f0xx_can.c ****     case CAN_IT_ERR:
 2196              		.loc 1 1580 0
 2197 009e 03E0     		b	.L159
 2198              	.L175:
1583:.\StdPeriphLib\src/stm32f0xx_can.c ****       /* Clear CAN_MSR_ERRI (rc_w1) */
 2199              		.loc 1 1583 0
 2200 00a0 0023     		mov	r3, #0
 2201 00a2 8361     		str	r3, [r0, #24]
1585:.\StdPeriphLib\src/stm32f0xx_can.c ****        /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
 2202              		.loc 1 1585 0
 2203 00a4 0433     		add	r3, r3, #4
 2204 00a6 4360     		str	r3, [r0, #4]
 2205              	.L159:
1591:.\StdPeriphLib\src/stm32f0xx_can.c ****  /**
 2206              		.loc 1 1591 0
 2207              		@ sp needed
 2208 00a8 7047     		bx	lr
 2209              	.L177:
 2210 00aa C046     		.align	2
 2211              	.L176:
 2212 00ac 01010100 		.word	65793
 2213              		.cfi_endproc
 2214              	.LFE56:
 2216              		.text
 2217              	.Letext0:
 2218              		.file 2 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 2219              		.file 3 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 2220              		.file 4 ".\\CMSIS/stm32f0xx.h"
 2221              		.file 5 ".\\StdPeriphLib\\inc/stm32f0xx_can.h"
 2222              		.file 6 ".\\StdPeriphLib\\inc/stm32f0xx_rcc.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f0xx_can.c
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:18     .text.CAN_DeInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:23     .text.CAN_DeInit:00000000 CAN_DeInit
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:54     .text.CAN_Init:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:59     .text.CAN_Init:00000000 CAN_Init
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:272    .text.CAN_Init:00000108 $d
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:277    .text.CAN_FilterInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:282    .text.CAN_FilterInit:00000000 CAN_FilterInit
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:469    .text.CAN_FilterInit:000000f4 $d
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:475    .text.CAN_StructInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:480    .text.CAN_StructInit:00000000 CAN_StructInit
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:518    .text.CAN_SlaveStartBank:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:523    .text.CAN_SlaveStartBank:00000000 CAN_SlaveStartBank
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:563    .text.CAN_SlaveStartBank:00000028 $d
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:569    .text.CAN_DBGFreeze:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:574    .text.CAN_DBGFreeze:00000000 CAN_DBGFreeze
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:602    .text.CAN_DBGFreeze:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:607    .text.CAN_TTComModeCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:612    .text.CAN_TTComModeCmd:00000000 CAN_TTComModeCmd
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:678    .text.CAN_TTComModeCmd:00000054 $d
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:683    .text.CAN_Transmit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:688    .text.CAN_Transmit:00000000 CAN_Transmit
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:855    .text.CAN_TransmitStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:860    .text.CAN_TransmitStatus:00000000 CAN_TransmitStatus
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:948    .text.CAN_TransmitStatus:00000050 $d
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:955    .text.CAN_CancelTransmit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:960    .text.CAN_CancelTransmit:00000000 CAN_CancelTransmit
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1005   .text.CAN_Receive:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1010   .text.CAN_Receive:00000000 CAN_Receive
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1126   .text.CAN_FIFORelease:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1131   .text.CAN_FIFORelease:00000000 CAN_FIFORelease
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1159   .text.CAN_MessagePending:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1164   .text.CAN_MessagePending:00000000 CAN_MessagePending
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1203   .text.CAN_OperatingModeRequest:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1208   .text.CAN_OperatingModeRequest:00000000 CAN_OperatingModeRequest
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1349   .text.CAN_OperatingModeRequest:000000a8 $d
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1354   .text.CAN_Sleep:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1359   .text.CAN_Sleep:00000000 CAN_Sleep
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1391   .text.CAN_WakeUp:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1396   .text.CAN_WakeUp:00000000 CAN_WakeUp
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1439   .text.CAN_WakeUp:0000002c $d
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1444   .text.CAN_GetLastErrorCode:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1449   .text.CAN_GetLastErrorCode:00000000 CAN_GetLastErrorCode
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1468   .text.CAN_GetReceiveErrorCounter:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1473   .text.CAN_GetReceiveErrorCounter:00000000 CAN_GetReceiveErrorCounter
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1491   .text.CAN_GetLSBTransmitErrorCounter:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1496   .text.CAN_GetLSBTransmitErrorCounter:00000000 CAN_GetLSBTransmitErrorCounter
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1515   .text.CAN_ITConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1520   .text.CAN_ITConfig:00000000 CAN_ITConfig
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1549   .text.CAN_GetFlagStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1554   .text.CAN_GetFlagStatus:00000000 CAN_GetFlagStatus
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1653   .text.CAN_ClearFlag:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1658   .text.CAN_ClearFlag:00000000 CAN_ClearFlag
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1707   .text.CAN_ClearFlag:0000002c $d
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1712   .text.CAN_GetITStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:1717   .text.CAN_GetITStatus:00000000 CAN_GetITStatus
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:2065   .text.CAN_GetITStatus:000000f8 $d
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:2070   .text.CAN_ClearITPendingBit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:2075   .text.CAN_ClearITPendingBit:00000000 CAN_ClearITPendingBit
C:\Users\Dima\AppData\Local\Temp\ccHUcbNc.s:2212   .text.CAN_ClearITPendingBit:000000ac $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
RCC_APB1PeriphResetCmd
