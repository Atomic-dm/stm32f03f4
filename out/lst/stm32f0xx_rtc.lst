   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"stm32f0xx_rtc.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.RTC_ByteToBcd2,"ax",%progbits
  18              		.align	2
  19              		.code	16
  20              		.thumb_func
  22              	RTC_ByteToBcd2:
  23              	.LFB84:
  24              		.file 1 ".\\StdPeriphLib\\src/stm32f0xx_rtc.c"
   1:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
   2:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ******************************************************************************
   3:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @file    stm32f0xx_rtc.c
   4:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @author  MCD Application Team
   5:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @version V1.5.0
   6:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @date    05-December-2014
   7:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief   This file provides firmware functions to manage the following 
   8:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          functionalities of the Real-Time Clock (RTC) peripheral:
   9:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *           + Initialization
  10:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *           + Calendar (Time and Date) configuration
  11:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *           + Alarms (Alarm A) configuration
  12:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *           + Daylight Saving configuration
  13:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *           + Output pin Configuration
  14:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *           + Digital Calibration configuration  
  15:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *           + TimeStamp configuration
  16:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *           + Tampers configuration
  17:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *           + Backup Data Registers configuration
  18:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *           + Output Type Config configuration
  19:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *           + Shift control synchronisation  
  20:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *           + Interrupts and flags management
  21:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *
  22:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  @verbatim
  23:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
  24:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                     ##### Backup Domain Operating Condition #####
  25:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
  26:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] The real-time clock (RTC) and the RTC backup registers can be powered
  27:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          from the VBAT voltage when the main VDD supply is powered off.
  28:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          To retain the content of the RTC backup registers and supply the RTC 
  29:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          when VDD is turned off, VBAT pin can be connected to an optional
  30:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          standby voltage supplied by a battery or by another source.
  31:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
  32:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] To allow the RTC to operate even when the main digital supply (VDD) 
  33:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          is turned off, the VBAT pin powers the following blocks:
  34:.\StdPeriphLib\src/stm32f0xx_rtc.c ****            (#) The RTC
  35:.\StdPeriphLib\src/stm32f0xx_rtc.c ****            (#) The LSE oscillator
  36:.\StdPeriphLib\src/stm32f0xx_rtc.c ****            (#) PC13 to PC15 I/Os I/Os (when available)
  37:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
  38:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] When the backup domain is supplied by VDD (analog switch connected 
  39:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          to VDD), the following functions are available:
  40:.\StdPeriphLib\src/stm32f0xx_rtc.c ****            (#) PC14 and PC15 can be used as either GPIO or LSE pins
  41:.\StdPeriphLib\src/stm32f0xx_rtc.c ****            (#) PC13 can be used as a GPIO or as the RTC_AF1 pin
  42:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
  43:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] When the backup domain is supplied by VBAT (analog switch connected 
  44:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          to VBAT because VDD is not present), the following functions are available:
  45:.\StdPeriphLib\src/stm32f0xx_rtc.c ****            (#) PC14 and PC15 can be used as LSE pins only
  46:.\StdPeriphLib\src/stm32f0xx_rtc.c ****            (#) PC13 can be used as the RTC_AF1 pin 
  47:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
  48:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                      ##### Backup Domain Reset #####
  49:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
  50:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] The backup domain reset sets all RTC registers and the RCC_BDCR 
  51:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          register to their reset values. 
  52:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          A backup domain reset is generated when one of the following events
  53:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          occurs:
  54:.\StdPeriphLib\src/stm32f0xx_rtc.c ****            (#) Software reset, triggered by setting the BDRST bit in the 
  55:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                RCC Backup domain control register (RCC_BDCR). You can use the
  56:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                RCC_BackupResetCmd().
  57:.\StdPeriphLib\src/stm32f0xx_rtc.c ****            (#) VDD or VBAT power on, if both supplies have previously been
  58:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                powered off.
  59:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
  60:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                      ##### Backup Domain Access #####
  61:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
  62:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] After reset, the backup domain (RTC registers and RTC backup data 
  63:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          registers) is protected against possible unwanted write accesses. 
  64:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] To enable access to the Backup Domain and RTC registers, proceed as follows:
  65:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (#) Enable the Power Controller (PWR) APB1 interface clock using the
  66:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              RCC_APB1PeriphClockCmd() function.
  67:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (#) Enable access to Backup domain using the PWR_BackupAccessCmd() function.
  68:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (#) Select the RTC clock source using the RCC_RTCCLKConfig() function.
  69:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (#) Enable RTC Clock using the RCC_RTCCLKCmd() function.
  70:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                                                                            
  71:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
  72:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                      ##### How to use this driver #####
  73:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
  74:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..]
  75:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Enable the backup domain access (see description in the section above)
  76:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Configure the RTC Prescaler (Asynchronous and Synchronous) and
  77:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             RTC hour format using the RTC_Init() function.
  78:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
  79:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ***Time and Date configuration ***
  80:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ==================================
  81:.\StdPeriphLib\src/stm32f0xx_rtc.c ****      [..]
  82:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) To configure the RTC Calendar (Time and Date) use the RTC_SetTime()
  83:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             and RTC_SetDate() functions.
  84:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) To read the RTC Calendar, use the RTC_GetTime() and RTC_GetDate()
  85:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             functions.
  86:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) To read the RTC subsecond, use the RTC_GetSubSecond() function.
  87:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Use the RTC_DayLightSavingConfig() function to add or sub one
  88:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             hour to the RTC Calendar.
  89:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
  90:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ***Alarm configuration ***
  91:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ========================== 
  92:.\StdPeriphLib\src/stm32f0xx_rtc.c ****      [..]  
  93:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) To configure the RTC Alarm use the RTC_SetAlarm() function.
  94:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Enable the selected RTC Alarm using the RTC_AlarmCmd() function  
  95:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) To read the RTC Alarm, use the RTC_GetAlarm() function.
  96:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) To read the RTC alarm SubSecond, use the RTC_GetAlarmSubSecond() function.
  97:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
  98:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ***RTC Wakeup configuration***
  99:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ========================== 
 100:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..]  
 101:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Configure the RTC Wakeup Clock source use the RTC_WakeUpClockConfig()
 102:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             function.
 103:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Configure the RTC WakeUp Counter using the RTC_SetWakeUpCounter() 
 104:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             function  
 105:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Enable the RTC WakeUp using the RTC_WakeUpCmd() function  
 106:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) To read the RTC WakeUp Counter register, use the RTC_GetWakeUpCounter() 
 107:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             function.
 108:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 109:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ***Outputs configuration ***
 110:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ============================
 111:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] The RTC has 2 different outputs:
 112:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) AFO_ALARM: this output is used to manage the RTC Alarm A.
 113:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             To output the selected RTC signal on RTC_AF1 pin, use the 
 114:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             RTC_OutputConfig() function.                
 115:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) AFO_CALIB: this output is 512Hz signal or 1Hz .
 116:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             To output the RTC Clock on RTC_AF1 pin, use the RTC_CalibOutputCmd()
 117:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             function.                
 118:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 119:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ***Original Digital Calibration configuration ***
 120:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  =================================    
 121:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] Configure the RTC Original Digital Calibration Value and the corresponding
 122:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          calibration cycle period (32s,16s and 8s) using the RTC_SmoothCalibConfig()
 123:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          function.
 124:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 125:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ***TimeStamp configuration ***
 126:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ==============================
 127:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..]  
 128:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Configure the RTC_AF1 trigger and enables the RTC TimeStamp 
 129:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             using the RTC_TimeStampCmd() function.
 130:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) To read the RTC TimeStamp Time and Date register, use the 
 131:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             RTC_GetTimeStamp() function.
 132:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) To read the RTC TimeStamp SubSecond register, use the 
 133:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             RTC_GetTimeStampSubSecond() function.
 134:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 135:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ***Tamper configuration ***
 136:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===========================
 137:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..]   
 138:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Configure the Tamper filter count using RTC_TamperFilterConfig()
 139:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             function. 
 140:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Configure the RTC Tamper trigger Edge or Level according to the Tamper 
 141:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             filter (if equal to 0 Edge else Level) value using the RTC_TamperConfig() function
 142:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Configure the Tamper sampling frequency using RTC_TamperSamplingFreqConfig()
 143:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             function.
 144:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Configure the Tamper precharge or discharge duration using 
 145:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             RTC_TamperPinsPrechargeDuration() function.
 146:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Enable the Tamper Pull-UP using RTC_TamperPullUpDisableCmd() function.
 147:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Enable the RTC Tamper using the RTC_TamperCmd() function.
 148:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) Enable the Time stamp on Tamper detection event using  
 149:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             RTC_TSOnTamperDetecCmd() function.     
 150:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 151:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ***Backup Data Registers configuration ***
 152:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ==========================================
 153:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..]  
 154:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) To write to the RTC Backup Data registers, use the RTC_WriteBackupRegister()
 155:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             function.  
 156:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         (+) To read the RTC Backup Data registers, use the RTC_ReadBackupRegister()
 157:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             function.  
 158:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 159:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                        ##### RTC and low power modes #####
 160:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
 161:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] The MCU can be woken up from a low power mode by an RTC alternate 
 162:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          function.
 163:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] The RTC alternate functions are the RTC alarm (Alarm A), RTC tamper 
 164:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          event detection and RTC time stamp event detection.
 165:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          These RTC alternate functions can wake up the system from the Stop 
 166:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          and Standby lowpower modes.
 167:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          The system can also wake up from low power modes without depending 
 168:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          on an external interrupt (Auto-wakeup mode), by using the RTC alarm events.
 169:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] The RTC provides a programmable time base for waking up from the 
 170:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          Stop or Standby mode at regular intervals.
 171:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          Wakeup from STOP and Standby modes is possible only when the RTC 
 172:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          clock source is LSE or LSI.
 173:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 174:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                ##### Selection of RTC_AF1 alternate functions #####
 175:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
 176:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] The RTC_AF1 pin (PC13) can be used for the following purposes:
 177:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (+) AFO_ALARM output
 178:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (+) AFO_CALIB output
 179:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (+) AFI_TAMPER
 180:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (+) AFI_TIMESTAMP
 181:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 182:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    +------------------------------------------------------------------------------------------+
 183:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |     Pin         |AFO_ALARM |AFO_CALIB |AFI_TAMPER |AFI_TIMESTAMP | WKUP2  |ALARMOUTTYPE  |
 184:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |  configuration  | ENABLED  | ENABLED  |  ENABLED  |   ENABLED    |ENABLED |  AFO_ALARM   |
 185:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |  and function   |          |          |           |              |        |Configuration |
 186:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |-----------------|----------|----------|-----------|--------------|--------|--------------|
 187:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |   Alarm out     |          |          |           |              | Don't  |              |
 188:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |   output OD     |     1    |    0     |Don't care | Don't care   | care   |      0       |
 189:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |-----------------|----------|----------|-----------|--------------|--------|--------------|
 190:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |   Alarm out     |          |          |           |              | Don't  |              |
 191:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |   output PP     |     1    |    0     |Don't care | Don't care   | care   |      1       |
 192:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |-----------------|----------|----------|-----------|--------------|--------|--------------|
 193:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    | Calibration out |          |          |           |              | Don't  |              |
 194:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |   output PP     |     0    |    1     |Don't care | Don't care   | care   |  Don't care  |
 195:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |-----------------|----------|----------|-----------|--------------|--------|--------------|
 196:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |  TAMPER input   |          |          |           |              | Don't  |              |
 197:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |   floating      |     0    |    0     |     1     |      0       | care   |  Don't care  |
 198:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |-----------------|----------|----------|-----------|--------------|--------|--------------|
 199:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |  TIMESTAMP and  |          |          |           |              | Don't  |              |
 200:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |  TAMPER input   |     0    |    0     |     1     |      1       | care   |  Don't care  |
 201:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |   floating      |          |          |           |              |        |              |
 202:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |-----------------|----------|----------|-----------|--------------|--------|--------------|
 203:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    | TIMESTAMP input |          |          |           |              | Don't  |              |
 204:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |    floating     |     0    |    0     |     0     |      1       | care   |  Don't care  |
 205:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |-----------------|----------|----------|-----------|--------------|--------|--------------|
 206:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |  Wakeup Pin 2   |     0    |    0     |     0     |      0       |   1    |  Don't care  |
 207:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |-----------------|----------|----------|-----------|--------------|--------|--------------|
 208:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    |  Standard GPIO  |     0    |    0     |     0     |      0       |   0    |  Don't care  |
 209:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    +------------------------------------------------------------------------------------------+
 210:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 211:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  @endverbatim
 212:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  
 213:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ******************************************************************************
 214:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @attention
 215:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *
 216:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
 217:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *
 218:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
 219:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * You may not use this file except in compliance with the License.
 220:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * You may obtain a copy of the License at:
 221:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *
 222:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
 223:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *
 224:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * Unless required by applicable law or agreed to in writing, software 
 225:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
 226:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 227:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * See the License for the specific language governing permissions and
 228:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * limitations under the License.
 229:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *
 230:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ******************************************************************************
 231:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 232:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 233:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /* Includes ------------------------------------------------------------------*/
 234:.\StdPeriphLib\src/stm32f0xx_rtc.c **** #include "stm32f0xx_rtc.h"
 235:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 236:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @addtogroup STM32F0xx_StdPeriph_Driver
 237:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
 238:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 239:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 240:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC 
 241:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief RTC driver modules
 242:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
 243:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 244:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 245:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /* Private typedef -----------------------------------------------------------*/
 246:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /* Private define ------------------------------------------------------------*/
 247:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 248:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /* Masks Definition */
 249:.\StdPeriphLib\src/stm32f0xx_rtc.c **** #define RTC_TR_RESERVED_MASK    ((uint32_t)0x007F7F7F)
 250:.\StdPeriphLib\src/stm32f0xx_rtc.c **** #define RTC_DR_RESERVED_MASK    ((uint32_t)0x00FFFF3F) 
 251:.\StdPeriphLib\src/stm32f0xx_rtc.c **** #define RTC_INIT_MASK           ((uint32_t)0xFFFFFFFF)  
 252:.\StdPeriphLib\src/stm32f0xx_rtc.c **** #define RTC_RSF_MASK            ((uint32_t)0xFFFFFF5F)
 253:.\StdPeriphLib\src/stm32f0xx_rtc.c **** #define RTC_FLAGS_MASK          ((uint32_t)(RTC_FLAG_TSOVF | RTC_FLAG_TSF | RTC_FLAG_ALRAF | \
 254:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                             RTC_FLAG_RSF | RTC_FLAG_INITS |RTC_FLAG_INITF | \
 255:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                             RTC_FLAG_TAMP1F | RTC_FLAG_TAMP2F | RTC_FLAG_RECALPF | 
 256:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                             RTC_FLAG_SHPF))
 257:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 258:.\StdPeriphLib\src/stm32f0xx_rtc.c **** #define INITMODE_TIMEOUT         ((uint32_t) 0x00004000)
 259:.\StdPeriphLib\src/stm32f0xx_rtc.c **** #define SYNCHRO_TIMEOUT          ((uint32_t) 0x00008000)
 260:.\StdPeriphLib\src/stm32f0xx_rtc.c **** #define RECALPF_TIMEOUT          ((uint32_t) 0x00001000)
 261:.\StdPeriphLib\src/stm32f0xx_rtc.c **** #define SHPF_TIMEOUT             ((uint32_t) 0x00001000)
 262:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 263:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /* Private macro -------------------------------------------------------------*/
 264:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /* Private variables ---------------------------------------------------------*/
 265:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /* Private function prototypes -----------------------------------------------*/
 266:.\StdPeriphLib\src/stm32f0xx_rtc.c **** static uint8_t RTC_ByteToBcd2(uint8_t Value);
 267:.\StdPeriphLib\src/stm32f0xx_rtc.c **** static uint8_t RTC_Bcd2ToByte(uint8_t Value);
 268:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 269:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /* Private functions ---------------------------------------------------------*/
 270:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 271:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC_Private_Functions
 272:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
 273:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */ 
 274:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 275:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC_Group1 Initialization and Configuration functions
 276:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *  @brief   Initialization and Configuration functions 
 277:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *
 278:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @verbatim   
 279:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
 280:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             ##### Initialization and Configuration functions #####
 281:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================  
 282:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 283:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] This section provide functions allowing to initialize and configure the RTC
 284:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          Prescaler (Synchronous and Asynchronous), RTC Hour format, disable RTC registers
 285:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          Write protection, enter and exit the RTC initialization mode, RTC registers
 286:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          synchronization check and reference clock detection enable.
 287:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 288:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (#) The RTC Prescaler is programmed to generate the RTC 1Hz time base.
 289:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              It is split into 2 programmable prescalers to minimize power consumption.
 290:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              (++) A 7-bit asynchronous prescaler and A 13-bit synchronous prescaler.
 291:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              (++) When both prescalers are used, it is recommended to configure the
 292:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                   asynchronous prescaler to a high value to minimize consumption.
 293:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (#) All RTC registers are Write protected. Writing to the RTC registers
 294:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              is enabled by writing a key into the Write Protection register, RTC_WPR.
 295:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (#) To Configure the RTC Calendar, user application should enter
 296:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              initialization mode. In this mode, the calendar counter is stopped
 297:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              and its value can be updated. When the initialization sequence is
 298:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              complete, the calendar restarts counting after 4 RTCCLK cycles.
 299:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (#) To read the calendar through the shadow registers after Calendar
 300:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              initialization, calendar update or after wakeup from low power modes
 301:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              the software must first clear the RSF flag. The software must then
 302:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              wait until it is set again before reading the calendar, which means
 303:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              that the calendar registers have been correctly copied into the
 304:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              RTC_TR and RTC_DR shadow registers.The RTC_WaitForSynchro() function
 305:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              implements the above software sequence (RSF clear and RSF check).
 306:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 307:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @endverbatim
 308:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
 309:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 310:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 311:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 312:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Deinitializes the RTC registers to their default reset values.
 313:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   This function doesn't reset the RTC Clock source and RTC Backup Data
 314:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         registers.       
 315:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  None
 316:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval An ErrorStatus enumeration value:
 317:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - SUCCESS: RTC registers are deinitialized
 318:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - ERROR: RTC registers are not deinitialized
 319:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 320:.\StdPeriphLib\src/stm32f0xx_rtc.c **** ErrorStatus RTC_DeInit(void)
 321:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 322:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
 323:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 324:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
 325:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
 326:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 327:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 328:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Set Initialization mode */
 329:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
 330:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 331:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = ERROR;
 332:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }  
 333:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
 334:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 335:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Reset TR, DR and CR registers */
 336:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->TR        = (uint32_t)0x00000000;
 337:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->WUTR      = (uint32_t)0x0000FFFF;
 338:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->DR        = (uint32_t)0x00002101;
 339:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CR        &= (uint32_t)0x00000000;
 340:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->PRER      = (uint32_t)0x007F00FF;
 341:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->ALRMAR    = (uint32_t)0x00000000;
 342:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->SHIFTR    = (uint32_t)0x00000000;
 343:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CALR       = (uint32_t)0x00000000;
 344:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->ALRMASSR  = (uint32_t)0x00000000;
 345:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 346:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Reset ISR register and exit initialization mode */
 347:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->ISR = (uint32_t)0x00000000;
 348:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 349:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Reset Tamper and alternate functions configuration register */
 350:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->TAFCR = 0x00000000;
 351:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       
 352:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Wait till the RTC RSF flag is set */
 353:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if (RTC_WaitForSynchro() == ERROR)
 354:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 355:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       status = ERROR;
 356:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 357:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
 358:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 359:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       status = SUCCESS;
 360:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 361:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 362:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 363:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 364:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
 365:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;  
 366:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 367:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return status;
 368:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 369:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 370:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 371:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Initializes the RTC registers according to the specified parameters 
 372:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         in RTC_InitStruct.
 373:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure that contains 
 374:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         the configuration information for the RTC peripheral.
 375:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   The RTC Prescaler register is write protected and can be written in 
 376:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         initialization mode only.  
 377:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval An ErrorStatus enumeration value:
 378:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - SUCCESS: RTC registers are initialized
 379:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - ERROR: RTC registers are not initialized  
 380:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 381:.\StdPeriphLib\src/stm32f0xx_rtc.c **** ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
 382:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 383:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
 384:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 385:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 386:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
 387:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
 388:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
 389:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 390:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
 391:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
 392:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 393:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 394:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Set Initialization mode */
 395:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
 396:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 397:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = ERROR;
 398:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 399:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
 400:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 401:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Clear RTC CR FMT Bit */
 402:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
 403:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Set RTC_CR register */
 404:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
 405:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 406:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Configure the RTC PRER */
 407:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
 408:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
 409:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 410:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Exit Initialization mode */
 411:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_ExitInitMode();
 412:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 413:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = SUCCESS;
 414:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 415:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
 416:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
 417:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 418:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return status;
 419:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 420:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 421:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 422:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Fills each RTC_InitStruct member with its default value.
 423:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
 424:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         initialized.
 425:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
 426:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 427:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
 428:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 429:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Initialize the RTC_HourFormat member */
 430:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
 431:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 432:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Initialize the RTC_AsynchPrediv member */
 433:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
 434:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 435:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Initialize the RTC_SynchPrediv member */
 436:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
 437:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 438:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 439:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 440:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Enables or disables the RTC registers write protection.
 441:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   All the RTC registers are write protected except for RTC_ISR[13:8], 
 442:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         RTC_TAFCR and RTC_BKPxR.
 443:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   Writing a wrong key reactivates the write protection.
 444:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   The protection mechanism is not affected by system reset.
 445:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  NewState: new state of the write protection.
 446:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be: ENABLE or DISABLE.
 447:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
 448:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 449:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_WriteProtectionCmd(FunctionalState NewState)
 450:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 451:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 452:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 453:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 454:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (NewState != DISABLE)
 455:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 456:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Enable the write protection for RTC registers */
 457:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->WPR = 0xFF;
 458:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 459:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
 460:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 461:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Disable the write protection for RTC registers */
 462:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->WPR = 0xCA;
 463:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->WPR = 0x53;
 464:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 465:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 466:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 467:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 468:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Enters the RTC Initialization mode.
 469:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   The RTC Initialization mode is write protected, use the 
 470:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         RTC_WriteProtectionCmd(DISABLE) before calling this function.
 471:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  None
 472:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval An ErrorStatus enumeration value:
 473:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - SUCCESS: RTC is in Init mode
 474:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - ERROR: RTC is not in Init mode
 475:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 476:.\StdPeriphLib\src/stm32f0xx_rtc.c **** ErrorStatus RTC_EnterInitMode(void)
 477:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 478:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   __IO uint32_t initcounter = 0x00;
 479:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
 480:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t initstatus = 0x00;
 481:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 482:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check if the Initialization mode is set */
 483:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 484:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 485:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Set the Initialization mode */
 486:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->ISR = (uint32_t)RTC_INIT_MASK;
 487:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 488:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Wait till RTC is in INIT state and if Time out is reached exit */
 489:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     do
 490:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 491:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       initstatus = RTC->ISR & RTC_ISR_INITF;
 492:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       initcounter++;  
 493:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 494:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 495:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if ((RTC->ISR & RTC_ISR_INITF) != RESET)
 496:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 497:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       status = SUCCESS;
 498:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 499:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
 500:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 501:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       status = ERROR;
 502:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 503:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 504:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
 505:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 506:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = SUCCESS;
 507:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 508:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 509:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return (status);
 510:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 511:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 512:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 513:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Exits the RTC Initialization mode.
 514:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   When the initialization sequence is complete, the calendar restarts 
 515:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         counting after 4 RTCCLK cycles.  
 516:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   The RTC Initialization mode is write protected, use the 
 517:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
 518:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  None
 519:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
 520:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 521:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_ExitInitMode(void)
 522:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 523:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Exit Initialization mode */
 524:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
 525:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 526:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 527:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 528:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Waits until the RTC Time and Date registers (RTC_TR and RTC_DR) are 
 529:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         synchronized with RTC APB clock.
 530:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   The RTC Resynchronization mode is write protected, use the 
 531:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         RTC_WriteProtectionCmd(DISABLE) before calling this function. 
 532:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   To read the calendar through the shadow registers after Calendar 
 533:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         initialization, calendar update or after wakeup from low power modes 
 534:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         the software must first clear the RSF flag. 
 535:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         The software must then wait until it is set again before reading 
 536:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         the calendar, which means that the calendar registers have been 
 537:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         correctly copied into the RTC_TR and RTC_DR shadow registers.   
 538:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  None
 539:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval An ErrorStatus enumeration value:
 540:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - SUCCESS: RTC registers are synchronised
 541:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - ERROR: RTC registers are not synchronised
 542:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 543:.\StdPeriphLib\src/stm32f0xx_rtc.c **** ErrorStatus RTC_WaitForSynchro(void)
 544:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 545:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   __IO uint32_t synchrocounter = 0;
 546:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
 547:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t synchrostatus = 0x00;
 548:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 549:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if ((RTC->CR & RTC_CR_BYPSHAD) != RESET)
 550:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 551:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Bypass shadow mode */
 552:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = SUCCESS;
 553:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 554:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
 555:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 556:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Disable the write protection for RTC registers */
 557:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->WPR = 0xCA;
 558:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->WPR = 0x53;
 559:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 560:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Clear RSF flag */
 561:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->ISR &= (uint32_t)RTC_RSF_MASK;
 562:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 563:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Wait the registers to be synchronised */
 564:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     do
 565:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 566:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       synchrostatus = RTC->ISR & RTC_ISR_RSF;
 567:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       synchrocounter++;  
 568:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 569:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 570:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if ((RTC->ISR & RTC_ISR_RSF) != RESET)
 571:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 572:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       status = SUCCESS;
 573:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 574:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
 575:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 576:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       status = ERROR;
 577:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 578:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 579:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Enable the write protection for RTC registers */
 580:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->WPR = 0xFF;
 581:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 582:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 583:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return (status);
 584:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 585:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 586:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 587:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Enables or disables the RTC reference clock detection.
 588:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  NewState: new state of the RTC reference clock.
 589:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be: ENABLE or DISABLE.
 590:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval An ErrorStatus enumeration value:
 591:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - SUCCESS: RTC reference clock detection is enabled
 592:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - ERROR: RTC reference clock detection is disabled  
 593:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 594:.\StdPeriphLib\src/stm32f0xx_rtc.c **** ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
 595:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 596:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
 597:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 598:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 599:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 600:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 601:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
 602:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
 603:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 604:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 605:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Set Initialization mode */
 606:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
 607:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 608:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = ERROR;
 609:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 610:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
 611:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 612:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if (NewState != DISABLE)
 613:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 614:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       /* Enable the RTC reference clock detection */
 615:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       RTC->CR |= RTC_CR_REFCKON;
 616:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 617:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
 618:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 619:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       /* Disable the RTC reference clock detection */
 620:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       RTC->CR &= ~RTC_CR_REFCKON;
 621:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 622:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Exit Initialization mode */
 623:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_ExitInitMode();
 624:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 625:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = SUCCESS;
 626:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 627:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 628:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
 629:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
 630:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 631:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return status;
 632:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 633:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 634:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 635:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Enables or Disables the Bypass Shadow feature.
 636:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   When the Bypass Shadow is enabled the calendar value are taken 
 637:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         directly from the Calendar counter.
 638:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  NewState: new state of the Bypass Shadow feature.
 639:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         This parameter can be: ENABLE or DISABLE.
 640:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
 641:.\StdPeriphLib\src/stm32f0xx_rtc.c **** */
 642:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_BypassShadowCmd(FunctionalState NewState)
 643:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 644:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 645:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 646:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 647:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
 648:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
 649:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 650:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 651:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (NewState != DISABLE)
 652:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 653:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Set the BYPSHAD bit */
 654:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
 655:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 656:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
 657:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 658:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Reset the BYPSHAD bit */
 659:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
 660:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 661:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 662:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
 663:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
 664:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 665:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 666:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 667:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @}
 668:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 669:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 670:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC_Group2 Time and Date configuration functions
 671:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *  @brief   Time and Date configuration functions
 672:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *
 673:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @verbatim
 674:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
 675:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                ##### Time and Date configuration functions #####
 676:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
 677:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..]  This section provide functions allowing to program and read the RTC
 678:.\StdPeriphLib\src/stm32f0xx_rtc.c ****           Calendar (Time and Date).
 679:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 680:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @endverbatim
 681:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
 682:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 683:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 684:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 685:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Set the RTC current time.
 686:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Format: specifies the format of the entered parameters.
 687:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be  one of the following values:
 688:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Format_BIN:  Binary data format 
 689:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Format_BCD:  BCD data format
 690:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that contains 
 691:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                        the time configuration information for the RTC.
 692:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval An ErrorStatus enumeration value:
 693:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - SUCCESS: RTC Time register is configured
 694:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - ERROR: RTC Time register is not configured
 695:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 696:.\StdPeriphLib\src/stm32f0xx_rtc.c **** ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
 697:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 698:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 699:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
 700:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 701:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 702:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
 703:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 704:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 705:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 706:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 707:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 708:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
 709:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
 710:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 711:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
 712:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 713:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       RTC_TimeStruct->RTC_H12 = 0x00;
 714:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
 715:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 716:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
 717:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
 718:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 719:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
 720:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 721:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 722:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 723:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 724:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_HOUR12(tmpreg));
 725:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
 726:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     } 
 727:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
 728:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 729:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       RTC_TimeStruct->RTC_H12 = 0x00;
 730:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
 731:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 732:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
 733:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
 734:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 735:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 736:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the input parameters format */
 737:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_Format != RTC_Format_BIN)
 738:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 739:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 740:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 741:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
 742:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
 743:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 744:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
 745:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 746:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 747:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                    ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 748:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                    ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
 749:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                    (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
 750:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   } 
 751:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 752:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
 753:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
 754:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 755:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 756:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Set Initialization mode */
 757:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
 758:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 759:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = ERROR;
 760:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   } 
 761:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
 762:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 763:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Set the RTC_TR register */
 764:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 765:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 766:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Exit Initialization mode */
 767:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_ExitInitMode(); 
 768:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 769:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
 770:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 771:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 772:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       if (RTC_WaitForSynchro() == ERROR)
 773:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       {
 774:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         status = ERROR;
 775:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       }
 776:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       else
 777:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       {
 778:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         status = SUCCESS;
 779:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       }
 780:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 781:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
 782:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 783:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       status = SUCCESS;
 784:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 785:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 786:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 787:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
 788:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
 789:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 790:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return status;
 791:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 792:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 793:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 794:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Fills each RTC_TimeStruct member with its default value
 795:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         (Time = 00h:00min:00sec).
 796:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
 797:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         initialized.
 798:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
 799:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 800:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
 801:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 802:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Time = 00h:00min:00sec */
 803:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
 804:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_TimeStruct->RTC_Hours = 0;
 805:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_TimeStruct->RTC_Minutes = 0;
 806:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_TimeStruct->RTC_Seconds = 0; 
 807:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 808:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 809:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 810:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Get the RTC current Time.
 811:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Format: specifies the format of the returned parameters.
 812:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be  one of the following values:
 813:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Format_BIN:  Binary data format 
 814:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Format_BCD:  BCD data format
 815:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
 816:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                        contain the returned current time configuration.
 817:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
 818:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 819:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
 820:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 821:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 822:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 823:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 824:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
 825:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 826:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get the RTC_TR register */
 827:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
 828:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 829:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Fill the structure fields with the read parameters */
 830:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 831:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 832:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 833:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 834:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 835:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the input parameters format */
 836:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 837:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 838:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Convert the structure parameters to Binary format */
 839:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 840:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
 841:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);
 842:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 843:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 844:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 845:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 846:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Gets the RTC current Calendar Subseconds value.
 847:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   This function freeze the Time and Date registers after reading the 
 848:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         SSR register.
 849:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  None
 850:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval RTC current Calendar Subseconds value.
 851:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 852:.\StdPeriphLib\src/stm32f0xx_rtc.c **** uint32_t RTC_GetSubSecond(void)
 853:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 854:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 855:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 856:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get subseconds values from the correspondent registers*/
 857:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmpreg = (uint32_t)(RTC->SSR);
 858:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 859:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Read DR register to unfroze calendar registers */
 860:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   (void) (RTC->DR);
 861:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 862:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return (tmpreg);
 863:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 864:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 865:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 866:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Set the RTC current date.
 867:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Format: specifies the format of the entered parameters.
 868:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be  one of the following values:
 869:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Format_BIN:  Binary data format 
 870:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Format_BCD:  BCD data format
 871:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure that contains 
 872:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                         the date configuration information for the RTC.
 873:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval An ErrorStatus enumeration value:
 874:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - SUCCESS: RTC Date register is configured
 875:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - ERROR: RTC Date register is not configured
 876:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 877:.\StdPeriphLib\src/stm32f0xx_rtc.c **** ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
 878:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 879:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 880:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
 881:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 882:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 883:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
 884:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 885:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
 886:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 887:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
 888:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }  
 889:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 890:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 891:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
 892:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
 893:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
 894:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 895:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
 896:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 897:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
 898:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 899:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     assert_param(IS_RTC_MONTH(tmpreg));
 900:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 901:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     assert_param(IS_RTC_DATE(tmpreg));
 902:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 903:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
 904:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 905:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the input parameters format */
 906:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_Format != RTC_Format_BIN)
 907:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 908:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 909:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 910:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_DateStruct->RTC_Date) | \
 911:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
 912:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }  
 913:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
 914:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 915:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 916:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 917:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
 918:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
 919:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 920:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 921:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
 922:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
 923:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 924:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 925:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Set Initialization mode */
 926:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
 927:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 928:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = ERROR;
 929:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   } 
 930:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
 931:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 932:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Set the RTC_DR register */
 933:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
 934:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 935:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Exit Initialization mode */
 936:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_ExitInitMode(); 
 937:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 938:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
 939:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 940:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 941:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       if (RTC_WaitForSynchro() == ERROR)
 942:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       {
 943:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         status = ERROR;
 944:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       }
 945:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       else
 946:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       {
 947:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         status = SUCCESS;
 948:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       }
 949:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 950:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
 951:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 952:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       status = SUCCESS;
 953:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 954:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 955:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
 956:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
 957:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 958:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return status;
 959:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 960:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 961:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 962:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Fills each RTC_DateStruct member with its default value
 963:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         (Monday, January 01 xx00).
 964:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
 965:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         initialized.
 966:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
 967:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 968:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
 969:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 970:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Monday, January 01 xx00 */
 971:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
 972:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_DateStruct->RTC_Date = 1;
 973:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_DateStruct->RTC_Month = RTC_Month_January;
 974:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_DateStruct->RTC_Year = 0;
 975:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 976:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 977:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
 978:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Get the RTC current date.
 979:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Format: specifies the format of the returned parameters.
 980:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
 981:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Format_BIN: Binary data format 
 982:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Format_BCD: BCD data format
 983:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
 984:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                        contain the returned current date configuration.
 985:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
 986:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
 987:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
 988:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
 989:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 990:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 991:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 992:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
 993:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 994:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get the RTC_TR register */
 995:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
 996:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 997:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Fill the structure fields with the read parameters */
 998:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 999:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
1000:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
1001:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
1002:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1003:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the input parameters format */
1004:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
1005:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1006:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Convert the structure parameters to Binary format */
1007:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
1008:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
1009:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
1010:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_DateStruct->RTC_WeekDay = (uint8_t)(RTC_DateStruct->RTC_WeekDay);   
1011:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1012:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1013:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1014:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1015:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @}
1016:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1017:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1018:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC_Group3 Alarms configuration functions
1019:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *  @brief   Alarms (Alarm A) configuration functions 
1020:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *
1021:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @verbatim
1022:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
1023:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          ##### Alarms (Alarm A and Alarm B) configuration functions #####
1024:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
1025:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] This section provide functions allowing to program and read the RTC 
1026:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          Alarms.
1027:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1028:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @endverbatim
1029:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
1030:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1031:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1032:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1033:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Set the specified RTC Alarm.
1034:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   The Alarm register can only be written when the corresponding Alarm
1035:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         is disabled (Use the RTC_AlarmCmd(DISABLE)).    
1036:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Format: specifies the format of the returned parameters.
1037:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1038:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Format_BIN: Binary data format 
1039:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Format_BCD: BCD data format
1040:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be configured.
1041:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1042:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Alarm_A: to select Alarm A
1043:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
1044:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                          contains the alarm configuration parameters.
1045:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1046:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1047:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
1048:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1049:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
1050:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1051:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1052:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
1053:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_ALARM(RTC_Alarm));
1054:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
1055:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
1056:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1057:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
1058:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1059:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
1060:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1061:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
1062:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
1063:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     } 
1064:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
1065:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1066:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
1067:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
1068:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
1069:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
1070:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
1071:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
1072:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
1073:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1074:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
1075:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
1076:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
1077:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1078:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
1079:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
1080:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1081:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
1082:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1083:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
1084:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1085:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
1086:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_HOUR12(tmpreg));
1087:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
1088:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     } 
1089:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
1090:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1091:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
1092:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
1093:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
1094:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
1095:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
1096:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
1097:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
1098:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
1099:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1100:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
1101:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
1102:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
1103:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
1104:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1105:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
1106:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
1107:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }    
1108:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1109:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1110:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the input parameters format */
1111:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_Format != RTC_Format_BIN)
1112:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1113:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
1114:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
1115:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
1116:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
1117:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
1118:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
1119:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
1120:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }  
1121:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
1122:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1123:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
1124:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
1125:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
1126:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
1127:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
1128:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
1129:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
1130:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1131:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1132:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
1133:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
1134:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
1135:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1136:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Configure the Alarm register */
1137:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->ALRMAR = (uint32_t)tmpreg;
1138:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1139:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
1140:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
1141:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1142:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1143:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1144:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Fills each RTC_AlarmStruct member with its default value
1145:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         (Time = 00h:00mn:00sec / Date = 1st day of the month/Mask =
1146:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         all fields are masked).
1147:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
1148:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         will be initialized.
1149:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1150:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1151:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
1152:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1153:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Alarm Time Settings : Time = 00h:00mn:00sec */
1154:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
1155:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
1156:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
1157:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
1158:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1159:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Alarm Date Settings : Date = 1st day of the month */
1160:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
1161:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
1162:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1163:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Alarm Masks Settings : Mask =  all fields are not masked */
1164:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
1165:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1166:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1167:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1168:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Get the RTC Alarm value and masks.
1169:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Format: specifies the format of the output parameters.
1170:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1171:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Format_BIN: Binary data format 
1172:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Format_BCD: BCD data format
1173:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be read.
1174:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1175:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Alarm_A: to select Alarm A
1176:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
1177:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                          contains the output alarm configuration values.
1178:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1179:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1180:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
1181:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1182:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
1183:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1184:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1185:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
1186:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_ALARM(RTC_Alarm)); 
1187:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1188:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get the RTC_ALRMAR register */
1189:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmpreg = (uint32_t)(RTC->ALRMAR);
1190:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1191:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Fill the structure with the read parameters */
1192:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
1193:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                                      RTC_ALRMAR_HU)) >> 16);
1194:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
1195:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                                      RTC_ALRMAR_MNU)) >> 8);
1196:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
1197:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                                      RTC_ALRMAR_SU));
1198:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
1199:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 
1200:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
1201:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
1202:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1203:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
1204:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1205:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
1206:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                                         RTC_AlarmTime.RTC_Hours);
1207:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
1208:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                                         RTC_AlarmTime.RTC_Minutes);
1209:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
1210:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                                         RTC_AlarmTime.RTC_Seconds);
1211:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
1212:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }  
1213:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1214:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1215:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1216:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Enables or disables the specified RTC Alarm.
1217:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be configured.
1218:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be any combination of the following values:
1219:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Alarm_A: to select Alarm A
1220:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  NewState: new state of the specified alarm.
1221:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be: ENABLE or DISABLE.
1222:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval An ErrorStatus enumeration value:
1223:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - SUCCESS: RTC Alarm is enabled/disabled
1224:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - ERROR: RTC Alarm is not enabled/disabled  
1225:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1226:.\StdPeriphLib\src/stm32f0xx_rtc.c **** ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
1227:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1228:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   __IO uint32_t alarmcounter = 0x00;
1229:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t alarmstatus = 0x00;
1230:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
1231:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
1232:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1233:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
1234:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1235:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1236:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
1237:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
1238:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
1239:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1240:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Configure the Alarm state */
1241:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (NewState != DISABLE)
1242:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1243:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CR |= (uint32_t)RTC_Alarm;
1244:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1245:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = SUCCESS;    
1246:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1247:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
1248:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   { 
1249:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Disable the Alarm in RTC_CR register */
1250:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CR &= (uint32_t)~RTC_Alarm;
1251:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    
1252:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
1253:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     do
1254:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1255:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
1256:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       alarmcounter++;  
1257:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
1258:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
1259:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
1260:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1261:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       status = ERROR;
1262:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     } 
1263:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
1264:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1265:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       status = SUCCESS;
1266:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }        
1267:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   } 
1268:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1269:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
1270:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
1271:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1272:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return status;
1273:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1274:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1275:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1276:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Configure the RTC AlarmA/B Subseconds value and mask.
1277:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   This function is performed only when the Alarm is disabled. 
1278:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be configured.
1279:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1280:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Alarm_A: to select Alarm A
1281:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_AlarmSubSecondValue: specifies the Subseconds value.
1282:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be a value from 0 to 0x00007FFF.
1283:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_AlarmSubSecondMask:  specifies the Subseconds Mask.
1284:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be any combination of the following values:
1285:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_All: All Alarm SS fields are masked.
1286:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                             There is no comparison on sub seconds for Alarm.
1287:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_SS14_1: SS[14:1] are don't care in Alarm comparison.
1288:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                Only SS[0] is compared
1289:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_SS14_2: SS[14:2] are don't care in Alarm comparison.
1290:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                Only SS[1:0] are compared
1291:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_SS14_3: SS[14:3] are don't care in Alarm comparison.
1292:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                Only SS[2:0] are compared
1293:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_SS14_4: SS[14:4] are don't care in Alarm comparison.
1294:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                Only SS[3:0] are compared
1295:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_SS14_5: SS[14:5] are don't care in Alarm comparison.
1296:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                Only SS[4:0] are compared
1297:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_SS14_6: SS[14:6] are don't care in Alarm comparison.
1298:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                Only SS[5:0] are compared
1299:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_SS14_7: SS[14:7] are don't care in Alarm comparison.
1300:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                Only SS[6:0] are compared
1301:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_SS14_8: SS[14:8] are don't care in Alarm comparison.
1302:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                Only SS[7:0] are compared
1303:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_SS14_9: SS[14:9] are don't care in Alarm comparison.
1304:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                Only SS[8:0] are compared
1305:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_SS14_10: SS[14:10] are don't care in Alarm comparison.
1306:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                 Only SS[9:0] are compared
1307:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_SS14_11: SS[14:11] are don't care in Alarm comparison.
1308:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                 Only SS[10:0] are compared
1309:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_SS14_12: SS[14:12] are don't care in Alarm comparison.
1310:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                 Only SS[11:0] are compared
1311:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_SS14_13: SS[14:13] are don't care in Alarm comparison.
1312:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                 Only SS[12:0] are compared
1313:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_SS14: SS[14] is don't care in Alarm comparison.
1314:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                              Only SS[13:0] are compared
1315:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_AlarmSubSecondMask_None: SS[14:0] are compared and must match to activate a
1316:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1317:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1318:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint8_t RTC_Ala
1319:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1320:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
1321:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1322:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1323:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_ALARM(RTC_Alarm));
1324:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
1325:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
1326:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1327:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
1328:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
1329:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
1330:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1331:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Configure the Alarm A or Alarm B SubSecond registers */
1332:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmpreg = (uint32_t) (((uint32_t)(RTC_AlarmSubSecondValue)) | ((uint32_t)(RTC_AlarmSubSecondMask) 
1333:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1334:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Configure the AlarmA SubSecond register */
1335:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->ALRMASSR = tmpreg;
1336:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1337:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
1338:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
1339:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1340:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1341:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1342:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1343:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Gets the RTC Alarm Subseconds value.
1344:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be read.
1345:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1346:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Alarm_A: to select Alarm A
1347:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  None
1348:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval RTC Alarm Subseconds value.
1349:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1350:.\StdPeriphLib\src/stm32f0xx_rtc.c **** uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
1351:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1352:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
1353:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1354:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get the RTC_ALRMAR register */
1355:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
1356:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1357:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return (tmpreg);
1358:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1359:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1360:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1361:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @}
1362:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1363:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1364:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC_Group4 WakeUp Timer configuration functions
1365:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *  @brief   WakeUp Timer configuration functions 
1366:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *
1367:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @verbatim   
1368:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
1369:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             ##### WakeUp Timer configuration functions #####
1370:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================  
1371:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1372:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] This section provide functions allowing to program and read the RTC WakeUp.
1373:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1374:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @endverbatim
1375:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
1376:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1377:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1378:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1379:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Configures the RTC Wakeup clock source.
1380:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         This function is available for STM32F072 devices.  
1381:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   The WakeUp Clock source can only be changed when the RTC WakeUp
1382:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).
1383:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_WakeUpClock: Wakeup Clock source.
1384:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1385:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_WakeUpClock_RTCCLK_Div16
1386:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_WakeUpClock_RTCCLK_Div8
1387:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_WakeUpClock_RTCCLK_Div4
1388:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_WakeUpClock_RTCCLK_Div2
1389:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_WakeUpClock_CK_SPRE_16bits
1390:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_WakeUpClock_CK_SPRE_17bits
1391:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1392:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1393:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
1394:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1395:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1396:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
1397:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1398:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
1399:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
1400:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
1401:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1402:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Clear the Wakeup Timer clock source bits in CR register */
1403:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
1404:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1405:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Configure the clock source */
1406:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->CR |= (uint32_t)RTC_WakeUpClock;
1407:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1408:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
1409:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
1410:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1411:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1412:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1413:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Configures the RTC Wakeup counter.
1414:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         This function is available for STM32F072 devices.  
1415:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   The RTC WakeUp counter can only be written when the RTC WakeUp
1416:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).
1417:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
1418:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be a value from 0x0000 to 0xFFFF. 
1419:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1420:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1421:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
1422:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1423:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1424:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
1425:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1426:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
1427:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
1428:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
1429:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1430:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Configure the Wakeup Timer counter */
1431:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
1432:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1433:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
1434:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
1435:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1436:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1437:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1438:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Returns the RTC WakeUp timer counter value.
1439:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         This function is available for STM32F072 devices.  
1440:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  None
1441:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval The RTC WakeUp Counter value.
1442:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1443:.\StdPeriphLib\src/stm32f0xx_rtc.c **** uint32_t RTC_GetWakeUpCounter(void)
1444:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1445:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get the counter value */
1446:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
1447:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1448:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1449:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1450:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Enables or Disables the RTC WakeUp timer.
1451:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         This function is available for STM32F072 devices.  
1452:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  NewState: new state of the WakeUp timer.
1453:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be: ENABLE or DISABLE.
1454:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1455:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1456:.\StdPeriphLib\src/stm32f0xx_rtc.c **** ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
1457:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1458:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   __IO uint32_t wutcounter = 0x00;
1459:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t wutwfstatus = 0x00;
1460:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
1461:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1462:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1463:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1464:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1465:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
1466:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
1467:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
1468:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1469:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (NewState != DISABLE)
1470:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1471:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Enable the Wakeup Timer */
1472:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CR |= (uint32_t)RTC_CR_WUTE;
1473:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = SUCCESS;    
1474:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1475:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
1476:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1477:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Disable the Wakeup Timer */
1478:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CR &= (uint32_t)~RTC_CR_WUTE;
1479:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
1480:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     do
1481:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1482:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
1483:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       wutcounter++;  
1484:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
1485:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
1486:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
1487:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1488:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       status = ERROR;
1489:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
1490:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
1491:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1492:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       status = SUCCESS;
1493:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }    
1494:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1495:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1496:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
1497:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
1498:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1499:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return status;
1500:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1501:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1502:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1503:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @}
1504:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1505:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1506:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC_Group5 Daylight Saving configuration functions
1507:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *  @brief   Daylight Saving configuration functions 
1508:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *
1509:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @verbatim   
1510:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
1511:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                ##### WakeUp Timer configuration functions #####
1512:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
1513:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] This section provide functions allowing to program and read the RTC WakeUp. 
1514:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1515:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   This section provide functions allowing to configure the RTC DayLight Saving.
1516:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1517:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @endverbatim
1518:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
1519:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1520:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1521:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1522:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Adds or substract one hour from the current time.
1523:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_DayLightSaveOperation: the value of hour adjustment. 
1524:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1525:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_DayLightSaving_SUB1H: Substract one hour (winter time)
1526:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_DayLightSaving_ADD1H: Add one hour (summer time)
1527:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_StoreOperation: Specifies the value to be written in the BCK bit 
1528:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                             in CR register to store the operation.
1529:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1530:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_StoreOperation_Reset: BCK Bit Reset
1531:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_StoreOperation_Set: BCK Bit Set
1532:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1533:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1534:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
1535:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1536:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1537:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
1538:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
1539:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1540:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
1541:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
1542:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
1543:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1544:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Clear the bits to be configured */
1545:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->CR &= (uint32_t)~(RTC_CR_BCK);
1546:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1547:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Configure the RTC_CR register */
1548:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
1549:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1550:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
1551:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
1552:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1553:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1554:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1555:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Returns the RTC Day Light Saving stored operation.
1556:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  None
1557:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval RTC Day Light Saving stored operation.
1558:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - RTC_StoreOperation_Reset
1559:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - RTC_StoreOperation_Set
1560:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1561:.\StdPeriphLib\src/stm32f0xx_rtc.c **** uint32_t RTC_GetStoreOperation(void)
1562:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1563:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return (RTC->CR & RTC_CR_BCK);
1564:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1565:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1566:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1567:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @}
1568:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1569:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1570:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC_Group6 Output pin Configuration function
1571:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *  @brief   Output pin Configuration function 
1572:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *
1573:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @verbatim   
1574:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
1575:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                   ##### Output pin Configuration function #####
1576:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
1577:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] This section provide functions allowing to configure the RTC Output source.
1578:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1579:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @endverbatim
1580:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
1581:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1582:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1583:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1584:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Configures the RTC output source (AFO_ALARM).
1585:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Output: Specifies which signal will be routed to the RTC output. 
1586:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1587:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Output_Disable: No output selected
1588:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Output_AlarmA: signal of AlarmA mapped to output
1589:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Output_WakeUp: signal of WakeUp mapped to output, available only for STM32F
1590:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_OutputPolarity: Specifies the polarity of the output signal. 
1591:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following:
1592:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_OutputPolarity_High: The output pin is high when the 
1593:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                          ALRAF is high (depending on OSEL)
1594:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_OutputPolarity_Low: The output pin is low when the 
1595:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                         ALRAF is high (depending on OSEL)
1596:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1597:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1598:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
1599:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1600:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1601:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_OUTPUT(RTC_Output));
1602:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
1603:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1604:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
1605:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
1606:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
1607:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1608:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Clear the bits to be configured */
1609:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
1610:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1611:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Configure the output selection and polarity */
1612:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
1613:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1614:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
1615:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
1616:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1617:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1618:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1619:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @}
1620:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1621:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1622:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC_Group7 Digital Calibration configuration functions
1623:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *  @brief   Digital Calibration configuration functions 
1624:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *
1625:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @verbatim   
1626:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
1627:.\StdPeriphLib\src/stm32f0xx_rtc.c ****           ##### Digital Calibration configuration functions #####
1628:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
1629:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1630:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @endverbatim
1631:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
1632:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1633:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1634:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1635:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Enables or disables the RTC clock to be output through the relative pin.
1636:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  NewState: new state of the digital calibration Output.
1637:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be: ENABLE or DISABLE.
1638:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1639:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1640:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_CalibOutputCmd(FunctionalState NewState)
1641:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1642:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1643:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1644:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1645:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
1646:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
1647:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
1648:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1649:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (NewState != DISABLE)
1650:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1651:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Enable the RTC clock output */
1652:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CR |= (uint32_t)RTC_CR_COE;
1653:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1654:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
1655:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   { 
1656:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Disable the RTC clock output */
1657:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CR &= (uint32_t)~RTC_CR_COE;
1658:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1659:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1660:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
1661:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF; 
1662:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1663:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1664:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1665:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Configure the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
1666:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_CalibOutput: Select the Calibration output Selection .
1667:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1668:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_CalibOutput_512Hz: A signal has a regular waveform at 512Hz. 
1669:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_CalibOutput_1Hz: A signal has a regular waveform at 1Hz.
1670:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1671:.\StdPeriphLib\src/stm32f0xx_rtc.c **** */
1672:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
1673:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1674:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1675:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
1676:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1677:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
1678:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
1679:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
1680:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1681:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /*clear flags before config*/
1682:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->CR &= (uint32_t)~(RTC_CR_CALSEL);
1683:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1684:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Configure the RTC_CR register */
1685:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->CR |= (uint32_t)RTC_CalibOutput;
1686:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1687:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
1688:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
1689:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1690:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1691:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1692:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Configures the Smooth Calibration Settings.
1693:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_SmoothCalibPeriod: Select the Smooth Calibration Period.
1694:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be can be one of the following values:
1695:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_SmoothCalibPeriod_32sec: The smooth calibration periode is 32s.
1696:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_SmoothCalibPeriod_16sec: The smooth calibration periode is 16s.
1697:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_SmoothCalibPeriod_8sec: The smooth calibartion periode is 8s.
1698:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_SmoothCalibPlusPulses: Select to Set or reset the CALP bit.
1699:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1700:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_SmoothCalibPlusPulses_Set: Add one RTCCLK puls every 2**11 pulses.
1701:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_SmoothCalibPlusPulses_Reset: No RTCCLK pulses are added.
1702:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_SmouthCalibMinusPulsesValue: Select the value of CALM[8:0] bits.
1703:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one any value from 0 to 0x000001FF.
1704:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval An ErrorStatus enumeration value:
1705:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - SUCCESS: RTC Calib registers are configured
1706:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - ERROR: RTC Calib registers are not configured
1707:.\StdPeriphLib\src/stm32f0xx_rtc.c **** */
1708:.\StdPeriphLib\src/stm32f0xx_rtc.c **** ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
1709:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                   uint32_t RTC_SmoothCalibPlusPulses,
1710:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                   uint32_t RTC_SmouthCalibMinusPulsesValue)
1711:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1712:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
1713:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t recalpfcount = 0;
1714:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1715:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1716:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
1717:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
1718:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
1719:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1720:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
1721:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
1722:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
1723:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1724:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* check if a calibration is pending*/
1725:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
1726:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1727:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* wait until the Calibration is completed*/
1728:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
1729:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
1730:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       recalpfcount++;
1731:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
1732:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1733:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1734:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* check if the calibration pending is completed or if there is no calibration operation at all*/
1735:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
1736:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1737:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Configure the Smooth calibration settings */
1738:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | 
1739:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1740:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = SUCCESS;
1741:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1742:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
1743:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1744:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = ERROR;
1745:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1746:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1747:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
1748:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
1749:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1750:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return (ErrorStatus)(status);
1751:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1752:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1753:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1754:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @}
1755:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1756:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1757:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1758:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC_Group8 TimeStamp configuration functions
1759:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *  @brief   TimeStamp configuration functions 
1760:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *
1761:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @verbatim   
1762:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
1763:.\StdPeriphLib\src/stm32f0xx_rtc.c ****           ##### TimeStamp configuration functions #####
1764:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================  
1765:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1766:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @endverbatim
1767:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
1768:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1769:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1770:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1771:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Enables or Disables the RTC TimeStamp functionality with the 
1772:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         specified time stamp pin stimulating edge.
1773:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_TimeStampEdge: Specifies the pin edge on which the TimeStamp is 
1774:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         activated.
1775:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following:
1776:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TimeStampEdge_Rising: the Time stamp event occurs on the rising 
1777:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                           edge of the related pin.
1778:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TimeStampEdge_Falling: the Time stamp event occurs on the 
1779:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                            falling edge of the related pin.
1780:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  NewState: new state of the TimeStamp.
1781:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be: ENABLE or DISABLE.
1782:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1783:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1784:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
1785:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1786:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
1787:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1788:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1789:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
1790:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1791:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1792:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get the RTC_CR register and clear the bits to be configured */
1793:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
1794:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1795:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get the new configuration */
1796:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (NewState != DISABLE)
1797:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1798:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
1799:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1800:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
1801:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1802:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     tmpreg |= (uint32_t)(RTC_TimeStampEdge);
1803:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1804:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1805:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
1806:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
1807:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
1808:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1809:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Configure the Time Stamp TSEDGE and Enable bits */
1810:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->CR = (uint32_t)tmpreg;
1811:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1812:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
1813:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
1814:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1815:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1816:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1817:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Get the RTC TimeStamp value and masks.
1818:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Format: specifies the format of the output parameters.
1819:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1820:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Format_BIN: Binary data format 
1821:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Format_BCD: BCD data format
1822:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param RTC_StampTimeStruct: pointer to a RTC_TimeTypeDef structure that will 
1823:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                             contains the TimeStamp time values. 
1824:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param RTC_StampDateStruct: pointer to a RTC_DateTypeDef structure that will 
1825:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                             contains the TimeStamp date values.     
1826:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1827:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1828:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
1829:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                       RTC_DateTypeDef* RTC_StampDateStruct)
1830:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1831:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmptime = 0, tmpdate = 0;
1832:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1833:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1834:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
1835:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1836:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get the TimeStamp time and date registers values */
1837:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
1838:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
1839:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1840:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Fill the Time structure fields with the read parameters */
1841:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
1842:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
1843:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
1844:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
1845:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1846:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Fill the Date structure fields with the read parameters */
1847:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_StampDateStruct->RTC_Year = 0;
1848:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
1849:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
1850:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
1851:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1852:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the input parameters format */
1853:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
1854:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1855:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Convert the Time structure parameters to Binary format */
1856:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
1857:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
1858:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
1859:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1860:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Convert the Date structure parameters to Binary format */
1861:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
1862:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
1863:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
1864:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1865:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1866:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1867:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1868:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Get the RTC timestamp Subseconds value.
1869:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  None
1870:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval RTC current timestamp Subseconds value.
1871:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1872:.\StdPeriphLib\src/stm32f0xx_rtc.c **** uint32_t RTC_GetTimeStampSubSecond(void)
1873:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1874:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get timestamp subseconds values from the correspondent registers */
1875:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return (uint32_t)(RTC->TSSSR);
1876:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1877:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1878:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1879:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @}
1880:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1881:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1882:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC_Group9 Tampers configuration functions
1883:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *  @brief   Tampers configuration functions 
1884:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *
1885:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @verbatim   
1886:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
1887:.\StdPeriphLib\src/stm32f0xx_rtc.c ****           ##### Tampers configuration functions #####
1888:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================  
1889:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1890:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @endverbatim
1891:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
1892:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1893:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1894:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1895:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Configures the select Tamper pin edge.
1896:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Tamper: Selected tamper pin.
1897:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be any combination of the following values:
1898:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Tamper_1: Select Tamper 1.
1899:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Tamper_2: Select Tamper 2.
1900:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_TamperTrigger: Specifies the trigger on the tamper pin that 
1901:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                            stimulates tamper event. 
1902:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1903:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperTrigger_RisingEdge: Rising Edge of the tamper pin causes tamper event
1904:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperTrigger_FallingEdge: Falling Edge of the tamper pin causes tamper eve
1905:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperTrigger_LowLevel: Low Level of the tamper pin causes tamper event.
1906:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperTrigger_HighLevel: High Level of the tamper pin causes tamper event.
1907:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1908:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1909:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
1910:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1911:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1912:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
1913:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
1914:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  
1915:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
1916:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {  
1917:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Configure the RTC_TAFCR register */
1918:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
1919:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1920:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
1921:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   { 
1922:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Configure the RTC_TAFCR register */
1923:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
1924:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }  
1925:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1926:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1927:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1928:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Enables or Disables the Tamper detection.
1929:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_Tamper: Selected tamper pin.
1930:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be any combination of the following values:
1931:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Tamper_1: Select Tamper 1.
1932:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_Tamper_2: Select Tamper 2.
1933:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  NewState: new state of the tamper pin.
1934:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         This parameter can be: ENABLE or DISABLE.                   
1935:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1936:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1937:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
1938:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1939:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1940:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_TAMPER(RTC_Tamper));  
1941:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1942:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
1943:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (NewState != DISABLE)
1944:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1945:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Enable the selected Tamper pin */
1946:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->TAFCR |= (uint32_t)RTC_Tamper;
1947:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
1948:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
1949:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
1950:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Disable the selected Tamper pin */
1951:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
1952:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }  
1953:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1954:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1955:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1956:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Configures the Tampers Filter.
1957:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_TamperFilter: Specifies the tampers filter.
1958:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1959:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperFilter_Disable: Tamper filter is disabled.
1960:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperFilter_2Sample: Tamper is activated after 2 consecutive 
1961:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                           samples at the active level 
1962:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperFilter_4Sample: Tamper is activated after 4 consecutive 
1963:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                           samples at the active level
1964:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperFilter_8Sample: Tamper is activated after 8 consecutive 
1965:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                           samples at the active level 
1966:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
1967:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
1968:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
1969:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
1970:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
1971:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
1972:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    
1973:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
1974:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
1975:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1976:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Configure the RTC_TAFCR register */
1977:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
1978:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
1979:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
1980:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
1981:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Configures the Tampers Sampling Frequency.
1982:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_TamperSamplingFreq: Specifies the tampers Sampling Frequency.
1983:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
1984:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperSamplingFreq_RTCCLK_Div32768: Each of the tamper inputs are sampled
1985:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                         with a frequency =  RTCCLK / 32768
1986:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperSamplingFreq_RTCCLK_Div16384: Each of the tamper inputs are sampled
1987:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                         with a frequency =  RTCCLK / 16384
1988:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperSamplingFreq_RTCCLK_Div8192: Each of the tamper inputs are sampled
1989:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                        with a frequency =  RTCCLK / 8192
1990:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperSamplingFreq_RTCCLK_Div4096: Each of the tamper inputs are sampled
1991:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                        with a frequency =  RTCCLK / 4096
1992:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperSamplingFreq_RTCCLK_Div2048: Each of the tamper inputs are sampled
1993:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                        with a frequency =  RTCCLK / 2048
1994:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperSamplingFreq_RTCCLK_Div1024: Each of the tamper inputs are sampled
1995:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                        with a frequency =  RTCCLK / 1024
1996:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperSamplingFreq_RTCCLK_Div512: Each of the tamper inputs are sampled
1997:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                       with a frequency =  RTCCLK / 512  
1998:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperSamplingFreq_RTCCLK_Div256: Each of the tamper inputs are sampled
1999:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                                       with a frequency =  RTCCLK / 256  
2000:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
2001:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2002:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
2003:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
2004:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
2005:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
2006:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  
2007:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
2008:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
2009:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2010:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Configure the RTC_TAFCR register */
2011:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
2012:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
2013:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2014:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2015:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Configures the Tampers Pins input Precharge Duration.
2016:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_TamperPrechargeDuration: Specifies the Tampers Pins input
2017:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         Precharge Duration.
2018:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
2019:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperPrechargeDuration_1RTCCLK: Tamper pins are pre-charged before samplin
2020:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperPrechargeDuration_2RTCCLK: Tamper pins are pre-charged before samplin
2021:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperPrechargeDuration_4RTCCLK: Tamper pins are pre-charged before samplin
2022:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_TamperPrechargeDuration_8RTCCLK: Tamper pins are pre-charged before samplin
2023:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
2024:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2025:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
2026:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
2027:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
2028:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
2029:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    
2030:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
2031:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
2032:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2033:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Configure the RTC_TAFCR register */
2034:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
2035:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
2036:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2037:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2038:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Enables or Disables the TimeStamp on Tamper Detection Event.
2039:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   The timestamp is valid even the TSE bit in tamper control register 
2040:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         is reset.   
2041:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  NewState: new state of the timestamp on tamper event.
2042:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         This parameter can be: ENABLE or DISABLE.
2043:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
2044:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2045:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
2046:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
2047:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
2048:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
2049:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    
2050:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (NewState != DISABLE)
2051:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
2052:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Save timestamp on tamper detection event */
2053:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
2054:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
2055:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
2056:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
2057:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Tamper detection does not cause a timestamp to be saved */
2058:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
2059:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
2060:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
2061:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2062:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2063:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Enables or Disables the Precharge of Tamper pin.
2064:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  NewState: new state of tamper pull up.
2065:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be: ENABLE or DISABLE.                   
2066:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
2067:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2068:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_TamperPullUpCmd(FunctionalState NewState)
2069:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
2070:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
2071:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
2072:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2073:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  if (NewState != DISABLE)
2074:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
2075:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Enable precharge of the selected Tamper pin */
2076:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
2077:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
2078:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
2079:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
2080:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Disable precharge of the selected Tamper pin */
2081:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
2082:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   } 
2083:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
2084:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2085:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2086:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @}
2087:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2088:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2089:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC_Group10 Backup Data Registers configuration functions
2090:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *  @brief   Backup Data Registers configuration functions  
2091:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *
2092:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @verbatim   
2093:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
2094:.\StdPeriphLib\src/stm32f0xx_rtc.c ****           ##### Backup Data Registers configuration functions ##### 
2095:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================  
2096:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2097:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @endverbatim
2098:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
2099:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2100:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2101:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2102:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Writes a data in a specified RTC Backup data register.
2103:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_BKP_DR: RTC Backup data Register number.
2104:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 4 to 
2105:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                 specify the register.
2106:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  Data: Data to be written in the specified RTC Backup data register.                    
2107:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
2108:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2109:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
2110:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
2111:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   __IO uint32_t tmp = 0;
2112:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2113:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
2114:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_BKP(RTC_BKP_DR));
2115:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2116:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmp = RTC_BASE + 0x50;
2117:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmp += (RTC_BKP_DR * 4);
2118:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2119:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Write the specified register */
2120:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *(__IO uint32_t *)tmp = (uint32_t)Data;
2121:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
2122:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2123:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2124:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Reads data from the specified RTC Backup data Register.
2125:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_BKP_DR: RTC Backup data Register number.
2126:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
2127:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                          specify the register.                   
2128:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
2129:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2130:.\StdPeriphLib\src/stm32f0xx_rtc.c **** uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
2131:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
2132:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   __IO uint32_t tmp = 0;
2133:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2134:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
2135:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_BKP(RTC_BKP_DR));
2136:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2137:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmp = RTC_BASE + 0x50;
2138:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmp += (RTC_BKP_DR * 4);
2139:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2140:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Read the specified register */
2141:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return (*(__IO uint32_t *)tmp);
2142:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
2143:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2144:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2145:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @}
2146:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2147:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2148:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC_Group11 Output Type Config configuration functions
2149:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *  @brief   Output Type Config configuration functions  
2150:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *
2151:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @verbatim   
2152:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
2153:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              ##### Output Type Config configuration functions ##### 
2154:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================  
2155:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2156:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @endverbatim
2157:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
2158:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2159:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2160:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2161:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Configures the RTC Output Pin mode. 
2162:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_OutputType: specifies the RTC Output (PC13) pin mode.
2163:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
2164:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_OutputType_OpenDrain: RTC Output (PC13) is configured in 
2165:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                    Open Drain mode.
2166:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
2167:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *                                    Push Pull mode.    
2168:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
2169:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2170:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
2171:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
2172:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
2173:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
2174:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2175:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
2176:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
2177:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
2178:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2179:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2180:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @}
2181:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2182:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2183:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC_Group12 Shift control synchronisation functions
2184:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *  @brief   Shift control synchronisation functions 
2185:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *
2186:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @verbatim   
2187:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
2188:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             ##### Shift control synchronisation functions #####
2189:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================  
2190:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2191:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @endverbatim
2192:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
2193:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2194:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2195:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2196:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Configures the Synchronization Shift Control Settings.
2197:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @note   When REFCKON is set, firmware must not write to Shift control register 
2198:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_ShiftAdd1S: Select to add or not 1 second to the time Calendar.
2199:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values :
2200:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_ShiftAdd1S_Set: Add one second to the clock calendar. 
2201:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_ShiftAdd1S_Reset: No effect.
2202:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_ShiftSubFS: Select the number of Second Fractions to Substitute.
2203:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *         This parameter can be one any value from 0 to 0x7FFF.
2204:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval An ErrorStatus enumeration value:
2205:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - SUCCESS: RTC Shift registers are configured
2206:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          - ERROR: RTC Shift registers are not configured
2207:.\StdPeriphLib\src/stm32f0xx_rtc.c **** */
2208:.\StdPeriphLib\src/stm32f0xx_rtc.c **** ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
2209:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
2210:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
2211:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t shpfcount = 0;
2212:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2213:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
2214:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
2215:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
2216:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2217:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
2218:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
2219:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
2220:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2221:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check if a Shift is pending*/
2222:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
2223:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
2224:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Wait until the shift is completed*/
2225:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
2226:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
2227:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       shpfcount++;
2228:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
2229:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
2230:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2231:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check if the Shift pending is completed or if there is no Shift operation at all*/
2232:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
2233:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
2234:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* check if the reference clock detection is disabled */
2235:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     if((RTC->CR & RTC_CR_REFCKON) == RESET)
2236:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
2237:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       /* Configure the Shift settings */
2238:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
2239:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
2240:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       if(RTC_WaitForSynchro() == ERROR)
2241:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       {
2242:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         status = ERROR;
2243:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       }
2244:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       else
2245:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       {
2246:.\StdPeriphLib\src/stm32f0xx_rtc.c ****         status = SUCCESS;
2247:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       }
2248:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
2249:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     else
2250:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
2251:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       status = ERROR;
2252:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
2253:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
2254:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
2255:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
2256:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = ERROR;
2257:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
2258:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2259:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
2260:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF;
2261:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2262:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return (ErrorStatus)(status);
2263:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
2264:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2265:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2266:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @}
2267:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2268:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2269:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /** @defgroup RTC_Group13 Interrupts and flags management functions
2270:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *  @brief   Interrupts and flags management functions  
2271:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  *
2272:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @verbatim   
2273:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================
2274:.\StdPeriphLib\src/stm32f0xx_rtc.c ****             ##### Interrupts and flags management functions #####
2275:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  ===============================================================================  
2276:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     [..] All RTC interrupts are connected to the EXTI controller.
2277:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  
2278:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (+) To enable the RTC Alarm interrupt, the following sequence is required:
2279:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              (++) Configure and enable the EXTI Line 17 in interrupt mode and select the rising 
2280:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                   edge sensitivity using the EXTI_Init() function.
2281:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              (++) Configure and enable the RTC_Alarm IRQ channel in the NVIC using the NVIC_Init()
2282:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                   function.
2283:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              (++) Configure the RTC to generate RTC alarms (Alarm A) using
2284:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                   the RTC_SetAlarm() and RTC_AlarmCmd() functions.
2285:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2286:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (+) To enable the RTC Tamper interrupt, the following sequence is required:
2287:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              (++) Configure and enable the EXTI Line 19 in interrupt mode and select the rising 
2288:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                   edge sensitivity using the EXTI_Init() function.
2289:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              (++) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the NVIC_Init()
2290:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                   function.
2291:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              (++) Configure the RTC to detect the RTC tamper event using the 
2292:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                   RTC_TamperTriggerConfig() and RTC_TamperCmd() functions.
2293:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2294:.\StdPeriphLib\src/stm32f0xx_rtc.c ****          (+) To enable the RTC TimeStamp interrupt, the following sequence is required:
2295:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              (++) Configure and enable the EXTI Line 19 in interrupt mode and select the rising 
2296:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                   edge sensitivity using the EXTI_Init() function.
2297:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              (++) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the NVIC_Init()
2298:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                   function.
2299:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              (++) Configure the RTC to detect the RTC time-stamp event using the 
2300:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                   RTC_TimeStampCmd() functions.
2301:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2302:.\StdPeriphLib\src/stm32f0xx_rtc.c **** @endverbatim
2303:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @{
2304:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2305:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2306:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2307:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Enables or disables the specified RTC interrupts.
2308:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_IT: specifies the RTC interrupt sources to be enabled or disabled. 
2309:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be any combination of the following values:
2310:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_IT_TS:  Time Stamp interrupt mask
2311:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_IT_WUT:  WakeUp Timer interrupt mask, available only for STM32F072 devices 
2312:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_IT_ALRA:  Alarm A interrupt mask
2313:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_IT_TAMP: Tamper event interrupt mask
2314:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  NewState: new state of the specified RTC interrupts.
2315:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be: ENABLE or DISABLE.
2316:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
2317:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2318:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
2319:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
2320:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
2321:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_CONFIG_IT(RTC_IT));
2322:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
2323:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2324:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Disable the write protection for RTC registers */
2325:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xCA;
2326:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
2327:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2328:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if (NewState != DISABLE)
2329:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
2330:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Configure the Interrupts in the RTC_CR register */
2331:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
2332:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Configure the Tamper Interrupt in the RTC_TAFCR */
2333:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
2334:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
2335:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
2336:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
2337:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Configure the Interrupts in the RTC_CR register */
2338:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
2339:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Configure the Tamper Interrupt in the RTC_TAFCR */
2340:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
2341:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
2342:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Enable the write protection for RTC registers */
2343:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0xFF; 
2344:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
2345:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2346:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2347:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Checks whether the specified RTC flag is set or not.
2348:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_FLAG: specifies the flag to check.
2349:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
2350:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_RECALPF: RECALPF event flag
2351:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_TAMP2F: Tamper 2 event flag   
2352:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
2353:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_TSOVF: Time Stamp OverFlow flag
2354:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_TSF: Time Stamp event flag
2355:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_WUTF: WakeUp Timer flag, available only for STM32F072 devices  
2356:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_ALRAF: Alarm A flag
2357:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_INITF: Initialization mode flag
2358:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_RSF: Registers Synchronized flag
2359:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_INITS: Registers Configured flag
2360:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval The new state of RTC_FLAG (SET or RESET).
2361:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2362:.\StdPeriphLib\src/stm32f0xx_rtc.c **** FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
2363:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
2364:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   FlagStatus bitstatus = RESET;
2365:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
2366:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2367:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
2368:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
2369:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2370:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get all the flags */
2371:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
2372:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2373:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Return the status of the flag */
2374:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
2375:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
2376:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     bitstatus = SET;
2377:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
2378:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
2379:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
2380:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     bitstatus = RESET;
2381:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
2382:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return bitstatus;
2383:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
2384:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2385:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2386:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Clears the RTC's pending flags.
2387:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_FLAG: specifies the RTC flag to clear.
2388:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be any combination of the following values:
2389:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_TAMP2F: Tamper 2 event flag
2390:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_TAMP1F: Tamper 1 event flag 
2391:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_TSOVF: Time Stamp Overflow flag 
2392:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_TSF: Time Stamp event flag
2393:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_WUTF: WakeUp Timer flag, available only for STM32F072 devices  
2394:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_ALRAF: Alarm A flag
2395:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_FLAG_RSF: Registers Synchronized flag
2396:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
2397:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2398:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_ClearFlag(uint32_t RTC_FLAG)
2399:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
2400:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
2401:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
2402:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2403:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Clear the Flags in the RTC_ISR register */
2404:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0001FFFF) | (uint32_t)(RTC->ISR &
2405:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
2406:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2407:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2408:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Checks whether the specified RTC interrupt has occurred or not.
2409:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_IT: specifies the RTC interrupt source to check.
2410:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be one of the following values:
2411:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_IT_TS: Time Stamp interrupt
2412:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_IT_WUT: WakeUp Timer interrupt, available only for STM32F072 devices
2413:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_IT_ALRA: Alarm A interrupt 
2414:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_IT_TAMP1: Tamper1 event interrupt 
2415:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_IT_TAMP2: Tamper2 event interrupt 
2416:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval The new state of RTC_IT (SET or RESET).
2417:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2418:.\StdPeriphLib\src/stm32f0xx_rtc.c **** ITStatus RTC_GetITStatus(uint32_t RTC_IT)
2419:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
2420:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ITStatus bitstatus = RESET;
2421:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0, enablestatus = 0;
2422:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  
2423:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
2424:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_GET_IT(RTC_IT));
2425:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2426:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get the TAMPER Interrupt enable bit and pending bit */
2427:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
2428:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  
2429:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get the Interrupt enable Status */
2430:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & ((RTC_IT >> (RTC_IT >> 18)) >> 15)));
2431:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2432:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get the Interrupt pending bit */
2433:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
2434:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2435:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get the status of the Interrupt */
2436:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
2437:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
2438:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     bitstatus = SET;
2439:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
2440:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   else
2441:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
2442:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     bitstatus = RESET;
2443:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
2444:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return bitstatus;
2445:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
2446:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2447:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2448:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Clears the RTC's interrupt pending bits.
2449:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  RTC_IT: specifies the RTC interrupt pending bit to clear.
2450:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *          This parameter can be any combination of the following values:
2451:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_IT_TS: Time Stamp interrupt 
2452:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_IT_WUT: WakeUp Timer interrupt, available only for STM32F072 devices
2453:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_IT_ALRA: Alarm A interrupt 
2454:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_IT_TAMP1: Tamper1 event interrupt
2455:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   *            @arg RTC_IT_TAMP2: Tamper2 event interrupt
2456:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval None
2457:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2458:.\StdPeriphLib\src/stm32f0xx_rtc.c **** void RTC_ClearITPendingBit(uint32_t RTC_IT)
2459:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
2460:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
2461:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2462:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
2463:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   assert_param(IS_RTC_CLEAR_IT(RTC_IT));
2464:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2465:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get the RTC_ISR Interrupt pending bits mask */
2466:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmpreg = (uint32_t)(RTC_IT >> 4);
2467:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2468:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Clear the interrupt pending bits in the RTC_ISR register */
2469:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & R
2470:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
2471:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2472:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2473:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @}
2474:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2475:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2476:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2477:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Converts a 2 digit decimal to BCD format.
2478:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  Value: Byte to be converted.
2479:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval Converted byte
2480:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2481:.\StdPeriphLib\src/stm32f0xx_rtc.c **** static uint8_t RTC_ByteToBcd2(uint8_t Value)
2482:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
  25              		.loc 1 2482 0
  26              		.cfi_startproc
  27              	.LVL0:
2483:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint8_t bcdhigh = 0;
2484:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2485:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   while (Value >= 10)
  28              		.loc 1 2485 0
  29 0000 0928     		cmp	r0, #9
  30 0002 07D9     		bls	.L4
  31 0004 0023     		mov	r3, #0
  32              	.LVL1:
  33              	.L3:
2486:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
2487:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     bcdhigh++;
  34              		.loc 1 2487 0
  35 0006 0133     		add	r3, r3, #1
  36              	.LVL2:
  37 0008 DBB2     		uxtb	r3, r3
  38              	.LVL3:
2488:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     Value -= 10;
  39              		.loc 1 2488 0
  40 000a 0A38     		sub	r0, r0, #10
  41              	.LVL4:
  42 000c C0B2     		uxtb	r0, r0
  43              	.LVL5:
2485:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
  44              		.loc 1 2485 0
  45 000e 0928     		cmp	r0, #9
  46 0010 F9D8     		bhi	.L3
  47 0012 00E0     		b	.L2
  48              	.LVL6:
  49              	.L4:
2483:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
  50              		.loc 1 2483 0
  51 0014 0023     		mov	r3, #0
  52              	.LVL7:
  53              	.L2:
2489:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
2490:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
2491:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return  ((uint8_t)(bcdhigh << 4) | Value);
  54              		.loc 1 2491 0
  55 0016 1B01     		lsl	r3, r3, #4
  56 0018 1843     		orr	r0, r3
  57              	.LVL8:
  58 001a C0B2     		uxtb	r0, r0
2492:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
  59              		.loc 1 2492 0
  60              		@ sp needed
  61 001c 7047     		bx	lr
  62              		.cfi_endproc
  63              	.LFE84:
  65 001e C046     		.section	.text.RTC_Bcd2ToByte,"ax",%progbits
  66              		.align	2
  67              		.code	16
  68              		.thumb_func
  70              	RTC_Bcd2ToByte:
  71              	.LFB85:
2493:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
2494:.\StdPeriphLib\src/stm32f0xx_rtc.c **** /**
2495:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @brief  Convert from 2 digit BCD to Binary.
2496:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @param  Value: BCD value to be converted.
2497:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   * @retval Converted word
2498:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   */
2499:.\StdPeriphLib\src/stm32f0xx_rtc.c **** static uint8_t RTC_Bcd2ToByte(uint8_t Value)
2500:.\StdPeriphLib\src/stm32f0xx_rtc.c **** {
  72              		.loc 1 2500 0
  73              		.cfi_startproc
  74              	.LVL9:
2501:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint8_t tmp = 0;
2502:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
  75              		.loc 1 2502 0
  76 0000 0209     		lsr	r2, r0, #4
  77 0002 9300     		lsl	r3, r2, #2
  78 0004 D318     		add	r3, r2, r3
  79 0006 5B00     		lsl	r3, r3, #1
2503:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return (tmp + (Value & (uint8_t)0x0F));
  80              		.loc 1 2503 0
  81 0008 0F22     		mov	r2, #15
  82 000a 1040     		and	r0, r2
  83              	.LVL10:
  84 000c 1818     		add	r0, r3, r0
  85 000e C0B2     		uxtb	r0, r0
2504:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
  86              		.loc 1 2504 0
  87              		@ sp needed
  88 0010 7047     		bx	lr
  89              		.cfi_endproc
  90              	.LFE85:
  92 0012 C046     		.section	.text.RTC_StructInit,"ax",%progbits
  93              		.align	2
  94              		.global	RTC_StructInit
  95              		.code	16
  96              		.thumb_func
  98              	RTC_StructInit:
  99              	.LFB35:
 428:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Initialize the RTC_HourFormat member */
 100              		.loc 1 428 0
 101              		.cfi_startproc
 102              	.LVL11:
 430:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 103              		.loc 1 430 0
 104 0000 0023     		mov	r3, #0
 105 0002 0360     		str	r3, [r0]
 433:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 106              		.loc 1 433 0
 107 0004 7F33     		add	r3, r3, #127
 108 0006 4360     		str	r3, [r0, #4]
 436:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 109              		.loc 1 436 0
 110 0008 8033     		add	r3, r3, #128
 111 000a 8360     		str	r3, [r0, #8]
 437:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 112              		.loc 1 437 0
 113              		@ sp needed
 114 000c 7047     		bx	lr
 115              		.cfi_endproc
 116              	.LFE35:
 118 000e C046     		.section	.text.RTC_WriteProtectionCmd,"ax",%progbits
 119              		.align	2
 120              		.global	RTC_WriteProtectionCmd
 121              		.code	16
 122              		.thumb_func
 124              	RTC_WriteProtectionCmd:
 125              	.LFB36:
 450:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 126              		.loc 1 450 0
 127              		.cfi_startproc
 128              	.LVL12:
 454:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 129              		.loc 1 454 0
 130 0000 0028     		cmp	r0, #0
 131 0002 03D0     		beq	.L9
 457:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 132              		.loc 1 457 0
 133 0004 FF22     		mov	r2, #255
 134 0006 044B     		ldr	r3, .L11
 135 0008 5A62     		str	r2, [r3, #36]
 136 000a 04E0     		b	.L8
 137              	.L9:
 462:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->WPR = 0x53;
 138              		.loc 1 462 0
 139 000c 024B     		ldr	r3, .L11
 140 000e CA22     		mov	r2, #202
 141 0010 5A62     		str	r2, [r3, #36]
 463:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 142              		.loc 1 463 0
 143 0012 773A     		sub	r2, r2, #119
 144 0014 5A62     		str	r2, [r3, #36]
 145              	.L8:
 465:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 146              		.loc 1 465 0
 147              		@ sp needed
 148 0016 7047     		bx	lr
 149              	.L12:
 150              		.align	2
 151              	.L11:
 152 0018 00280040 		.word	1073752064
 153              		.cfi_endproc
 154              	.LFE36:
 156              		.section	.text.RTC_EnterInitMode,"ax",%progbits
 157              		.align	2
 158              		.global	RTC_EnterInitMode
 159              		.code	16
 160              		.thumb_func
 162              	RTC_EnterInitMode:
 163              	.LFB37:
 477:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   __IO uint32_t initcounter = 0x00;
 164              		.loc 1 477 0
 165              		.cfi_startproc
 166 0000 10B5     		push	{r4, lr}
 167              	.LCFI0:
 168              		.cfi_def_cfa_offset 8
 169              		.cfi_offset 4, -8
 170              		.cfi_offset 14, -4
 171 0002 82B0     		sub	sp, sp, #8
 172              	.LCFI1:
 173              		.cfi_def_cfa_offset 16
 478:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
 174              		.loc 1 478 0
 175 0004 0023     		mov	r3, #0
 176 0006 0193     		str	r3, [sp, #4]
 177              	.LVL13:
 483:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 178              		.loc 1 483 0
 179 0008 0E4B     		ldr	r3, .L19
 180 000a DB68     		ldr	r3, [r3, #12]
 506:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 181              		.loc 1 506 0
 182 000c 0120     		mov	r0, #1
 483:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 183              		.loc 1 483 0
 184 000e 5B06     		lsl	r3, r3, #25
 185 0010 16D4     		bmi	.L14
 486:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 186              		.loc 1 486 0
 187 0012 0122     		mov	r2, #1
 188 0014 5242     		neg	r2, r2
 189 0016 0B4B     		ldr	r3, .L19
 190 0018 DA60     		str	r2, [r3, #12]
 491:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       initcounter++;  
 191              		.loc 1 491 0
 192 001a 1C1C     		mov	r4, r3
 193 001c 3F30     		add	r0, r0, #63
 493:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 194              		.loc 1 493 0
 195 001e 8021     		mov	r1, #128
 196 0020 C901     		lsl	r1, r1, #7
 197              	.LVL14:
 198              	.L16:
 491:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       initcounter++;  
 199              		.loc 1 491 0 discriminator 2
 200 0022 E368     		ldr	r3, [r4, #12]
 201 0024 0340     		and	r3, r0
 202 0026 1A1C     		mov	r2, r3
 203              	.LVL15:
 492:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 204              		.loc 1 492 0 discriminator 2
 205 0028 019B     		ldr	r3, [sp, #4]
 206 002a 0133     		add	r3, r3, #1
 207 002c 0193     		str	r3, [sp, #4]
 493:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 208              		.loc 1 493 0 discriminator 2
 209 002e 019B     		ldr	r3, [sp, #4]
 210 0030 8B42     		cmp	r3, r1
 211 0032 01D0     		beq	.L15
 493:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 212              		.loc 1 493 0 is_stmt 0 discriminator 1
 213 0034 002A     		cmp	r2, #0
 214 0036 F4D0     		beq	.L16
 215              	.L15:
 495:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 216              		.loc 1 495 0 is_stmt 1
 217 0038 024B     		ldr	r3, .L19
 218 003a D868     		ldr	r0, [r3, #12]
 219 003c 4006     		lsl	r0, r0, #25
 501:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 220              		.loc 1 501 0
 221 003e C00F     		lsr	r0, r0, #31
 222              	.LVL16:
 223              	.L14:
 510:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 224              		.loc 1 510 0
 225 0040 02B0     		add	sp, sp, #8
 226              		@ sp needed
 227 0042 10BD     		pop	{r4, pc}
 228              	.L20:
 229              		.align	2
 230              	.L19:
 231 0044 00280040 		.word	1073752064
 232              		.cfi_endproc
 233              	.LFE37:
 235              		.section	.text.RTC_ExitInitMode,"ax",%progbits
 236              		.align	2
 237              		.global	RTC_ExitInitMode
 238              		.code	16
 239              		.thumb_func
 241              	RTC_ExitInitMode:
 242              	.LFB38:
 522:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Exit Initialization mode */
 243              		.loc 1 522 0
 244              		.cfi_startproc
 524:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 245              		.loc 1 524 0
 246 0000 024A     		ldr	r2, .L22
 247 0002 D368     		ldr	r3, [r2, #12]
 248 0004 8021     		mov	r1, #128
 249 0006 8B43     		bic	r3, r1
 250 0008 D360     		str	r3, [r2, #12]
 525:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 251              		.loc 1 525 0
 252              		@ sp needed
 253 000a 7047     		bx	lr
 254              	.L23:
 255              		.align	2
 256              	.L22:
 257 000c 00280040 		.word	1073752064
 258              		.cfi_endproc
 259              	.LFE38:
 261              		.section	.text.RTC_Init,"ax",%progbits
 262              		.align	2
 263              		.global	RTC_Init
 264              		.code	16
 265              		.thumb_func
 267              	RTC_Init:
 268              	.LFB34:
 382:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
 269              		.loc 1 382 0
 270              		.cfi_startproc
 271              	.LVL17:
 272 0000 10B5     		push	{r4, lr}
 273              	.LCFI2:
 274              		.cfi_def_cfa_offset 8
 275              		.cfi_offset 4, -8
 276              		.cfi_offset 14, -4
 277 0002 041C     		mov	r4, r0
 278              	.LVL18:
 391:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 279              		.loc 1 391 0
 280 0004 104B     		ldr	r3, .L27
 281 0006 CA22     		mov	r2, #202
 282 0008 5A62     		str	r2, [r3, #36]
 392:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 283              		.loc 1 392 0
 284 000a 773A     		sub	r2, r2, #119
 285 000c 5A62     		str	r2, [r3, #36]
 395:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 286              		.loc 1 395 0
 287 000e FFF7FEFF 		bl	RTC_EnterInitMode
 288              	.LVL19:
 397:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 289              		.loc 1 397 0
 290 0012 0023     		mov	r3, #0
 395:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 291              		.loc 1 395 0
 292 0014 0028     		cmp	r0, #0
 293 0016 12D0     		beq	.L25
 402:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Set RTC_CR register */
 294              		.loc 1 402 0
 295 0018 0B4B     		ldr	r3, .L27
 296 001a 9A68     		ldr	r2, [r3, #8]
 297 001c 4021     		mov	r1, #64
 298 001e 8A43     		bic	r2, r1
 299 0020 9A60     		str	r2, [r3, #8]
 404:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 300              		.loc 1 404 0
 301 0022 9A68     		ldr	r2, [r3, #8]
 302 0024 2168     		ldr	r1, [r4]
 303 0026 0A43     		orr	r2, r1
 304 0028 9A60     		str	r2, [r3, #8]
 407:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
 305              		.loc 1 407 0
 306 002a A268     		ldr	r2, [r4, #8]
 307 002c 1A61     		str	r2, [r3, #16]
 408:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 308              		.loc 1 408 0
 309 002e 1969     		ldr	r1, [r3, #16]
 310 0030 6268     		ldr	r2, [r4, #4]
 311 0032 1204     		lsl	r2, r2, #16
 312 0034 0A43     		orr	r2, r1
 313 0036 1A61     		str	r2, [r3, #16]
 411:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 314              		.loc 1 411 0
 315 0038 FFF7FEFF 		bl	RTC_ExitInitMode
 316              	.LVL20:
 413:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 317              		.loc 1 413 0
 318 003c 0123     		mov	r3, #1
 319              	.LVL21:
 320              	.L25:
 416:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 321              		.loc 1 416 0
 322 003e FF21     		mov	r1, #255
 323 0040 014A     		ldr	r2, .L27
 324 0042 5162     		str	r1, [r2, #36]
 419:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 325              		.loc 1 419 0
 326 0044 181C     		mov	r0, r3
 327              		@ sp needed
 328              	.LVL22:
 329 0046 10BD     		pop	{r4, pc}
 330              	.L28:
 331              		.align	2
 332              	.L27:
 333 0048 00280040 		.word	1073752064
 334              		.cfi_endproc
 335              	.LFE34:
 337              		.section	.text.RTC_WaitForSynchro,"ax",%progbits
 338              		.align	2
 339              		.global	RTC_WaitForSynchro
 340              		.code	16
 341              		.thumb_func
 343              	RTC_WaitForSynchro:
 344              	.LFB39:
 544:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   __IO uint32_t synchrocounter = 0;
 345              		.loc 1 544 0
 346              		.cfi_startproc
 347 0000 10B5     		push	{r4, lr}
 348              	.LCFI3:
 349              		.cfi_def_cfa_offset 8
 350              		.cfi_offset 4, -8
 351              		.cfi_offset 14, -4
 352 0002 82B0     		sub	sp, sp, #8
 353              	.LCFI4:
 354              		.cfi_def_cfa_offset 16
 545:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
 355              		.loc 1 545 0
 356 0004 0023     		mov	r3, #0
 357 0006 0193     		str	r3, [sp, #4]
 358              	.LVL23:
 549:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 359              		.loc 1 549 0
 360 0008 124B     		ldr	r3, .L35
 361 000a 9B68     		ldr	r3, [r3, #8]
 552:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 362              		.loc 1 552 0
 363 000c 0120     		mov	r0, #1
 549:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 364              		.loc 1 549 0
 365 000e 9B06     		lsl	r3, r3, #26
 366 0010 1DD4     		bmi	.L30
 557:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->WPR = 0x53;
 367              		.loc 1 557 0
 368 0012 104B     		ldr	r3, .L35
 369 0014 CA22     		mov	r2, #202
 370 0016 5A62     		str	r2, [r3, #36]
 558:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 371              		.loc 1 558 0
 372 0018 773A     		sub	r2, r2, #119
 373 001a 5A62     		str	r2, [r3, #36]
 561:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 374              		.loc 1 561 0
 375 001c DA68     		ldr	r2, [r3, #12]
 376 001e A021     		mov	r1, #160
 377 0020 8A43     		bic	r2, r1
 378 0022 DA60     		str	r2, [r3, #12]
 566:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       synchrocounter++;  
 379              		.loc 1 566 0
 380 0024 1C1C     		mov	r4, r3
 381 0026 1F30     		add	r0, r0, #31
 568:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 382              		.loc 1 568 0
 383 0028 8021     		mov	r1, #128
 384 002a 0902     		lsl	r1, r1, #8
 385              	.LVL24:
 386              	.L32:
 566:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       synchrocounter++;  
 387              		.loc 1 566 0 discriminator 2
 388 002c E368     		ldr	r3, [r4, #12]
 389 002e 0340     		and	r3, r0
 390 0030 1A1C     		mov	r2, r3
 391              	.LVL25:
 567:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 392              		.loc 1 567 0 discriminator 2
 393 0032 019B     		ldr	r3, [sp, #4]
 394 0034 0133     		add	r3, r3, #1
 395 0036 0193     		str	r3, [sp, #4]
 568:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 396              		.loc 1 568 0 discriminator 2
 397 0038 019B     		ldr	r3, [sp, #4]
 398 003a 8B42     		cmp	r3, r1
 399 003c 01D0     		beq	.L31
 568:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 400              		.loc 1 568 0 is_stmt 0 discriminator 1
 401 003e 002A     		cmp	r2, #0
 402 0040 F4D0     		beq	.L32
 403              	.L31:
 570:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 404              		.loc 1 570 0 is_stmt 1
 405 0042 044B     		ldr	r3, .L35
 406 0044 D868     		ldr	r0, [r3, #12]
 407 0046 8006     		lsl	r0, r0, #26
 572:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 408              		.loc 1 572 0
 409 0048 C00F     		lsr	r0, r0, #31
 410              	.LVL26:
 580:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 411              		.loc 1 580 0
 412 004a FF22     		mov	r2, #255
 413              	.LVL27:
 414 004c 5A62     		str	r2, [r3, #36]
 415              	.LVL28:
 416              	.L30:
 584:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 417              		.loc 1 584 0
 418 004e 02B0     		add	sp, sp, #8
 419              		@ sp needed
 420 0050 10BD     		pop	{r4, pc}
 421              	.L36:
 422 0052 C046     		.align	2
 423              	.L35:
 424 0054 00280040 		.word	1073752064
 425              		.cfi_endproc
 426              	.LFE39:
 428              		.section	.text.RTC_DeInit,"ax",%progbits
 429              		.align	2
 430              		.global	RTC_DeInit
 431              		.code	16
 432              		.thumb_func
 434              	RTC_DeInit:
 435              	.LFB33:
 321:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
 436              		.loc 1 321 0
 437              		.cfi_startproc
 438 0000 08B5     		push	{r3, lr}
 439              	.LCFI5:
 440              		.cfi_def_cfa_offset 8
 441              		.cfi_offset 3, -8
 442              		.cfi_offset 14, -4
 443              	.LVL29:
 325:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 444              		.loc 1 325 0
 445 0002 124B     		ldr	r3, .L40
 446 0004 CA22     		mov	r2, #202
 447 0006 5A62     		str	r2, [r3, #36]
 326:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 448              		.loc 1 326 0
 449 0008 773A     		sub	r2, r2, #119
 450 000a 5A62     		str	r2, [r3, #36]
 329:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 451              		.loc 1 329 0
 452 000c FFF7FEFF 		bl	RTC_EnterInitMode
 453              	.LVL30:
 331:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }  
 454              		.loc 1 331 0
 455 0010 0023     		mov	r3, #0
 329:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 456              		.loc 1 329 0
 457 0012 0028     		cmp	r0, #0
 458 0014 15D0     		beq	.L38
 336:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->WUTR      = (uint32_t)0x0000FFFF;
 459              		.loc 1 336 0
 460 0016 0D4B     		ldr	r3, .L40
 461 0018 0022     		mov	r2, #0
 462 001a 1A60     		str	r2, [r3]
 337:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->DR        = (uint32_t)0x00002101;
 463              		.loc 1 337 0
 464 001c 0C49     		ldr	r1, .L40+4
 465 001e 5961     		str	r1, [r3, #20]
 338:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CR        &= (uint32_t)0x00000000;
 466              		.loc 1 338 0
 467 0020 0C49     		ldr	r1, .L40+8
 468 0022 5960     		str	r1, [r3, #4]
 339:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->PRER      = (uint32_t)0x007F00FF;
 469              		.loc 1 339 0
 470 0024 9968     		ldr	r1, [r3, #8]
 471 0026 9A60     		str	r2, [r3, #8]
 340:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->ALRMAR    = (uint32_t)0x00000000;
 472              		.loc 1 340 0
 473 0028 0B49     		ldr	r1, .L40+12
 474 002a 1961     		str	r1, [r3, #16]
 341:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->SHIFTR    = (uint32_t)0x00000000;
 475              		.loc 1 341 0
 476 002c DA61     		str	r2, [r3, #28]
 342:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->CALR       = (uint32_t)0x00000000;
 477              		.loc 1 342 0
 478 002e DA62     		str	r2, [r3, #44]
 343:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC->ALRMASSR  = (uint32_t)0x00000000;
 479              		.loc 1 343 0
 480 0030 DA63     		str	r2, [r3, #60]
 344:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 481              		.loc 1 344 0
 482 0032 5A64     		str	r2, [r3, #68]
 347:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 483              		.loc 1 347 0
 484 0034 DA60     		str	r2, [r3, #12]
 350:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       
 485              		.loc 1 350 0
 486 0036 1A64     		str	r2, [r3, #64]
 353:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 487              		.loc 1 353 0
 488 0038 FFF7FEFF 		bl	RTC_WaitForSynchro
 489              	.LVL31:
 490 003c 431E     		sub	r3, r0, #1
 491 003e 9841     		sbc	r0, r0, r3
 331:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }  
 492              		.loc 1 331 0
 493 0040 C3B2     		uxtb	r3, r0
 494              	.L38:
 495              	.LVL32:
 365:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 496              		.loc 1 365 0
 497 0042 FF21     		mov	r1, #255
 498 0044 014A     		ldr	r2, .L40
 499 0046 5162     		str	r1, [r2, #36]
 368:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 500              		.loc 1 368 0
 501 0048 181C     		mov	r0, r3
 502              		@ sp needed
 503 004a 08BD     		pop	{r3, pc}
 504              	.L41:
 505              		.align	2
 506              	.L40:
 507 004c 00280040 		.word	1073752064
 508 0050 FFFF0000 		.word	65535
 509 0054 01210000 		.word	8449
 510 0058 FF007F00 		.word	8323327
 511              		.cfi_endproc
 512              	.LFE33:
 514              		.section	.text.RTC_RefClockCmd,"ax",%progbits
 515              		.align	2
 516              		.global	RTC_RefClockCmd
 517              		.code	16
 518              		.thumb_func
 520              	RTC_RefClockCmd:
 521              	.LFB40:
 595:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
 522              		.loc 1 595 0
 523              		.cfi_startproc
 524              	.LVL33:
 525 0000 10B5     		push	{r4, lr}
 526              	.LCFI6:
 527              		.cfi_def_cfa_offset 8
 528              		.cfi_offset 4, -8
 529              		.cfi_offset 14, -4
 530 0002 041C     		mov	r4, r0
 531              	.LVL34:
 602:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 532              		.loc 1 602 0
 533 0004 0F4B     		ldr	r3, .L47
 534 0006 CA22     		mov	r2, #202
 535 0008 5A62     		str	r2, [r3, #36]
 603:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 536              		.loc 1 603 0
 537 000a 773A     		sub	r2, r2, #119
 538 000c 5A62     		str	r2, [r3, #36]
 606:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 539              		.loc 1 606 0
 540 000e FFF7FEFF 		bl	RTC_EnterInitMode
 541              	.LVL35:
 608:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 542              		.loc 1 608 0
 543 0012 0023     		mov	r3, #0
 606:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 544              		.loc 1 606 0
 545 0014 0028     		cmp	r0, #0
 546 0016 0FD0     		beq	.L43
 612:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 547              		.loc 1 612 0
 548 0018 002C     		cmp	r4, #0
 549 001a 05D0     		beq	.L44
 615:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 550              		.loc 1 615 0
 551 001c 094A     		ldr	r2, .L47
 552 001e 9168     		ldr	r1, [r2, #8]
 553 0020 1033     		add	r3, r3, #16
 554 0022 0B43     		orr	r3, r1
 555 0024 9360     		str	r3, [r2, #8]
 556 0026 04E0     		b	.L45
 557              	.L44:
 620:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 558              		.loc 1 620 0
 559 0028 064A     		ldr	r2, .L47
 560 002a 9368     		ldr	r3, [r2, #8]
 561 002c 1021     		mov	r1, #16
 562 002e 8B43     		bic	r3, r1
 563 0030 9360     		str	r3, [r2, #8]
 564              	.L45:
 623:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 565              		.loc 1 623 0
 566 0032 FFF7FEFF 		bl	RTC_ExitInitMode
 567              	.LVL36:
 625:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 568              		.loc 1 625 0
 569 0036 0123     		mov	r3, #1
 570              	.LVL37:
 571              	.L43:
 629:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 572              		.loc 1 629 0
 573 0038 FF21     		mov	r1, #255
 574 003a 024A     		ldr	r2, .L47
 575 003c 5162     		str	r1, [r2, #36]
 632:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 576              		.loc 1 632 0
 577 003e 181C     		mov	r0, r3
 578              		@ sp needed
 579 0040 10BD     		pop	{r4, pc}
 580              	.L48:
 581 0042 C046     		.align	2
 582              	.L47:
 583 0044 00280040 		.word	1073752064
 584              		.cfi_endproc
 585              	.LFE40:
 587              		.section	.text.RTC_BypassShadowCmd,"ax",%progbits
 588              		.align	2
 589              		.global	RTC_BypassShadowCmd
 590              		.code	16
 591              		.thumb_func
 593              	RTC_BypassShadowCmd:
 594              	.LFB41:
 643:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 595              		.loc 1 643 0
 596              		.cfi_startproc
 597              	.LVL38:
 648:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 598              		.loc 1 648 0
 599 0000 0A4B     		ldr	r3, .L52
 600 0002 CA22     		mov	r2, #202
 601 0004 5A62     		str	r2, [r3, #36]
 649:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 602              		.loc 1 649 0
 603 0006 773A     		sub	r2, r2, #119
 604 0008 5A62     		str	r2, [r3, #36]
 651:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 605              		.loc 1 651 0
 606 000a 0028     		cmp	r0, #0
 607 000c 05D0     		beq	.L50
 654:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 608              		.loc 1 654 0
 609 000e 1A1C     		mov	r2, r3
 610 0010 9968     		ldr	r1, [r3, #8]
 611 0012 2023     		mov	r3, #32
 612 0014 0B43     		orr	r3, r1
 613 0016 9360     		str	r3, [r2, #8]
 614 0018 04E0     		b	.L51
 615              	.L50:
 659:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 616              		.loc 1 659 0
 617 001a 044A     		ldr	r2, .L52
 618 001c 9368     		ldr	r3, [r2, #8]
 619 001e DF21     		mov	r1, #223
 620 0020 0B40     		and	r3, r1
 621 0022 9360     		str	r3, [r2, #8]
 622              	.L51:
 663:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 623              		.loc 1 663 0
 624 0024 FF22     		mov	r2, #255
 625 0026 014B     		ldr	r3, .L52
 626 0028 5A62     		str	r2, [r3, #36]
 664:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 627              		.loc 1 664 0
 628              		@ sp needed
 629 002a 7047     		bx	lr
 630              	.L53:
 631              		.align	2
 632              	.L52:
 633 002c 00280040 		.word	1073752064
 634              		.cfi_endproc
 635              	.LFE41:
 637              		.section	.text.RTC_SetTime,"ax",%progbits
 638              		.align	2
 639              		.global	RTC_SetTime
 640              		.code	16
 641              		.thumb_func
 643              	RTC_SetTime:
 644              	.LFB42:
 697:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 645              		.loc 1 697 0
 646              		.cfi_startproc
 647              	.LVL39:
 648 0000 70B5     		push	{r4, r5, r6, lr}
 649              	.LCFI7:
 650              		.cfi_def_cfa_offset 16
 651              		.cfi_offset 4, -16
 652              		.cfi_offset 5, -12
 653              		.cfi_offset 6, -8
 654              		.cfi_offset 14, -4
 655 0002 0C1C     		mov	r4, r1
 656              	.LVL40:
 704:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 657              		.loc 1 704 0
 658 0004 0028     		cmp	r0, #0
 659 0006 06D1     		bne	.L55
 706:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 660              		.loc 1 706 0
 661 0008 254B     		ldr	r3, .L63
 662 000a 9B68     		ldr	r3, [r3, #8]
 663 000c 5B06     		lsl	r3, r3, #25
 664 000e 2FD4     		bmi	.L56
 713:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
 665              		.loc 1 713 0
 666 0010 0023     		mov	r3, #0
 667 0012 CB70     		strb	r3, [r1, #3]
 668 0014 2CE0     		b	.L56
 669              	.L55:
 721:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 670              		.loc 1 721 0
 671 0016 224B     		ldr	r3, .L63
 672 0018 9B68     		ldr	r3, [r3, #8]
 673 001a 5B06     		lsl	r3, r3, #25
 674 001c 1CD4     		bmi	.L57
 729:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
 675              		.loc 1 729 0
 676 001e 0023     		mov	r3, #0
 677 0020 CB70     		strb	r3, [r1, #3]
 678 0022 19E0     		b	.L57
 679              	.LVL41:
 680              	.L59:
 753:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 681              		.loc 1 753 0
 682 0024 1E4B     		ldr	r3, .L63
 683 0026 CA22     		mov	r2, #202
 684 0028 5A62     		str	r2, [r3, #36]
 754:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 685              		.loc 1 754 0
 686 002a 773A     		sub	r2, r2, #119
 687 002c 5A62     		str	r2, [r3, #36]
 757:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 688              		.loc 1 757 0
 689 002e FFF7FEFF 		bl	RTC_EnterInitMode
 690              	.LVL42:
 759:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   } 
 691              		.loc 1 759 0
 692 0032 0023     		mov	r3, #0
 757:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 693              		.loc 1 757 0
 694 0034 0028     		cmp	r0, #0
 695 0036 2ED0     		beq	.L58
 764:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 696              		.loc 1 764 0
 697 0038 1A48     		ldr	r0, .L63+4
 698 003a 0440     		and	r4, r0
 699              	.LVL43:
 700 003c 184D     		ldr	r5, .L63
 701 003e 2C60     		str	r4, [r5]
 767:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 702              		.loc 1 767 0
 703 0040 FFF7FEFF 		bl	RTC_ExitInitMode
 704              	.LVL44:
 770:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 705              		.loc 1 770 0
 706 0044 AA68     		ldr	r2, [r5, #8]
 783:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 707              		.loc 1 783 0
 708 0046 0123     		mov	r3, #1
 770:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 709              		.loc 1 770 0
 710 0048 9206     		lsl	r2, r2, #26
 711 004a 24D4     		bmi	.L58
 772:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       {
 712              		.loc 1 772 0
 713 004c FFF7FEFF 		bl	RTC_WaitForSynchro
 714              	.LVL45:
 715 0050 431E     		sub	r3, r0, #1
 716 0052 9841     		sbc	r0, r0, r3
 759:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   } 
 717              		.loc 1 759 0
 718 0054 C3B2     		uxtb	r3, r0
 719 0056 1EE0     		b	.L58
 720              	.LVL46:
 721              	.L57:
 739:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 722              		.loc 1 739 0
 723 0058 2378     		ldrb	r3, [r4]
 724 005a 1804     		lsl	r0, r3, #16
 725              	.LVL47:
 740:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
 726              		.loc 1 740 0
 727 005c 6378     		ldrb	r3, [r4, #1]
 728 005e 1B02     		lsl	r3, r3, #8
 739:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 729              		.loc 1 739 0
 730 0060 0343     		orr	r3, r0
 741:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
 731              		.loc 1 741 0
 732 0062 A078     		ldrb	r0, [r4, #2]
 740:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
 733              		.loc 1 740 0
 734 0064 1843     		orr	r0, r3
 742:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 735              		.loc 1 742 0
 736 0066 E378     		ldrb	r3, [r4, #3]
 737 0068 1B04     		lsl	r3, r3, #16
 739:.\StdPeriphLib\src/stm32f0xx_rtc.c ****              ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 738              		.loc 1 739 0
 739 006a 1843     		orr	r0, r3
 740 006c 041C     		mov	r4, r0
 741              	.LVL48:
 742 006e D9E7     		b	.L59
 743              	.LVL49:
 744              	.L56:
 746:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                    ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 745              		.loc 1 746 0
 746 0070 2078     		ldrb	r0, [r4]
 747              	.LVL50:
 748 0072 FFF7FEFF 		bl	RTC_ByteToBcd2
 749              	.LVL51:
 750 0076 061C     		mov	r6, r0
 747:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                    ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
 751              		.loc 1 747 0
 752 0078 6078     		ldrb	r0, [r4, #1]
 753 007a FFF7FEFF 		bl	RTC_ByteToBcd2
 754              	.LVL52:
 755 007e 051C     		mov	r5, r0
 748:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                    (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
 756              		.loc 1 748 0
 757 0080 A078     		ldrb	r0, [r4, #2]
 758 0082 FFF7FEFF 		bl	RTC_ByteToBcd2
 759              	.LVL53:
 749:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   } 
 760              		.loc 1 749 0
 761 0086 E478     		ldrb	r4, [r4, #3]
 762              	.LVL54:
 763 0088 2404     		lsl	r4, r4, #16
 764 008a 0443     		orr	r4, r0
 746:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                    ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 765              		.loc 1 746 0
 766 008c 3604     		lsl	r6, r6, #16
 767 008e 3443     		orr	r4, r6
 747:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                    ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
 768              		.loc 1 747 0
 769 0090 2D02     		lsl	r5, r5, #8
 746:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                    ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 770              		.loc 1 746 0
 771 0092 2C43     		orr	r4, r5
 772              	.LVL55:
 773 0094 C6E7     		b	.L59
 774              	.LVL56:
 775              	.L58:
 788:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 776              		.loc 1 788 0
 777 0096 FF21     		mov	r1, #255
 778 0098 014A     		ldr	r2, .L63
 779 009a 5162     		str	r1, [r2, #36]
 791:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 780              		.loc 1 791 0
 781 009c 181C     		mov	r0, r3
 782              		@ sp needed
 783 009e 70BD     		pop	{r4, r5, r6, pc}
 784              	.L64:
 785              		.align	2
 786              	.L63:
 787 00a0 00280040 		.word	1073752064
 788 00a4 7F7F7F00 		.word	8355711
 789              		.cfi_endproc
 790              	.LFE42:
 792              		.section	.text.RTC_TimeStructInit,"ax",%progbits
 793              		.align	2
 794              		.global	RTC_TimeStructInit
 795              		.code	16
 796              		.thumb_func
 798              	RTC_TimeStructInit:
 799              	.LFB43:
 801:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Time = 00h:00min:00sec */
 800              		.loc 1 801 0
 801              		.cfi_startproc
 802              	.LVL57:
 803:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_TimeStruct->RTC_Hours = 0;
 803              		.loc 1 803 0
 804 0000 0023     		mov	r3, #0
 805 0002 C370     		strb	r3, [r0, #3]
 804:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_TimeStruct->RTC_Minutes = 0;
 806              		.loc 1 804 0
 807 0004 0370     		strb	r3, [r0]
 805:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_TimeStruct->RTC_Seconds = 0; 
 808              		.loc 1 805 0
 809 0006 4370     		strb	r3, [r0, #1]
 806:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 810              		.loc 1 806 0
 811 0008 8370     		strb	r3, [r0, #2]
 807:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 812              		.loc 1 807 0
 813              		@ sp needed
 814 000a 7047     		bx	lr
 815              		.cfi_endproc
 816              	.LFE43:
 818              		.section	.text.RTC_GetTime,"ax",%progbits
 819              		.align	2
 820              		.global	RTC_GetTime
 821              		.code	16
 822              		.thumb_func
 824              	RTC_GetTime:
 825              	.LFB44:
 820:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 826              		.loc 1 820 0
 827              		.cfi_startproc
 828              	.LVL58:
 829 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 830              	.LCFI8:
 831              		.cfi_def_cfa_offset 24
 832              		.cfi_offset 3, -24
 833              		.cfi_offset 4, -20
 834              		.cfi_offset 5, -16
 835              		.cfi_offset 6, -12
 836              		.cfi_offset 7, -8
 837              		.cfi_offset 14, -4
 838              	.LVL59:
 827:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 839              		.loc 1 827 0
 840 0002 104B     		ldr	r3, .L68
 841 0004 1A68     		ldr	r2, [r3]
 842              	.LVL60:
 830:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 843              		.loc 1 830 0
 844 0006 9702     		lsl	r7, r2, #10
 845 0008 BF0E     		lsr	r7, r7, #26
 846 000a 0F70     		strb	r7, [r1]
 831:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 847              		.loc 1 831 0
 848 000c 5604     		lsl	r6, r2, #17
 849 000e 760E     		lsr	r6, r6, #25
 850 0010 4E70     		strb	r6, [r1, #1]
 832:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 851              		.loc 1 832 0
 852 0012 7F25     		mov	r5, #127
 853 0014 1540     		and	r5, r2
 854 0016 8D70     		strb	r5, [r1, #2]
 833:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 855              		.loc 1 833 0
 856 0018 8023     		mov	r3, #128
 857 001a DB03     		lsl	r3, r3, #15
 858 001c 1340     		and	r3, r2
 859 001e 1B0C     		lsr	r3, r3, #16
 860 0020 CB70     		strb	r3, [r1, #3]
 836:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 861              		.loc 1 836 0
 862 0022 0028     		cmp	r0, #0
 863 0024 0CD1     		bne	.L66
 864 0026 0C1C     		mov	r4, r1
 839:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
 865              		.loc 1 839 0
 866 0028 381C     		mov	r0, r7
 867              	.LVL61:
 868 002a FFF7FEFF 		bl	RTC_Bcd2ToByte
 869              	.LVL62:
 870 002e 2070     		strb	r0, [r4]
 840:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);
 871              		.loc 1 840 0
 872 0030 301C     		mov	r0, r6
 873 0032 FFF7FEFF 		bl	RTC_Bcd2ToByte
 874              	.LVL63:
 875 0036 6070     		strb	r0, [r4, #1]
 841:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 876              		.loc 1 841 0
 877 0038 281C     		mov	r0, r5
 878 003a FFF7FEFF 		bl	RTC_Bcd2ToByte
 879              	.LVL64:
 880 003e A070     		strb	r0, [r4, #2]
 881              	.LVL65:
 882              	.L66:
 843:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 883              		.loc 1 843 0
 884              		@ sp needed
 885 0040 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 886              	.L69:
 887 0042 C046     		.align	2
 888              	.L68:
 889 0044 00280040 		.word	1073752064
 890              		.cfi_endproc
 891              	.LFE44:
 893              		.section	.text.RTC_GetSubSecond,"ax",%progbits
 894              		.align	2
 895              		.global	RTC_GetSubSecond
 896              		.code	16
 897              		.thumb_func
 899              	RTC_GetSubSecond:
 900              	.LFB45:
 853:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 901              		.loc 1 853 0
 902              		.cfi_startproc
 903              	.LVL66:
 857:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 904              		.loc 1 857 0
 905 0000 014B     		ldr	r3, .L71
 906 0002 986A     		ldr	r0, [r3, #40]
 907              	.LVL67:
 860:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 908              		.loc 1 860 0
 909 0004 5B68     		ldr	r3, [r3, #4]
 863:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 910              		.loc 1 863 0
 911              		@ sp needed
 912 0006 7047     		bx	lr
 913              	.L72:
 914              		.align	2
 915              	.L71:
 916 0008 00280040 		.word	1073752064
 917              		.cfi_endproc
 918              	.LFE45:
 920              		.section	.text.RTC_SetDate,"ax",%progbits
 921              		.align	2
 922              		.global	RTC_SetDate
 923              		.code	16
 924              		.thumb_func
 926              	RTC_SetDate:
 927              	.LFB46:
 878:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 928              		.loc 1 878 0
 929              		.cfi_startproc
 930              	.LVL68:
 931 0000 70B5     		push	{r4, r5, r6, lr}
 932              	.LCFI9:
 933              		.cfi_def_cfa_offset 16
 934              		.cfi_offset 4, -16
 935              		.cfi_offset 5, -12
 936              		.cfi_offset 6, -8
 937              		.cfi_offset 14, -4
 938 0002 0C1C     		mov	r4, r1
 939              	.LVL69:
 885:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 940              		.loc 1 885 0
 941 0004 0028     		cmp	r0, #0
 942 0006 34D1     		bne	.L74
 885:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 943              		.loc 1 885 0 is_stmt 0 discriminator 1
 944 0008 4B78     		ldrb	r3, [r1, #1]
 945 000a DA06     		lsl	r2, r3, #27
 946 000c 1ED5     		bpl	.L75
 887:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }  
 947              		.loc 1 887 0 is_stmt 1
 948 000e 1022     		mov	r2, #16
 949 0010 9343     		bic	r3, r2
 950 0012 0A33     		add	r3, r3, #10
 951 0014 4B70     		strb	r3, [r1, #1]
 952 0016 19E0     		b	.L75
 953              	.LVL70:
 954              	.L77:
 922:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 955              		.loc 1 922 0
 956 0018 1E4B     		ldr	r3, .L81
 957 001a CA22     		mov	r2, #202
 958 001c 5A62     		str	r2, [r3, #36]
 923:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 959              		.loc 1 923 0
 960 001e 773A     		sub	r2, r2, #119
 961 0020 5A62     		str	r2, [r3, #36]
 926:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 962              		.loc 1 926 0
 963 0022 FFF7FEFF 		bl	RTC_EnterInitMode
 964              	.LVL71:
 928:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   } 
 965              		.loc 1 928 0
 966 0026 0023     		mov	r3, #0
 926:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 967              		.loc 1 926 0
 968 0028 0028     		cmp	r0, #0
 969 002a 2ED0     		beq	.L76
 933:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 970              		.loc 1 933 0
 971 002c 1A48     		ldr	r0, .L81+4
 972 002e 0440     		and	r4, r0
 973              	.LVL72:
 974 0030 184D     		ldr	r5, .L81
 975 0032 6C60     		str	r4, [r5, #4]
 936:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 976              		.loc 1 936 0
 977 0034 FFF7FEFF 		bl	RTC_ExitInitMode
 978              	.LVL73:
 939:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 979              		.loc 1 939 0
 980 0038 AA68     		ldr	r2, [r5, #8]
 952:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 981              		.loc 1 952 0
 982 003a 0123     		mov	r3, #1
 939:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 983              		.loc 1 939 0
 984 003c 9206     		lsl	r2, r2, #26
 985 003e 24D4     		bmi	.L76
 941:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       {
 986              		.loc 1 941 0
 987 0040 FFF7FEFF 		bl	RTC_WaitForSynchro
 988              	.LVL74:
 989 0044 431E     		sub	r3, r0, #1
 990 0046 9841     		sbc	r0, r0, r3
 928:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   } 
 991              		.loc 1 928 0
 992 0048 C3B2     		uxtb	r3, r0
 993 004a 1EE0     		b	.L76
 994              	.LVL75:
 995              	.L75:
 915:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 996              		.loc 1 915 0
 997 004c E078     		ldrb	r0, [r4, #3]
 998              	.LVL76:
 999 004e FFF7FEFF 		bl	RTC_ByteToBcd2
 1000              	.LVL77:
 1001 0052 061C     		mov	r6, r0
 916:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
 1002              		.loc 1 916 0
 1003 0054 6078     		ldrb	r0, [r4, #1]
 1004 0056 FFF7FEFF 		bl	RTC_ByteToBcd2
 1005              	.LVL78:
 1006 005a 051C     		mov	r5, r0
 917:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
 1007              		.loc 1 917 0
 1008 005c A078     		ldrb	r0, [r4, #2]
 1009 005e FFF7FEFF 		bl	RTC_ByteToBcd2
 1010              	.LVL79:
 918:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 1011              		.loc 1 918 0
 1012 0062 2478     		ldrb	r4, [r4]
 1013              	.LVL80:
 1014 0064 6403     		lsl	r4, r4, #13
 1015 0066 0443     		orr	r4, r0
 915:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 1016              		.loc 1 915 0
 1017 0068 3604     		lsl	r6, r6, #16
 1018 006a 3443     		orr	r4, r6
 916:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
 1019              		.loc 1 916 0
 1020 006c 2D02     		lsl	r5, r5, #8
 915:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 1021              		.loc 1 915 0
 1022 006e 2C43     		orr	r4, r5
 1023              	.LVL81:
 1024 0070 D2E7     		b	.L77
 1025              	.LVL82:
 1026              	.L74:
 908:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 1027              		.loc 1 908 0
 1028 0072 CB78     		ldrb	r3, [r1, #3]
 1029 0074 1804     		lsl	r0, r3, #16
 1030              	.LVL83:
 909:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_DateStruct->RTC_Date) | \
 1031              		.loc 1 909 0
 1032 0076 4B78     		ldrb	r3, [r1, #1]
 1033 0078 1B02     		lsl	r3, r3, #8
 908:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 1034              		.loc 1 908 0
 1035 007a 0343     		orr	r3, r0
 910:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
 1036              		.loc 1 910 0
 1037 007c 8878     		ldrb	r0, [r1, #2]
 909:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_DateStruct->RTC_Date) | \
 1038              		.loc 1 909 0
 1039 007e 1843     		orr	r0, r3
 911:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }  
 1040              		.loc 1 911 0
 1041 0080 0B78     		ldrb	r3, [r1]
 1042 0082 5B03     		lsl	r3, r3, #13
 908:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 1043              		.loc 1 908 0
 1044 0084 1843     		orr	r0, r3
 1045 0086 041C     		mov	r4, r0
 1046              	.LVL84:
 1047 0088 C6E7     		b	.L77
 1048              	.LVL85:
 1049              	.L76:
 956:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 1050              		.loc 1 956 0
 1051 008a FF21     		mov	r1, #255
 1052 008c 014A     		ldr	r2, .L81
 1053 008e 5162     		str	r1, [r2, #36]
 959:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1054              		.loc 1 959 0
 1055 0090 181C     		mov	r0, r3
 1056              		@ sp needed
 1057 0092 70BD     		pop	{r4, r5, r6, pc}
 1058              	.L82:
 1059              		.align	2
 1060              	.L81:
 1061 0094 00280040 		.word	1073752064
 1062 0098 3FFFFF00 		.word	16777023
 1063              		.cfi_endproc
 1064              	.LFE46:
 1066              		.section	.text.RTC_DateStructInit,"ax",%progbits
 1067              		.align	2
 1068              		.global	RTC_DateStructInit
 1069              		.code	16
 1070              		.thumb_func
 1072              	RTC_DateStructInit:
 1073              	.LFB47:
 969:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Monday, January 01 xx00 */
 1074              		.loc 1 969 0
 1075              		.cfi_startproc
 1076              	.LVL86:
 971:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_DateStruct->RTC_Date = 1;
 1077              		.loc 1 971 0
 1078 0000 0123     		mov	r3, #1
 1079 0002 0370     		strb	r3, [r0]
 972:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_DateStruct->RTC_Month = RTC_Month_January;
 1080              		.loc 1 972 0
 1081 0004 8370     		strb	r3, [r0, #2]
 973:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_DateStruct->RTC_Year = 0;
 1082              		.loc 1 973 0
 1083 0006 4370     		strb	r3, [r0, #1]
 974:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 1084              		.loc 1 974 0
 1085 0008 0023     		mov	r3, #0
 1086 000a C370     		strb	r3, [r0, #3]
 975:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1087              		.loc 1 975 0
 1088              		@ sp needed
 1089 000c 7047     		bx	lr
 1090              		.cfi_endproc
 1091              	.LFE47:
 1093 000e C046     		.section	.text.RTC_GetDate,"ax",%progbits
 1094              		.align	2
 1095              		.global	RTC_GetDate
 1096              		.code	16
 1097              		.thumb_func
 1099              	RTC_GetDate:
 1100              	.LFB48:
 988:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 1101              		.loc 1 988 0
 1102              		.cfi_startproc
 1103              	.LVL87:
 1104 0000 70B5     		push	{r4, r5, r6, lr}
 1105              	.LCFI10:
 1106              		.cfi_def_cfa_offset 16
 1107              		.cfi_offset 4, -16
 1108              		.cfi_offset 5, -12
 1109              		.cfi_offset 6, -8
 1110              		.cfi_offset 14, -4
 1111              	.LVL88:
 995:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1112              		.loc 1 995 0
 1113 0002 0F4B     		ldr	r3, .L86
 1114 0004 5B68     		ldr	r3, [r3, #4]
 1115              	.LVL89:
 998:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 1116              		.loc 1 998 0
 1117 0006 1A02     		lsl	r2, r3, #8
 1118 0008 120E     		lsr	r2, r2, #24
 1119 000a CA70     		strb	r2, [r1, #3]
 999:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
 1120              		.loc 1 999 0
 1121 000c DE04     		lsl	r6, r3, #19
 1122 000e F60E     		lsr	r6, r6, #27
 1123 0010 4E70     		strb	r6, [r1, #1]
1000:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
 1124              		.loc 1 1000 0
 1125 0012 3F25     		mov	r5, #63
 1126 0014 1D40     		and	r5, r3
 1127 0016 8D70     		strb	r5, [r1, #2]
1001:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1128              		.loc 1 1001 0
 1129 0018 1B04     		lsl	r3, r3, #16
 1130              	.LVL90:
 1131 001a 5B0F     		lsr	r3, r3, #29
 1132 001c 0B70     		strb	r3, [r1]
1004:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 1133              		.loc 1 1004 0
 1134 001e 0028     		cmp	r0, #0
 1135 0020 0CD1     		bne	.L84
 1136 0022 0C1C     		mov	r4, r1
1007:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 1137              		.loc 1 1007 0
 1138 0024 101C     		mov	r0, r2
 1139              	.LVL91:
 1140 0026 FFF7FEFF 		bl	RTC_Bcd2ToByte
 1141              	.LVL92:
 1142 002a E070     		strb	r0, [r4, #3]
1008:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 1143              		.loc 1 1008 0
 1144 002c 301C     		mov	r0, r6
 1145 002e FFF7FEFF 		bl	RTC_Bcd2ToByte
 1146              	.LVL93:
 1147 0032 6070     		strb	r0, [r4, #1]
1009:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_DateStruct->RTC_WeekDay = (uint8_t)(RTC_DateStruct->RTC_WeekDay);   
 1148              		.loc 1 1009 0
 1149 0034 281C     		mov	r0, r5
 1150 0036 FFF7FEFF 		bl	RTC_Bcd2ToByte
 1151              	.LVL94:
 1152 003a A070     		strb	r0, [r4, #2]
 1153              	.LVL95:
 1154              	.L84:
1012:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1155              		.loc 1 1012 0
 1156              		@ sp needed
 1157 003c 70BD     		pop	{r4, r5, r6, pc}
 1158              	.L87:
 1159 003e C046     		.align	2
 1160              	.L86:
 1161 0040 00280040 		.word	1073752064
 1162              		.cfi_endproc
 1163              	.LFE48:
 1165              		.section	.text.RTC_SetAlarm,"ax",%progbits
 1166              		.align	2
 1167              		.global	RTC_SetAlarm
 1168              		.code	16
 1169              		.thumb_func
 1171              	RTC_SetAlarm:
 1172              	.LFB49:
1048:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 1173              		.loc 1 1048 0
 1174              		.cfi_startproc
 1175              	.LVL96:
 1176 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1177              	.LCFI11:
 1178              		.cfi_def_cfa_offset 24
 1179              		.cfi_offset 3, -24
 1180              		.cfi_offset 4, -20
 1181              		.cfi_offset 5, -16
 1182              		.cfi_offset 6, -12
 1183              		.cfi_offset 7, -8
 1184              		.cfi_offset 14, -4
 1185              	.LVL97:
1057:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 1186              		.loc 1 1057 0
 1187 0002 0028     		cmp	r0, #0
 1188 0004 06D1     		bne	.L89
1059:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 1189              		.loc 1 1059 0
 1190 0006 244B     		ldr	r3, .L94
 1191 0008 9B68     		ldr	r3, [r3, #8]
 1192 000a 5B06     		lsl	r3, r3, #25
 1193 000c 24D4     		bmi	.L90
1066:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
 1194              		.loc 1 1066 0
 1195 000e 0023     		mov	r3, #0
 1196 0010 D370     		strb	r3, [r2, #3]
 1197 0012 21E0     		b	.L90
 1198              	.L89:
1083:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 1199              		.loc 1 1083 0
 1200 0014 204B     		ldr	r3, .L94
 1201 0016 9B68     		ldr	r3, [r3, #8]
 1202 0018 5B06     		lsl	r3, r3, #25
 1203 001a 0BD4     		bmi	.L91
1091:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
 1204              		.loc 1 1091 0
 1205 001c 0023     		mov	r3, #0
 1206 001e D370     		strb	r3, [r2, #3]
 1207 0020 08E0     		b	.L91
 1208              	.LVL98:
 1209              	.L92:
1133:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 1210              		.loc 1 1133 0
 1211 0022 1D4B     		ldr	r3, .L94
 1212 0024 CA22     		mov	r2, #202
 1213 0026 5A62     		str	r2, [r3, #36]
1134:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1214              		.loc 1 1134 0
 1215 0028 773A     		sub	r2, r2, #119
 1216 002a 5A62     		str	r2, [r3, #36]
1137:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1217              		.loc 1 1137 0
 1218 002c D861     		str	r0, [r3, #28]
1140:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 1219              		.loc 1 1140 0
 1220 002e AC32     		add	r2, r2, #172
 1221 0030 5A62     		str	r2, [r3, #36]
 1222 0032 2FE0     		b	.L93
 1223              	.LVL99:
 1224              	.L91:
 1225 0034 5068     		ldr	r0, [r2, #4]
 1226              	.LVL100:
 1227 0036 9368     		ldr	r3, [r2, #8]
 1228 0038 1843     		orr	r0, r3
1115:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 1229              		.loc 1 1115 0
 1230 003a 9378     		ldrb	r3, [r2, #2]
 1231 003c 1843     		orr	r0, r3
1113:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 1232              		.loc 1 1113 0
 1233 003e 1378     		ldrb	r3, [r2]
 1234 0040 1B04     		lsl	r3, r3, #16
 1235 0042 1843     		orr	r0, r3
1114:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 1236              		.loc 1 1114 0
 1237 0044 5378     		ldrb	r3, [r2, #1]
 1238 0046 1B02     		lsl	r3, r3, #8
 1239 0048 1843     		orr	r0, r3
1116:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 1240              		.loc 1 1116 0
 1241 004a D378     		ldrb	r3, [r2, #3]
 1242 004c 1B04     		lsl	r3, r3, #16
 1243 004e 1843     		orr	r0, r3
1117:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 1244              		.loc 1 1117 0
 1245 0050 137B     		ldrb	r3, [r2, #12]
 1246 0052 1B06     		lsl	r3, r3, #24
1113:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 1247              		.loc 1 1113 0
 1248 0054 1843     		orr	r0, r3
 1249              	.LVL101:
 1250 0056 E4E7     		b	.L92
 1251              	.LVL102:
 1252              	.L90:
 1253 0058 141C     		mov	r4, r2
1123:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 1254              		.loc 1 1123 0
 1255 005a 1078     		ldrb	r0, [r2]
 1256              	.LVL103:
 1257 005c FFF7FEFF 		bl	RTC_ByteToBcd2
 1258              	.LVL104:
 1259 0060 061C     		mov	r6, r0
1124:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 1260              		.loc 1 1124 0
 1261 0062 6078     		ldrb	r0, [r4, #1]
 1262 0064 FFF7FEFF 		bl	RTC_ByteToBcd2
 1263              	.LVL105:
 1264 0068 051C     		mov	r5, r0
1125:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 1265              		.loc 1 1125 0
 1266 006a A078     		ldrb	r0, [r4, #2]
 1267 006c FFF7FEFF 		bl	RTC_ByteToBcd2
 1268              	.LVL106:
 1269 0070 071C     		mov	r7, r0
1127:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 1270              		.loc 1 1127 0
 1271 0072 207B     		ldrb	r0, [r4, #12]
 1272 0074 FFF7FEFF 		bl	RTC_ByteToBcd2
 1273              	.LVL107:
 1274 0078 6368     		ldr	r3, [r4, #4]
 1275 007a A268     		ldr	r2, [r4, #8]
 1276 007c 1343     		orr	r3, r2
1126:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 1277              		.loc 1 1126 0
 1278 007e E278     		ldrb	r2, [r4, #3]
 1279 0080 1204     		lsl	r2, r2, #16
 1280 0082 1343     		orr	r3, r2
 1281 0084 3B43     		orr	r3, r7
1123:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 1282              		.loc 1 1123 0
 1283 0086 3604     		lsl	r6, r6, #16
 1284 0088 1E43     		orr	r6, r3
1124:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 1285              		.loc 1 1124 0
 1286 008a 2D02     		lsl	r5, r5, #8
 1287 008c 3543     		orr	r5, r6
1127:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 1288              		.loc 1 1127 0
 1289 008e 0006     		lsl	r0, r0, #24
1123:.\StdPeriphLib\src/stm32f0xx_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 1290              		.loc 1 1123 0
 1291 0090 2843     		orr	r0, r5
 1292              	.LVL108:
 1293 0092 C6E7     		b	.L92
 1294              	.LVL109:
 1295              	.L93:
1141:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1296              		.loc 1 1141 0
 1297              		@ sp needed
 1298 0094 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1299              	.L95:
 1300 0096 C046     		.align	2
 1301              	.L94:
 1302 0098 00280040 		.word	1073752064
 1303              		.cfi_endproc
 1304              	.LFE49:
 1306              		.section	.text.RTC_AlarmStructInit,"ax",%progbits
 1307              		.align	2
 1308              		.global	RTC_AlarmStructInit
 1309              		.code	16
 1310              		.thumb_func
 1312              	RTC_AlarmStructInit:
 1313              	.LFB50:
1152:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Alarm Time Settings : Time = 00h:00mn:00sec */
 1314              		.loc 1 1152 0
 1315              		.cfi_startproc
 1316              	.LVL110:
1154:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
 1317              		.loc 1 1154 0
 1318 0000 0023     		mov	r3, #0
 1319 0002 C370     		strb	r3, [r0, #3]
1155:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
 1320              		.loc 1 1155 0
 1321 0004 0370     		strb	r3, [r0]
1156:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
 1322              		.loc 1 1156 0
 1323 0006 4370     		strb	r3, [r0, #1]
1157:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1324              		.loc 1 1157 0
 1325 0008 8370     		strb	r3, [r0, #2]
1160:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
 1326              		.loc 1 1160 0
 1327 000a 8360     		str	r3, [r0, #8]
1161:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1328              		.loc 1 1161 0
 1329 000c 0122     		mov	r2, #1
 1330 000e 0273     		strb	r2, [r0, #12]
1164:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 1331              		.loc 1 1164 0
 1332 0010 4360     		str	r3, [r0, #4]
1165:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1333              		.loc 1 1165 0
 1334              		@ sp needed
 1335 0012 7047     		bx	lr
 1336              		.cfi_endproc
 1337              	.LFE50:
 1339              		.section	.text.RTC_GetAlarm,"ax",%progbits
 1340              		.align	2
 1341              		.global	RTC_GetAlarm
 1342              		.code	16
 1343              		.thumb_func
 1345              	RTC_GetAlarm:
 1346              	.LFB51:
1181:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 1347              		.loc 1 1181 0
 1348              		.cfi_startproc
 1349              	.LVL111:
 1350 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1351              	.LCFI12:
 1352              		.cfi_def_cfa_offset 20
 1353              		.cfi_offset 4, -20
 1354              		.cfi_offset 5, -16
 1355              		.cfi_offset 6, -12
 1356              		.cfi_offset 7, -8
 1357              		.cfi_offset 14, -4
 1358 0002 4746     		mov	r7, r8
 1359 0004 80B4     		push	{r7}
 1360              	.LCFI13:
 1361              		.cfi_def_cfa_offset 24
 1362              		.cfi_offset 8, -24
 1363              	.LVL112:
1189:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1364              		.loc 1 1189 0
 1365 0006 1A4B     		ldr	r3, .L99
 1366 0008 DB69     		ldr	r3, [r3, #28]
 1367              	.LVL113:
1192:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                                      RTC_ALRMAR_HU)) >> 16);
 1368              		.loc 1 1192 0
 1369 000a 9F02     		lsl	r7, r3, #10
 1370 000c BF0E     		lsr	r7, r7, #26
 1371 000e 1770     		strb	r7, [r2]
1194:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                                      RTC_ALRMAR_MNU)) >> 8);
 1372              		.loc 1 1194 0
 1373 0010 5E04     		lsl	r6, r3, #17
 1374 0012 760E     		lsr	r6, r6, #25
 1375 0014 5670     		strb	r6, [r2, #1]
1196:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                                      RTC_ALRMAR_SU));
 1376              		.loc 1 1196 0
 1377 0016 7F25     		mov	r5, #127
 1378 0018 1D40     		and	r5, r3
 1379 001a 9570     		strb	r5, [r2, #2]
1198:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 
 1380              		.loc 1 1198 0
 1381 001c 8021     		mov	r1, #128
 1382              	.LVL114:
 1383 001e C903     		lsl	r1, r1, #15
 1384 0020 1940     		and	r1, r3
 1385 0022 090C     		lsr	r1, r1, #16
 1386 0024 D170     		strb	r1, [r2, #3]
1199:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 1387              		.loc 1 1199 0
 1388 0026 9C00     		lsl	r4, r3, #2
 1389 0028 A40E     		lsr	r4, r4, #26
 1390 002a 1473     		strb	r4, [r2, #12]
1200:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
 1391              		.loc 1 1200 0
 1392 002c 8021     		mov	r1, #128
 1393 002e C905     		lsl	r1, r1, #23
 1394 0030 1940     		and	r1, r3
 1395 0032 9160     		str	r1, [r2, #8]
1201:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1396              		.loc 1 1201 0
 1397 0034 0F49     		ldr	r1, .L99+4
 1398 0036 0B40     		and	r3, r1
 1399              	.LVL115:
 1400 0038 5360     		str	r3, [r2, #4]
1203:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 1401              		.loc 1 1203 0
 1402 003a 0028     		cmp	r0, #0
 1403 003c 14D1     		bne	.L97
 1404 003e 9046     		mov	r8, r2
1205:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                                         RTC_AlarmTime.RTC_Hours);
 1405              		.loc 1 1205 0
 1406 0040 381C     		mov	r0, r7
 1407              	.LVL116:
 1408 0042 FFF7FEFF 		bl	RTC_Bcd2ToByte
 1409              	.LVL117:
 1410 0046 4346     		mov	r3, r8
 1411 0048 1870     		strb	r0, [r3]
1207:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                                         RTC_AlarmTime.RTC_Minutes);
 1412              		.loc 1 1207 0
 1413 004a 301C     		mov	r0, r6
 1414 004c FFF7FEFF 		bl	RTC_Bcd2ToByte
 1415              	.LVL118:
 1416 0050 4346     		mov	r3, r8
 1417 0052 5870     		strb	r0, [r3, #1]
1209:.\StdPeriphLib\src/stm32f0xx_rtc.c ****                                                         RTC_AlarmTime.RTC_Seconds);
 1418              		.loc 1 1209 0
 1419 0054 281C     		mov	r0, r5
 1420 0056 FFF7FEFF 		bl	RTC_Bcd2ToByte
 1421              	.LVL119:
 1422 005a 4346     		mov	r3, r8
 1423 005c 9870     		strb	r0, [r3, #2]
1211:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }  
 1424              		.loc 1 1211 0
 1425 005e 201C     		mov	r0, r4
 1426 0060 FFF7FEFF 		bl	RTC_Bcd2ToByte
 1427              	.LVL120:
 1428 0064 4346     		mov	r3, r8
 1429 0066 1873     		strb	r0, [r3, #12]
 1430              	.LVL121:
 1431              	.L97:
1213:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1432              		.loc 1 1213 0
 1433              		@ sp needed
 1434 0068 04BC     		pop	{r2}
 1435 006a 9046     		mov	r8, r2
 1436 006c F0BD     		pop	{r4, r5, r6, r7, pc}
 1437              	.L100:
 1438 006e C046     		.align	2
 1439              	.L99:
 1440 0070 00280040 		.word	1073752064
 1441 0074 80808080 		.word	-2139062144
 1442              		.cfi_endproc
 1443              	.LFE51:
 1445              		.section	.text.RTC_AlarmCmd,"ax",%progbits
 1446              		.align	2
 1447              		.global	RTC_AlarmCmd
 1448              		.code	16
 1449              		.thumb_func
 1451              	RTC_AlarmCmd:
 1452              	.LFB52:
1227:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   __IO uint32_t alarmcounter = 0x00;
 1453              		.loc 1 1227 0
 1454              		.cfi_startproc
 1455              	.LVL122:
 1456 0000 10B5     		push	{r4, lr}
 1457              	.LCFI14:
 1458              		.cfi_def_cfa_offset 8
 1459              		.cfi_offset 4, -8
 1460              		.cfi_offset 14, -4
 1461 0002 82B0     		sub	sp, sp, #8
 1462              	.LCFI15:
 1463              		.cfi_def_cfa_offset 16
1228:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t alarmstatus = 0x00;
 1464              		.loc 1 1228 0
 1465 0004 0023     		mov	r3, #0
 1466 0006 0193     		str	r3, [sp, #4]
 1467              	.LVL123:
1237:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 1468              		.loc 1 1237 0
 1469 0008 154B     		ldr	r3, .L107
 1470 000a CA22     		mov	r2, #202
 1471 000c 5A62     		str	r2, [r3, #36]
1238:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1472              		.loc 1 1238 0
 1473 000e 773A     		sub	r2, r2, #119
 1474 0010 5A62     		str	r2, [r3, #36]
1241:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 1475              		.loc 1 1241 0
 1476 0012 0029     		cmp	r1, #0
 1477 0014 05D0     		beq	.L102
1243:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1478              		.loc 1 1243 0
 1479 0016 1A1C     		mov	r2, r3
 1480 0018 9B68     		ldr	r3, [r3, #8]
 1481 001a 1843     		orr	r0, r3
 1482              	.LVL124:
 1483 001c 9060     		str	r0, [r2, #8]
 1484              	.LVL125:
1245:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 1485              		.loc 1 1245 0
 1486 001e 0120     		mov	r0, #1
 1487 0020 18E0     		b	.L103
 1488              	.LVL126:
 1489              	.L102:
1250:.\StdPeriphLib\src/stm32f0xx_rtc.c ****    
 1490              		.loc 1 1250 0
 1491 0022 0F4A     		ldr	r2, .L107
 1492 0024 9368     		ldr	r3, [r2, #8]
 1493 0026 8343     		bic	r3, r0
 1494 0028 9360     		str	r3, [r2, #8]
1255:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       alarmcounter++;  
 1495              		.loc 1 1255 0
 1496 002a 000A     		lsr	r0, r0, #8
 1497              	.LVL127:
 1498 002c 141C     		mov	r4, r2
1257:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 1499              		.loc 1 1257 0
 1500 002e 8021     		mov	r1, #128
 1501              	.LVL128:
 1502 0030 C901     		lsl	r1, r1, #7
 1503              	.LVL129:
 1504              	.L105:
1255:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       alarmcounter++;  
 1505              		.loc 1 1255 0 discriminator 2
 1506 0032 E368     		ldr	r3, [r4, #12]
 1507 0034 0340     		and	r3, r0
 1508 0036 1A1C     		mov	r2, r3
 1509              	.LVL130:
1256:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
 1510              		.loc 1 1256 0 discriminator 2
 1511 0038 019B     		ldr	r3, [sp, #4]
 1512 003a 0133     		add	r3, r3, #1
 1513 003c 0193     		str	r3, [sp, #4]
1257:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 1514              		.loc 1 1257 0 discriminator 2
 1515 003e 019B     		ldr	r3, [sp, #4]
 1516 0040 8B42     		cmp	r3, r1
 1517 0042 01D0     		beq	.L104
1257:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 1518              		.loc 1 1257 0 is_stmt 0 discriminator 1
 1519 0044 002A     		cmp	r2, #0
 1520 0046 F4D0     		beq	.L105
 1521              	.L104:
1259:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 1522              		.loc 1 1259 0 is_stmt 1
 1523 0048 054B     		ldr	r3, .L107
 1524 004a DB68     		ldr	r3, [r3, #12]
 1525 004c 1840     		and	r0, r3
 1526 004e 431E     		sub	r3, r0, #1
 1527 0050 9841     		sbc	r0, r0, r3
1245:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 1528              		.loc 1 1245 0
 1529 0052 C0B2     		uxtb	r0, r0
 1530              	.LVL131:
 1531              	.L103:
1270:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 1532              		.loc 1 1270 0
 1533 0054 FF22     		mov	r2, #255
 1534 0056 024B     		ldr	r3, .L107
 1535 0058 5A62     		str	r2, [r3, #36]
1273:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1536              		.loc 1 1273 0
 1537 005a 02B0     		add	sp, sp, #8
 1538              		@ sp needed
 1539 005c 10BD     		pop	{r4, pc}
 1540              	.L108:
 1541 005e C046     		.align	2
 1542              	.L107:
 1543 0060 00280040 		.word	1073752064
 1544              		.cfi_endproc
 1545              	.LFE52:
 1547              		.section	.text.RTC_AlarmSubSecondConfig,"ax",%progbits
 1548              		.align	2
 1549              		.global	RTC_AlarmSubSecondConfig
 1550              		.code	16
 1551              		.thumb_func
 1553              	RTC_AlarmSubSecondConfig:
 1554              	.LFB53:
1319:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 1555              		.loc 1 1319 0
 1556              		.cfi_startproc
 1557              	.LVL132:
1328:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 1558              		.loc 1 1328 0
 1559 0000 054B     		ldr	r3, .L110
 1560 0002 CA20     		mov	r0, #202
 1561              	.LVL133:
 1562 0004 5862     		str	r0, [r3, #36]
1329:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 1563              		.loc 1 1329 0
 1564 0006 7738     		sub	r0, r0, #119
 1565 0008 5862     		str	r0, [r3, #36]
1332:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 1566              		.loc 1 1332 0
 1567 000a 1206     		lsl	r2, r2, #24
 1568              	.LVL134:
 1569 000c 1143     		orr	r1, r2
 1570              	.LVL135:
1335:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1571              		.loc 1 1335 0
 1572 000e 5964     		str	r1, [r3, #68]
1338:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1573              		.loc 1 1338 0
 1574 0010 FF22     		mov	r2, #255
 1575 0012 5A62     		str	r2, [r3, #36]
1340:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1576              		.loc 1 1340 0
 1577              		@ sp needed
 1578 0014 7047     		bx	lr
 1579              	.L111:
 1580 0016 C046     		.align	2
 1581              	.L110:
 1582 0018 00280040 		.word	1073752064
 1583              		.cfi_endproc
 1584              	.LFE53:
 1586              		.section	.text.RTC_GetAlarmSubSecond,"ax",%progbits
 1587              		.align	2
 1588              		.global	RTC_GetAlarmSubSecond
 1589              		.code	16
 1590              		.thumb_func
 1592              	RTC_GetAlarmSubSecond:
 1593              	.LFB54:
1351:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 1594              		.loc 1 1351 0
 1595              		.cfi_startproc
 1596              	.LVL136:
1355:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1597              		.loc 1 1355 0
 1598 0000 024B     		ldr	r3, .L113
 1599 0002 586C     		ldr	r0, [r3, #68]
 1600              	.LVL137:
 1601 0004 4004     		lsl	r0, r0, #17
 1602              	.LVL138:
 1603 0006 400C     		lsr	r0, r0, #17
1358:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1604              		.loc 1 1358 0
 1605              		@ sp needed
 1606 0008 7047     		bx	lr
 1607              	.L114:
 1608 000a C046     		.align	2
 1609              	.L113:
 1610 000c 00280040 		.word	1073752064
 1611              		.cfi_endproc
 1612              	.LFE54:
 1614              		.section	.text.RTC_WakeUpClockConfig,"ax",%progbits
 1615              		.align	2
 1616              		.global	RTC_WakeUpClockConfig
 1617              		.code	16
 1618              		.thumb_func
 1620              	RTC_WakeUpClockConfig:
 1621              	.LFB55:
1394:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 1622              		.loc 1 1394 0
 1623              		.cfi_startproc
 1624              	.LVL139:
1399:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 1625              		.loc 1 1399 0
 1626 0000 074B     		ldr	r3, .L116
 1627 0002 CA22     		mov	r2, #202
 1628 0004 5A62     		str	r2, [r3, #36]
1400:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1629              		.loc 1 1400 0
 1630 0006 773A     		sub	r2, r2, #119
 1631 0008 5A62     		str	r2, [r3, #36]
1403:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1632              		.loc 1 1403 0
 1633 000a 9A68     		ldr	r2, [r3, #8]
 1634 000c 0721     		mov	r1, #7
 1635 000e 8A43     		bic	r2, r1
 1636 0010 9A60     		str	r2, [r3, #8]
1406:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 1637              		.loc 1 1406 0
 1638 0012 9A68     		ldr	r2, [r3, #8]
 1639 0014 1043     		orr	r0, r2
 1640              	.LVL140:
 1641 0016 9860     		str	r0, [r3, #8]
1409:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 1642              		.loc 1 1409 0
 1643 0018 FF22     		mov	r2, #255
 1644 001a 5A62     		str	r2, [r3, #36]
1410:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1645              		.loc 1 1410 0
 1646              		@ sp needed
 1647 001c 7047     		bx	lr
 1648              	.L117:
 1649 001e C046     		.align	2
 1650              	.L116:
 1651 0020 00280040 		.word	1073752064
 1652              		.cfi_endproc
 1653              	.LFE55:
 1655              		.section	.text.RTC_SetWakeUpCounter,"ax",%progbits
 1656              		.align	2
 1657              		.global	RTC_SetWakeUpCounter
 1658              		.code	16
 1659              		.thumb_func
 1661              	RTC_SetWakeUpCounter:
 1662              	.LFB56:
1422:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 1663              		.loc 1 1422 0
 1664              		.cfi_startproc
 1665              	.LVL141:
1427:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 1666              		.loc 1 1427 0
 1667 0000 044B     		ldr	r3, .L119
 1668 0002 CA22     		mov	r2, #202
 1669 0004 5A62     		str	r2, [r3, #36]
1428:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 1670              		.loc 1 1428 0
 1671 0006 773A     		sub	r2, r2, #119
 1672 0008 5A62     		str	r2, [r3, #36]
1431:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 1673              		.loc 1 1431 0
 1674 000a 5861     		str	r0, [r3, #20]
1434:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 1675              		.loc 1 1434 0
 1676 000c AC32     		add	r2, r2, #172
 1677 000e 5A62     		str	r2, [r3, #36]
1435:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1678              		.loc 1 1435 0
 1679              		@ sp needed
 1680 0010 7047     		bx	lr
 1681              	.L120:
 1682 0012 C046     		.align	2
 1683              	.L119:
 1684 0014 00280040 		.word	1073752064
 1685              		.cfi_endproc
 1686              	.LFE56:
 1688              		.section	.text.RTC_GetWakeUpCounter,"ax",%progbits
 1689              		.align	2
 1690              		.global	RTC_GetWakeUpCounter
 1691              		.code	16
 1692              		.thumb_func
 1694              	RTC_GetWakeUpCounter:
 1695              	.LFB57:
1444:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get the counter value */
 1696              		.loc 1 1444 0
 1697              		.cfi_startproc
1446:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 1698              		.loc 1 1446 0
 1699 0000 024B     		ldr	r3, .L122
 1700 0002 5869     		ldr	r0, [r3, #20]
 1701 0004 0004     		lsl	r0, r0, #16
 1702 0006 000C     		lsr	r0, r0, #16
1447:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1703              		.loc 1 1447 0
 1704              		@ sp needed
 1705 0008 7047     		bx	lr
 1706              	.L123:
 1707 000a C046     		.align	2
 1708              	.L122:
 1709 000c 00280040 		.word	1073752064
 1710              		.cfi_endproc
 1711              	.LFE57:
 1713              		.section	.text.RTC_WakeUpCmd,"ax",%progbits
 1714              		.align	2
 1715              		.global	RTC_WakeUpCmd
 1716              		.code	16
 1717              		.thumb_func
 1719              	RTC_WakeUpCmd:
 1720              	.LFB58:
1457:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   __IO uint32_t wutcounter = 0x00;
 1721              		.loc 1 1457 0
 1722              		.cfi_startproc
 1723              	.LVL142:
 1724 0000 10B5     		push	{r4, lr}
 1725              	.LCFI16:
 1726              		.cfi_def_cfa_offset 8
 1727              		.cfi_offset 4, -8
 1728              		.cfi_offset 14, -4
 1729 0002 82B0     		sub	sp, sp, #8
 1730              	.LCFI17:
 1731              		.cfi_def_cfa_offset 16
1458:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t wutwfstatus = 0x00;
 1732              		.loc 1 1458 0
 1733 0004 0023     		mov	r3, #0
 1734 0006 0193     		str	r3, [sp, #4]
 1735              	.LVL143:
1466:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 1736              		.loc 1 1466 0
 1737 0008 154B     		ldr	r3, .L130
 1738 000a CA22     		mov	r2, #202
 1739 000c 5A62     		str	r2, [r3, #36]
1467:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1740              		.loc 1 1467 0
 1741 000e 773A     		sub	r2, r2, #119
 1742 0010 5A62     		str	r2, [r3, #36]
1469:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 1743              		.loc 1 1469 0
 1744 0012 0028     		cmp	r0, #0
 1745 0014 07D0     		beq	.L125
1472:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     status = SUCCESS;    
 1746              		.loc 1 1472 0
 1747 0016 1A1C     		mov	r2, r3
 1748 0018 9B68     		ldr	r3, [r3, #8]
 1749 001a 8021     		mov	r1, #128
 1750 001c C900     		lsl	r1, r1, #3
 1751 001e 0B43     		orr	r3, r1
 1752 0020 9360     		str	r3, [r2, #8]
 1753              	.LVL144:
1473:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 1754              		.loc 1 1473 0
 1755 0022 0120     		mov	r0, #1
 1756              	.LVL145:
 1757 0024 17E0     		b	.L126
 1758              	.LVL146:
 1759              	.L125:
1478:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
 1760              		.loc 1 1478 0
 1761 0026 0E4A     		ldr	r2, .L130
 1762 0028 9168     		ldr	r1, [r2, #8]
 1763 002a 0E4B     		ldr	r3, .L130+4
 1764 002c 0B40     		and	r3, r1
 1765 002e 9360     		str	r3, [r2, #8]
1482:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       wutcounter++;  
 1766              		.loc 1 1482 0
 1767 0030 141C     		mov	r4, r2
 1768 0032 0420     		mov	r0, #4
 1769              	.LVL147:
1484:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 1770              		.loc 1 1484 0
 1771 0034 8021     		mov	r1, #128
 1772 0036 C901     		lsl	r1, r1, #7
 1773              	.LVL148:
 1774              	.L128:
1482:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       wutcounter++;  
 1775              		.loc 1 1482 0 discriminator 2
 1776 0038 E368     		ldr	r3, [r4, #12]
 1777 003a 0340     		and	r3, r0
 1778 003c 1A1C     		mov	r2, r3
 1779              	.LVL149:
1483:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 1780              		.loc 1 1483 0 discriminator 2
 1781 003e 019B     		ldr	r3, [sp, #4]
 1782 0040 0133     		add	r3, r3, #1
 1783 0042 0193     		str	r3, [sp, #4]
1484:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 1784              		.loc 1 1484 0 discriminator 2
 1785 0044 019B     		ldr	r3, [sp, #4]
 1786 0046 8B42     		cmp	r3, r1
 1787 0048 01D0     		beq	.L127
1484:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 1788              		.loc 1 1484 0 is_stmt 0 discriminator 1
 1789 004a 002A     		cmp	r2, #0
 1790 004c F4D0     		beq	.L128
 1791              	.L127:
1486:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 1792              		.loc 1 1486 0 is_stmt 1
 1793 004e 044B     		ldr	r3, .L130
 1794 0050 D868     		ldr	r0, [r3, #12]
 1795 0052 4007     		lsl	r0, r0, #29
1473:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 1796              		.loc 1 1473 0
 1797 0054 C00F     		lsr	r0, r0, #31
 1798              	.LVL150:
 1799              	.L126:
1497:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 1800              		.loc 1 1497 0
 1801 0056 FF22     		mov	r2, #255
 1802 0058 014B     		ldr	r3, .L130
 1803 005a 5A62     		str	r2, [r3, #36]
1500:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1804              		.loc 1 1500 0
 1805 005c 02B0     		add	sp, sp, #8
 1806              		@ sp needed
 1807 005e 10BD     		pop	{r4, pc}
 1808              	.L131:
 1809              		.align	2
 1810              	.L130:
 1811 0060 00280040 		.word	1073752064
 1812 0064 FFFBFFFF 		.word	-1025
 1813              		.cfi_endproc
 1814              	.LFE58:
 1816              		.section	.text.RTC_DayLightSavingConfig,"ax",%progbits
 1817              		.align	2
 1818              		.global	RTC_DayLightSavingConfig
 1819              		.code	16
 1820              		.thumb_func
 1822              	RTC_DayLightSavingConfig:
 1823              	.LFB59:
1535:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 1824              		.loc 1 1535 0
 1825              		.cfi_startproc
 1826              	.LVL151:
 1827 0000 10B5     		push	{r4, lr}
 1828              	.LCFI18:
 1829              		.cfi_def_cfa_offset 8
 1830              		.cfi_offset 4, -8
 1831              		.cfi_offset 14, -4
1541:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 1832              		.loc 1 1541 0
 1833 0002 084B     		ldr	r3, .L133
 1834 0004 CA22     		mov	r2, #202
 1835 0006 5A62     		str	r2, [r3, #36]
1542:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1836              		.loc 1 1542 0
 1837 0008 773A     		sub	r2, r2, #119
 1838 000a 5A62     		str	r2, [r3, #36]
1545:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1839              		.loc 1 1545 0
 1840 000c 9C68     		ldr	r4, [r3, #8]
 1841 000e 064A     		ldr	r2, .L133+4
 1842 0010 2240     		and	r2, r4
 1843 0012 9A60     		str	r2, [r3, #8]
1548:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1844              		.loc 1 1548 0
 1845 0014 9A68     		ldr	r2, [r3, #8]
 1846 0016 1143     		orr	r1, r2
 1847              	.LVL152:
 1848 0018 0843     		orr	r0, r1
 1849              	.LVL153:
 1850 001a 9860     		str	r0, [r3, #8]
1551:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 1851              		.loc 1 1551 0
 1852 001c FF22     		mov	r2, #255
 1853 001e 5A62     		str	r2, [r3, #36]
1552:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1854              		.loc 1 1552 0
 1855              		@ sp needed
 1856 0020 10BD     		pop	{r4, pc}
 1857              	.L134:
 1858 0022 C046     		.align	2
 1859              	.L133:
 1860 0024 00280040 		.word	1073752064
 1861 0028 FFFFFBFF 		.word	-262145
 1862              		.cfi_endproc
 1863              	.LFE59:
 1865              		.section	.text.RTC_GetStoreOperation,"ax",%progbits
 1866              		.align	2
 1867              		.global	RTC_GetStoreOperation
 1868              		.code	16
 1869              		.thumb_func
 1871              	RTC_GetStoreOperation:
 1872              	.LFB60:
1562:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   return (RTC->CR & RTC_CR_BCK);
 1873              		.loc 1 1562 0
 1874              		.cfi_startproc
1563:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 1875              		.loc 1 1563 0
 1876 0000 024B     		ldr	r3, .L136
 1877 0002 9868     		ldr	r0, [r3, #8]
 1878 0004 8023     		mov	r3, #128
 1879 0006 DB02     		lsl	r3, r3, #11
 1880 0008 1840     		and	r0, r3
1564:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1881              		.loc 1 1564 0
 1882              		@ sp needed
 1883 000a 7047     		bx	lr
 1884              	.L137:
 1885              		.align	2
 1886              	.L136:
 1887 000c 00280040 		.word	1073752064
 1888              		.cfi_endproc
 1889              	.LFE60:
 1891              		.section	.text.RTC_OutputConfig,"ax",%progbits
 1892              		.align	2
 1893              		.global	RTC_OutputConfig
 1894              		.code	16
 1895              		.thumb_func
 1897              	RTC_OutputConfig:
 1898              	.LFB61:
1599:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 1899              		.loc 1 1599 0
 1900              		.cfi_startproc
 1901              	.LVL154:
 1902 0000 10B5     		push	{r4, lr}
 1903              	.LCFI19:
 1904              		.cfi_def_cfa_offset 8
 1905              		.cfi_offset 4, -8
 1906              		.cfi_offset 14, -4
1605:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 1907              		.loc 1 1605 0
 1908 0002 084B     		ldr	r3, .L139
 1909 0004 CA22     		mov	r2, #202
 1910 0006 5A62     		str	r2, [r3, #36]
1606:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1911              		.loc 1 1606 0
 1912 0008 773A     		sub	r2, r2, #119
 1913 000a 5A62     		str	r2, [r3, #36]
1609:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1914              		.loc 1 1609 0
 1915 000c 9C68     		ldr	r4, [r3, #8]
 1916 000e 064A     		ldr	r2, .L139+4
 1917 0010 2240     		and	r2, r4
 1918 0012 9A60     		str	r2, [r3, #8]
1612:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1919              		.loc 1 1612 0
 1920 0014 9A68     		ldr	r2, [r3, #8]
 1921 0016 1143     		orr	r1, r2
 1922              	.LVL155:
 1923 0018 0843     		orr	r0, r1
 1924              	.LVL156:
 1925 001a 9860     		str	r0, [r3, #8]
1615:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 1926              		.loc 1 1615 0
 1927 001c FF22     		mov	r2, #255
 1928 001e 5A62     		str	r2, [r3, #36]
1616:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1929              		.loc 1 1616 0
 1930              		@ sp needed
 1931 0020 10BD     		pop	{r4, pc}
 1932              	.L140:
 1933 0022 C046     		.align	2
 1934              	.L139:
 1935 0024 00280040 		.word	1073752064
 1936 0028 FFFF8FFF 		.word	-7340033
 1937              		.cfi_endproc
 1938              	.LFE61:
 1940              		.section	.text.RTC_CalibOutputCmd,"ax",%progbits
 1941              		.align	2
 1942              		.global	RTC_CalibOutputCmd
 1943              		.code	16
 1944              		.thumb_func
 1946              	RTC_CalibOutputCmd:
 1947              	.LFB62:
1641:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 1948              		.loc 1 1641 0
 1949              		.cfi_startproc
 1950              	.LVL157:
1646:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 1951              		.loc 1 1646 0
 1952 0000 0B4B     		ldr	r3, .L144
 1953 0002 CA22     		mov	r2, #202
 1954 0004 5A62     		str	r2, [r3, #36]
1647:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 1955              		.loc 1 1647 0
 1956 0006 773A     		sub	r2, r2, #119
 1957 0008 5A62     		str	r2, [r3, #36]
1649:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 1958              		.loc 1 1649 0
 1959 000a 0028     		cmp	r0, #0
 1960 000c 06D0     		beq	.L142
1652:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 1961              		.loc 1 1652 0
 1962 000e 1A1C     		mov	r2, r3
 1963 0010 9B68     		ldr	r3, [r3, #8]
 1964 0012 8021     		mov	r1, #128
 1965 0014 0904     		lsl	r1, r1, #16
 1966 0016 0B43     		orr	r3, r1
 1967 0018 9360     		str	r3, [r2, #8]
 1968 001a 04E0     		b	.L143
 1969              	.L142:
1657:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 1970              		.loc 1 1657 0
 1971 001c 044A     		ldr	r2, .L144
 1972 001e 9168     		ldr	r1, [r2, #8]
 1973 0020 044B     		ldr	r3, .L144+4
 1974 0022 0B40     		and	r3, r1
 1975 0024 9360     		str	r3, [r2, #8]
 1976              	.L143:
1661:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 1977              		.loc 1 1661 0
 1978 0026 FF22     		mov	r2, #255
 1979 0028 014B     		ldr	r3, .L144
 1980 002a 5A62     		str	r2, [r3, #36]
1662:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 1981              		.loc 1 1662 0
 1982              		@ sp needed
 1983 002c 7047     		bx	lr
 1984              	.L145:
 1985 002e C046     		.align	2
 1986              	.L144:
 1987 0030 00280040 		.word	1073752064
 1988 0034 FFFF7FFF 		.word	-8388609
 1989              		.cfi_endproc
 1990              	.LFE62:
 1992              		.section	.text.RTC_CalibOutputConfig,"ax",%progbits
 1993              		.align	2
 1994              		.global	RTC_CalibOutputConfig
 1995              		.code	16
 1996              		.thumb_func
 1998              	RTC_CalibOutputConfig:
 1999              	.LFB63:
1673:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 2000              		.loc 1 1673 0
 2001              		.cfi_startproc
 2002              	.LVL158:
1678:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 2003              		.loc 1 1678 0
 2004 0000 074B     		ldr	r3, .L147
 2005 0002 CA22     		mov	r2, #202
 2006 0004 5A62     		str	r2, [r3, #36]
1679:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 2007              		.loc 1 1679 0
 2008 0006 773A     		sub	r2, r2, #119
 2009 0008 5A62     		str	r2, [r3, #36]
1682:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2010              		.loc 1 1682 0
 2011 000a 9968     		ldr	r1, [r3, #8]
 2012 000c 054A     		ldr	r2, .L147+4
 2013 000e 0A40     		and	r2, r1
 2014 0010 9A60     		str	r2, [r3, #8]
1685:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2015              		.loc 1 1685 0
 2016 0012 9A68     		ldr	r2, [r3, #8]
 2017 0014 1043     		orr	r0, r2
 2018              	.LVL159:
 2019 0016 9860     		str	r0, [r3, #8]
1688:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 2020              		.loc 1 1688 0
 2021 0018 FF22     		mov	r2, #255
 2022 001a 5A62     		str	r2, [r3, #36]
1689:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2023              		.loc 1 1689 0
 2024              		@ sp needed
 2025 001c 7047     		bx	lr
 2026              	.L148:
 2027 001e C046     		.align	2
 2028              	.L147:
 2029 0020 00280040 		.word	1073752064
 2030 0024 FFFFF7FF 		.word	-524289
 2031              		.cfi_endproc
 2032              	.LFE63:
 2034              		.section	.text.RTC_SmoothCalibConfig,"ax",%progbits
 2035              		.align	2
 2036              		.global	RTC_SmoothCalibConfig
 2037              		.code	16
 2038              		.thumb_func
 2040              	RTC_SmoothCalibConfig:
 2041              	.LFB64:
1711:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
 2042              		.loc 1 1711 0
 2043              		.cfi_startproc
 2044              	.LVL160:
 2045 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2046              	.LCFI20:
 2047              		.cfi_def_cfa_offset 20
 2048              		.cfi_offset 4, -20
 2049              		.cfi_offset 5, -16
 2050              		.cfi_offset 6, -12
 2051              		.cfi_offset 7, -8
 2052              		.cfi_offset 14, -4
 2053 0002 071C     		mov	r7, r0
 2054              	.LVL161:
1721:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 2055              		.loc 1 1721 0
 2056 0004 124B     		ldr	r3, .L155
 2057 0006 CA20     		mov	r0, #202
 2058              	.LVL162:
 2059 0008 5862     		str	r0, [r3, #36]
1722:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 2060              		.loc 1 1722 0
 2061 000a 7738     		sub	r0, r0, #119
 2062 000c 5862     		str	r0, [r3, #36]
1725:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2063              		.loc 1 1725 0
 2064 000e DB68     		ldr	r3, [r3, #12]
 2065 0010 DB03     		lsl	r3, r3, #15
 2066 0012 0ED5     		bpl	.L150
1728:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 2067              		.loc 1 1728 0
 2068 0014 0E4B     		ldr	r3, .L155
 2069 0016 DB68     		ldr	r3, [r3, #12]
 2070 0018 DB03     		lsl	r3, r3, #15
 2071 001a 0AD5     		bpl	.L150
 2072 001c 8023     		mov	r3, #128
 2073 001e 5B01     		lsl	r3, r3, #5
 2074 0020 0B4E     		ldr	r6, .L155
 2075 0022 8025     		mov	r5, #128
 2076 0024 6D02     		lsl	r5, r5, #9
 2077              	.LVL163:
 2078              	.L151:
 2079 0026 F468     		ldr	r4, [r6, #12]
 2080 0028 2C42     		tst	r4, r5
 2081 002a 02D0     		beq	.L150
 2082 002c 013B     		sub	r3, r3, #1
 2083              	.LVL164:
1728:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 2084              		.loc 1 1728 0 is_stmt 0 discriminator 1
 2085 002e 002B     		cmp	r3, #0
 2086 0030 F9D1     		bne	.L151
 2087              	.LVL165:
 2088              	.L150:
1735:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2089              		.loc 1 1735 0 is_stmt 1
 2090 0032 074B     		ldr	r3, .L155
 2091 0034 DB68     		ldr	r3, [r3, #12]
1744:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2092              		.loc 1 1744 0
 2093 0036 0020     		mov	r0, #0
1735:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2094              		.loc 1 1735 0
 2095 0038 DB03     		lsl	r3, r3, #15
 2096 003a 04D4     		bmi	.L152
 2097 003c 1143     		orr	r1, r2
 2098              	.LVL166:
1738:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2099              		.loc 1 1738 0
 2100 003e 0F43     		orr	r7, r1
 2101              	.LVL167:
 2102 0040 034B     		ldr	r3, .L155
 2103 0042 DF63     		str	r7, [r3, #60]
 2104              	.LVL168:
1740:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2105              		.loc 1 1740 0
 2106 0044 0130     		add	r0, r0, #1
 2107              	.LVL169:
 2108              	.L152:
1748:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 2109              		.loc 1 1748 0
 2110 0046 FF22     		mov	r2, #255
 2111              	.LVL170:
 2112 0048 014B     		ldr	r3, .L155
 2113 004a 5A62     		str	r2, [r3, #36]
1751:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2114              		.loc 1 1751 0
 2115              		@ sp needed
 2116 004c F0BD     		pop	{r4, r5, r6, r7, pc}
 2117              	.L156:
 2118 004e C046     		.align	2
 2119              	.L155:
 2120 0050 00280040 		.word	1073752064
 2121              		.cfi_endproc
 2122              	.LFE64:
 2124              		.section	.text.RTC_TimeStampCmd,"ax",%progbits
 2125              		.align	2
 2126              		.global	RTC_TimeStampCmd
 2127              		.code	16
 2128              		.thumb_func
 2130              	RTC_TimeStampCmd:
 2131              	.LFB65:
1785:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 2132              		.loc 1 1785 0
 2133              		.cfi_startproc
 2134              	.LVL171:
1793:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2135              		.loc 1 1793 0
 2136 0000 0A4B     		ldr	r3, .L160
 2137 0002 9B68     		ldr	r3, [r3, #8]
 2138 0004 0A4A     		ldr	r2, .L160+4
 2139 0006 1340     		and	r3, r2
 2140              	.LVL172:
1796:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2141              		.loc 1 1796 0
 2142 0008 0029     		cmp	r1, #0
 2143 000a 04D0     		beq	.L158
 2144 000c 8022     		mov	r2, #128
 2145 000e 1201     		lsl	r2, r2, #4
 2146 0010 1343     		orr	r3, r2
 2147              	.LVL173:
1798:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2148              		.loc 1 1798 0
 2149 0012 1843     		orr	r0, r3
 2150              	.LVL174:
 2151 0014 00E0     		b	.L159
 2152              	.LVL175:
 2153              	.L158:
1802:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2154              		.loc 1 1802 0
 2155 0016 1843     		orr	r0, r3
 2156              	.LVL176:
 2157              	.L159:
1806:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 2158              		.loc 1 1806 0
 2159 0018 044B     		ldr	r3, .L160
 2160 001a CA22     		mov	r2, #202
 2161 001c 5A62     		str	r2, [r3, #36]
1807:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2162              		.loc 1 1807 0
 2163 001e 773A     		sub	r2, r2, #119
 2164 0020 5A62     		str	r2, [r3, #36]
1810:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2165              		.loc 1 1810 0
 2166 0022 9860     		str	r0, [r3, #8]
1813:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 2167              		.loc 1 1813 0
 2168 0024 AC32     		add	r2, r2, #172
 2169 0026 5A62     		str	r2, [r3, #36]
1814:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2170              		.loc 1 1814 0
 2171              		@ sp needed
 2172 0028 7047     		bx	lr
 2173              	.L161:
 2174 002a C046     		.align	2
 2175              	.L160:
 2176 002c 00280040 		.word	1073752064
 2177 0030 F7F7FFFF 		.word	-2057
 2178              		.cfi_endproc
 2179              	.LFE65:
 2181              		.section	.text.RTC_GetTimeStamp,"ax",%progbits
 2182              		.align	2
 2183              		.global	RTC_GetTimeStamp
 2184              		.code	16
 2185              		.thumb_func
 2187              	RTC_GetTimeStamp:
 2188              	.LFB66:
1830:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmptime = 0, tmpdate = 0;
 2189              		.loc 1 1830 0
 2190              		.cfi_startproc
 2191              	.LVL177:
 2192 0000 70B5     		push	{r4, r5, r6, lr}
 2193              	.LCFI21:
 2194              		.cfi_def_cfa_offset 16
 2195              		.cfi_offset 4, -16
 2196              		.cfi_offset 5, -12
 2197              		.cfi_offset 6, -8
 2198              		.cfi_offset 14, -4
 2199              	.LVL178:
1837:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
 2200              		.loc 1 1837 0
 2201 0002 1C4B     		ldr	r3, .L164
 2202 0004 1E6B     		ldr	r6, [r3, #48]
 2203              	.LVL179:
1838:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2204              		.loc 1 1838 0
 2205 0006 5B6B     		ldr	r3, [r3, #52]
 2206              	.LVL180:
1841:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
 2207              		.loc 1 1841 0
 2208 0008 B402     		lsl	r4, r6, #10
 2209 000a A40E     		lsr	r4, r4, #26
 2210 000c 0C70     		strb	r4, [r1]
1842:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
 2211              		.loc 1 1842 0
 2212 000e 7404     		lsl	r4, r6, #17
 2213 0010 640E     		lsr	r4, r4, #25
 2214 0012 4C70     		strb	r4, [r1, #1]
1843:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
 2215              		.loc 1 1843 0
 2216 0014 7F24     		mov	r4, #127
 2217 0016 3440     		and	r4, r6
 2218 0018 8C70     		strb	r4, [r1, #2]
1844:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2219              		.loc 1 1844 0
 2220 001a 8025     		mov	r5, #128
 2221 001c ED03     		lsl	r5, r5, #15
 2222 001e 3540     		and	r5, r6
 2223 0020 2D0C     		lsr	r5, r5, #16
 2224 0022 CD70     		strb	r5, [r1, #3]
1847:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 2225              		.loc 1 1847 0
 2226 0024 0024     		mov	r4, #0
 2227 0026 D470     		strb	r4, [r2, #3]
1848:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
 2228              		.loc 1 1848 0
 2229 0028 DC04     		lsl	r4, r3, #19
 2230 002a E40E     		lsr	r4, r4, #27
 2231 002c 5470     		strb	r4, [r2, #1]
1849:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
 2232              		.loc 1 1849 0
 2233 002e 3F24     		mov	r4, #63
 2234 0030 1C40     		and	r4, r3
 2235 0032 9470     		strb	r4, [r2, #2]
1850:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2236              		.loc 1 1850 0
 2237 0034 1B04     		lsl	r3, r3, #16
 2238              	.LVL181:
 2239 0036 5B0F     		lsr	r3, r3, #29
 2240 0038 1370     		strb	r3, [r2]
1853:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2241              		.loc 1 1853 0
 2242 003a 0028     		cmp	r0, #0
 2243 003c 19D1     		bne	.L162
 2244 003e 151C     		mov	r5, r2
 2245 0040 0C1C     		mov	r4, r1
1856:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
 2246              		.loc 1 1856 0
 2247 0042 0878     		ldrb	r0, [r1]
 2248              	.LVL182:
 2249 0044 FFF7FEFF 		bl	RTC_Bcd2ToByte
 2250              	.LVL183:
 2251 0048 2070     		strb	r0, [r4]
1857:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
 2252              		.loc 1 1857 0
 2253 004a 6078     		ldrb	r0, [r4, #1]
 2254 004c FFF7FEFF 		bl	RTC_Bcd2ToByte
 2255              	.LVL184:
 2256 0050 6070     		strb	r0, [r4, #1]
1858:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2257              		.loc 1 1858 0
 2258 0052 A078     		ldrb	r0, [r4, #2]
 2259 0054 FFF7FEFF 		bl	RTC_Bcd2ToByte
 2260              	.LVL185:
 2261 0058 A070     		strb	r0, [r4, #2]
1861:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
 2262              		.loc 1 1861 0
 2263 005a 6878     		ldrb	r0, [r5, #1]
 2264 005c FFF7FEFF 		bl	RTC_Bcd2ToByte
 2265              	.LVL186:
 2266 0060 6870     		strb	r0, [r5, #1]
1862:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
 2267              		.loc 1 1862 0
 2268 0062 A878     		ldrb	r0, [r5, #2]
 2269 0064 FFF7FEFF 		bl	RTC_Bcd2ToByte
 2270              	.LVL187:
 2271 0068 A870     		strb	r0, [r5, #2]
1863:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2272              		.loc 1 1863 0
 2273 006a 2878     		ldrb	r0, [r5]
 2274 006c FFF7FEFF 		bl	RTC_Bcd2ToByte
 2275              	.LVL188:
 2276 0070 2870     		strb	r0, [r5]
 2277              	.LVL189:
 2278              	.L162:
1865:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2279              		.loc 1 1865 0
 2280              		@ sp needed
 2281              	.LVL190:
 2282 0072 70BD     		pop	{r4, r5, r6, pc}
 2283              	.L165:
 2284              		.align	2
 2285              	.L164:
 2286 0074 00280040 		.word	1073752064
 2287              		.cfi_endproc
 2288              	.LFE66:
 2290              		.section	.text.RTC_GetTimeStampSubSecond,"ax",%progbits
 2291              		.align	2
 2292              		.global	RTC_GetTimeStampSubSecond
 2293              		.code	16
 2294              		.thumb_func
 2296              	RTC_GetTimeStampSubSecond:
 2297              	.LFB67:
1873:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Get timestamp subseconds values from the correspondent registers */
 2298              		.loc 1 1873 0
 2299              		.cfi_startproc
1875:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 2300              		.loc 1 1875 0
 2301 0000 014B     		ldr	r3, .L167
 2302 0002 986B     		ldr	r0, [r3, #56]
1876:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2303              		.loc 1 1876 0
 2304              		@ sp needed
 2305 0004 7047     		bx	lr
 2306              	.L168:
 2307 0006 C046     		.align	2
 2308              	.L167:
 2309 0008 00280040 		.word	1073752064
 2310              		.cfi_endproc
 2311              	.LFE67:
 2313              		.section	.text.RTC_TamperTriggerConfig,"ax",%progbits
 2314              		.align	2
 2315              		.global	RTC_TamperTriggerConfig
 2316              		.code	16
 2317              		.thumb_func
 2319              	RTC_TamperTriggerConfig:
 2320              	.LFB68:
1910:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 2321              		.loc 1 1910 0
 2322              		.cfi_startproc
 2323              	.LVL191:
1915:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {  
 2324              		.loc 1 1915 0
 2325 0000 0029     		cmp	r1, #0
 2326 0002 05D1     		bne	.L170
1918:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2327              		.loc 1 1918 0
 2328 0004 054A     		ldr	r2, .L172
 2329 0006 136C     		ldr	r3, [r2, #64]
 2330 0008 4000     		lsl	r0, r0, #1
 2331              	.LVL192:
 2332 000a 8343     		bic	r3, r0
 2333 000c 1364     		str	r3, [r2, #64]
 2334 000e 04E0     		b	.L169
 2335              	.LVL193:
 2336              	.L170:
1923:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }  
 2337              		.loc 1 1923 0
 2338 0010 024A     		ldr	r2, .L172
 2339 0012 136C     		ldr	r3, [r2, #64]
 2340 0014 4000     		lsl	r0, r0, #1
 2341              	.LVL194:
 2342 0016 1843     		orr	r0, r3
 2343 0018 1064     		str	r0, [r2, #64]
 2344              	.L169:
1925:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2345              		.loc 1 1925 0
 2346              		@ sp needed
 2347 001a 7047     		bx	lr
 2348              	.L173:
 2349              		.align	2
 2350              	.L172:
 2351 001c 00280040 		.word	1073752064
 2352              		.cfi_endproc
 2353              	.LFE68:
 2355              		.section	.text.RTC_TamperCmd,"ax",%progbits
 2356              		.align	2
 2357              		.global	RTC_TamperCmd
 2358              		.code	16
 2359              		.thumb_func
 2361              	RTC_TamperCmd:
 2362              	.LFB69:
1938:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 2363              		.loc 1 1938 0
 2364              		.cfi_startproc
 2365              	.LVL195:
1943:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2366              		.loc 1 1943 0
 2367 0000 0029     		cmp	r1, #0
 2368 0002 04D0     		beq	.L175
1946:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2369              		.loc 1 1946 0
 2370 0004 044A     		ldr	r2, .L177
 2371 0006 136C     		ldr	r3, [r2, #64]
 2372 0008 1843     		orr	r0, r3
 2373              	.LVL196:
 2374 000a 1064     		str	r0, [r2, #64]
 2375 000c 03E0     		b	.L174
 2376              	.LVL197:
 2377              	.L175:
1951:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }  
 2378              		.loc 1 1951 0
 2379 000e 024A     		ldr	r2, .L177
 2380 0010 136C     		ldr	r3, [r2, #64]
 2381 0012 8343     		bic	r3, r0
 2382 0014 1364     		str	r3, [r2, #64]
 2383              	.LVL198:
 2384              	.L174:
1953:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2385              		.loc 1 1953 0
 2386              		@ sp needed
 2387 0016 7047     		bx	lr
 2388              	.L178:
 2389              		.align	2
 2390              	.L177:
 2391 0018 00280040 		.word	1073752064
 2392              		.cfi_endproc
 2393              	.LFE69:
 2395              		.section	.text.RTC_TamperFilterConfig,"ax",%progbits
 2396              		.align	2
 2397              		.global	RTC_TamperFilterConfig
 2398              		.code	16
 2399              		.thumb_func
 2401              	RTC_TamperFilterConfig:
 2402              	.LFB70:
1969:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 2403              		.loc 1 1969 0
 2404              		.cfi_startproc
 2405              	.LVL199:
1974:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2406              		.loc 1 1974 0
 2407 0000 044B     		ldr	r3, .L180
 2408 0002 196C     		ldr	r1, [r3, #64]
 2409 0004 044A     		ldr	r2, .L180+4
 2410 0006 0A40     		and	r2, r1
 2411 0008 1A64     		str	r2, [r3, #64]
1977:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 2412              		.loc 1 1977 0
 2413 000a 1A6C     		ldr	r2, [r3, #64]
 2414 000c 1043     		orr	r0, r2
 2415              	.LVL200:
 2416 000e 1864     		str	r0, [r3, #64]
1978:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2417              		.loc 1 1978 0
 2418              		@ sp needed
 2419 0010 7047     		bx	lr
 2420              	.L181:
 2421 0012 C046     		.align	2
 2422              	.L180:
 2423 0014 00280040 		.word	1073752064
 2424 0018 FFE7FFFF 		.word	-6145
 2425              		.cfi_endproc
 2426              	.LFE70:
 2428              		.section	.text.RTC_TamperSamplingFreqConfig,"ax",%progbits
 2429              		.align	2
 2430              		.global	RTC_TamperSamplingFreqConfig
 2431              		.code	16
 2432              		.thumb_func
 2434              	RTC_TamperSamplingFreqConfig:
 2435              	.LFB71:
2003:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 2436              		.loc 1 2003 0
 2437              		.cfi_startproc
 2438              	.LVL201:
2008:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2439              		.loc 1 2008 0
 2440 0000 044B     		ldr	r3, .L183
 2441 0002 196C     		ldr	r1, [r3, #64]
 2442 0004 044A     		ldr	r2, .L183+4
 2443 0006 0A40     		and	r2, r1
 2444 0008 1A64     		str	r2, [r3, #64]
2011:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 2445              		.loc 1 2011 0
 2446 000a 1A6C     		ldr	r2, [r3, #64]
 2447 000c 1043     		orr	r0, r2
 2448              	.LVL202:
 2449 000e 1864     		str	r0, [r3, #64]
2012:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2450              		.loc 1 2012 0
 2451              		@ sp needed
 2452 0010 7047     		bx	lr
 2453              	.L184:
 2454 0012 C046     		.align	2
 2455              	.L183:
 2456 0014 00280040 		.word	1073752064
 2457 0018 FFF8FFFF 		.word	-1793
 2458              		.cfi_endproc
 2459              	.LFE71:
 2461              		.section	.text.RTC_TamperPinsPrechargeDuration,"ax",%progbits
 2462              		.align	2
 2463              		.global	RTC_TamperPinsPrechargeDuration
 2464              		.code	16
 2465              		.thumb_func
 2467              	RTC_TamperPinsPrechargeDuration:
 2468              	.LFB72:
2026:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 2469              		.loc 1 2026 0
 2470              		.cfi_startproc
 2471              	.LVL203:
2031:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2472              		.loc 1 2031 0
 2473 0000 044B     		ldr	r3, .L186
 2474 0002 196C     		ldr	r1, [r3, #64]
 2475 0004 044A     		ldr	r2, .L186+4
 2476 0006 0A40     		and	r2, r1
 2477 0008 1A64     		str	r2, [r3, #64]
2034:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 2478              		.loc 1 2034 0
 2479 000a 1A6C     		ldr	r2, [r3, #64]
 2480 000c 1043     		orr	r0, r2
 2481              	.LVL204:
 2482 000e 1864     		str	r0, [r3, #64]
2035:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2483              		.loc 1 2035 0
 2484              		@ sp needed
 2485 0010 7047     		bx	lr
 2486              	.L187:
 2487 0012 C046     		.align	2
 2488              	.L186:
 2489 0014 00280040 		.word	1073752064
 2490 0018 FF9FFFFF 		.word	-24577
 2491              		.cfi_endproc
 2492              	.LFE72:
 2494              		.section	.text.RTC_TimeStampOnTamperDetectionCmd,"ax",%progbits
 2495              		.align	2
 2496              		.global	RTC_TimeStampOnTamperDetectionCmd
 2497              		.code	16
 2498              		.thumb_func
 2500              	RTC_TimeStampOnTamperDetectionCmd:
 2501              	.LFB73:
2046:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 2502              		.loc 1 2046 0
 2503              		.cfi_startproc
 2504              	.LVL205:
2050:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2505              		.loc 1 2050 0
 2506 0000 0028     		cmp	r0, #0
 2507 0002 05D0     		beq	.L189
2053:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2508              		.loc 1 2053 0
 2509 0004 054A     		ldr	r2, .L191
 2510 0006 116C     		ldr	r1, [r2, #64]
 2511 0008 8023     		mov	r3, #128
 2512 000a 0B43     		orr	r3, r1
 2513 000c 1364     		str	r3, [r2, #64]
 2514 000e 04E0     		b	.L188
 2515              	.L189:
2058:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2516              		.loc 1 2058 0
 2517 0010 024A     		ldr	r2, .L191
 2518 0012 136C     		ldr	r3, [r2, #64]
 2519 0014 8021     		mov	r1, #128
 2520 0016 8B43     		bic	r3, r1
 2521 0018 1364     		str	r3, [r2, #64]
 2522              	.L188:
2060:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2523              		.loc 1 2060 0
 2524              		@ sp needed
 2525 001a 7047     		bx	lr
 2526              	.L192:
 2527              		.align	2
 2528              	.L191:
 2529 001c 00280040 		.word	1073752064
 2530              		.cfi_endproc
 2531              	.LFE73:
 2533              		.section	.text.RTC_TamperPullUpCmd,"ax",%progbits
 2534              		.align	2
 2535              		.global	RTC_TamperPullUpCmd
 2536              		.code	16
 2537              		.thumb_func
 2539              	RTC_TamperPullUpCmd:
 2540              	.LFB74:
2069:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 2541              		.loc 1 2069 0
 2542              		.cfi_startproc
 2543              	.LVL206:
2073:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2544              		.loc 1 2073 0
 2545 0000 0028     		cmp	r0, #0
 2546 0002 05D0     		beq	.L194
2076:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2547              		.loc 1 2076 0
 2548 0004 064A     		ldr	r2, .L196
 2549 0006 116C     		ldr	r1, [r2, #64]
 2550 0008 064B     		ldr	r3, .L196+4
 2551 000a 0B40     		and	r3, r1
 2552 000c 1364     		str	r3, [r2, #64]
 2553 000e 05E0     		b	.L193
 2554              	.L194:
2081:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   } 
 2555              		.loc 1 2081 0
 2556 0010 034A     		ldr	r2, .L196
 2557 0012 136C     		ldr	r3, [r2, #64]
 2558 0014 8021     		mov	r1, #128
 2559 0016 0902     		lsl	r1, r1, #8
 2560 0018 0B43     		orr	r3, r1
 2561 001a 1364     		str	r3, [r2, #64]
 2562              	.L193:
2083:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2563              		.loc 1 2083 0
 2564              		@ sp needed
 2565 001c 7047     		bx	lr
 2566              	.L197:
 2567 001e C046     		.align	2
 2568              	.L196:
 2569 0020 00280040 		.word	1073752064
 2570 0024 FF7FFFFF 		.word	-32769
 2571              		.cfi_endproc
 2572              	.LFE74:
 2574              		.section	.text.RTC_WriteBackupRegister,"ax",%progbits
 2575              		.align	2
 2576              		.global	RTC_WriteBackupRegister
 2577              		.code	16
 2578              		.thumb_func
 2580              	RTC_WriteBackupRegister:
 2581              	.LFB75:
2110:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   __IO uint32_t tmp = 0;
 2582              		.loc 1 2110 0
 2583              		.cfi_startproc
 2584              	.LVL207:
 2585 0000 82B0     		sub	sp, sp, #8
 2586              	.LCFI22:
 2587              		.cfi_def_cfa_offset 8
2111:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 2588              		.loc 1 2111 0
 2589 0002 0023     		mov	r3, #0
 2590 0004 0193     		str	r3, [sp, #4]
2116:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmp += (RTC_BKP_DR * 4);
 2591              		.loc 1 2116 0
 2592 0006 054B     		ldr	r3, .L199
 2593 0008 0193     		str	r3, [sp, #4]
2117:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2594              		.loc 1 2117 0
 2595 000a 019B     		ldr	r3, [sp, #4]
 2596 000c 8000     		lsl	r0, r0, #2
 2597              	.LVL208:
 2598 000e C018     		add	r0, r0, r3
 2599 0010 0190     		str	r0, [sp, #4]
2120:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 2600              		.loc 1 2120 0
 2601 0012 019B     		ldr	r3, [sp, #4]
 2602 0014 1960     		str	r1, [r3]
2121:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2603              		.loc 1 2121 0
 2604 0016 02B0     		add	sp, sp, #8
 2605              		@ sp needed
 2606 0018 7047     		bx	lr
 2607              	.L200:
 2608 001a C046     		.align	2
 2609              	.L199:
 2610 001c 50280040 		.word	1073752144
 2611              		.cfi_endproc
 2612              	.LFE75:
 2614              		.section	.text.RTC_ReadBackupRegister,"ax",%progbits
 2615              		.align	2
 2616              		.global	RTC_ReadBackupRegister
 2617              		.code	16
 2618              		.thumb_func
 2620              	RTC_ReadBackupRegister:
 2621              	.LFB76:
2131:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   __IO uint32_t tmp = 0;
 2622              		.loc 1 2131 0
 2623              		.cfi_startproc
 2624              	.LVL209:
 2625 0000 82B0     		sub	sp, sp, #8
 2626              	.LCFI23:
 2627              		.cfi_def_cfa_offset 8
2132:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 2628              		.loc 1 2132 0
 2629 0002 0023     		mov	r3, #0
 2630 0004 0193     		str	r3, [sp, #4]
2137:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   tmp += (RTC_BKP_DR * 4);
 2631              		.loc 1 2137 0
 2632 0006 054B     		ldr	r3, .L202
 2633 0008 0193     		str	r3, [sp, #4]
2138:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 2634              		.loc 1 2138 0
 2635 000a 019B     		ldr	r3, [sp, #4]
 2636 000c 8000     		lsl	r0, r0, #2
 2637              	.LVL210:
 2638 000e C018     		add	r0, r0, r3
 2639 0010 0190     		str	r0, [sp, #4]
2141:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 2640              		.loc 1 2141 0
 2641 0012 019B     		ldr	r3, [sp, #4]
 2642 0014 1868     		ldr	r0, [r3]
2142:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2643              		.loc 1 2142 0
 2644 0016 02B0     		add	sp, sp, #8
 2645              		@ sp needed
 2646 0018 7047     		bx	lr
 2647              	.L203:
 2648 001a C046     		.align	2
 2649              	.L202:
 2650 001c 50280040 		.word	1073752144
 2651              		.cfi_endproc
 2652              	.LFE76:
 2654              		.section	.text.RTC_OutputTypeConfig,"ax",%progbits
 2655              		.align	2
 2656              		.global	RTC_OutputTypeConfig
 2657              		.code	16
 2658              		.thumb_func
 2660              	RTC_OutputTypeConfig:
 2661              	.LFB77:
2171:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 2662              		.loc 1 2171 0
 2663              		.cfi_startproc
 2664              	.LVL211:
2175:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
 2665              		.loc 1 2175 0
 2666 0000 044B     		ldr	r3, .L205
 2667 0002 196C     		ldr	r1, [r3, #64]
 2668 0004 044A     		ldr	r2, .L205+4
 2669 0006 0A40     		and	r2, r1
 2670 0008 1A64     		str	r2, [r3, #64]
2176:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 2671              		.loc 1 2176 0
 2672 000a 1A6C     		ldr	r2, [r3, #64]
 2673 000c 1043     		orr	r0, r2
 2674              	.LVL212:
 2675 000e 1864     		str	r0, [r3, #64]
2177:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2676              		.loc 1 2177 0
 2677              		@ sp needed
 2678 0010 7047     		bx	lr
 2679              	.L206:
 2680 0012 C046     		.align	2
 2681              	.L205:
 2682 0014 00280040 		.word	1073752064
 2683 0018 FFFFFBFF 		.word	-262145
 2684              		.cfi_endproc
 2685              	.LFE77:
 2687              		.section	.text.RTC_SynchroShiftConfig,"ax",%progbits
 2688              		.align	2
 2689              		.global	RTC_SynchroShiftConfig
 2690              		.code	16
 2691              		.thumb_func
 2693              	RTC_SynchroShiftConfig:
 2694              	.LFB78:
2209:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ErrorStatus status = ERROR;
 2695              		.loc 1 2209 0
 2696              		.cfi_startproc
 2697              	.LVL213:
 2698 0000 38B5     		push	{r3, r4, r5, lr}
 2699              	.LCFI24:
 2700              		.cfi_def_cfa_offset 16
 2701              		.cfi_offset 3, -16
 2702              		.cfi_offset 4, -12
 2703              		.cfi_offset 5, -8
 2704              		.cfi_offset 14, -4
 2705              	.LVL214:
2218:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 2706              		.loc 1 2218 0
 2707 0002 164B     		ldr	r3, .L214
 2708 0004 CA22     		mov	r2, #202
 2709 0006 5A62     		str	r2, [r3, #36]
2219:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 2710              		.loc 1 2219 0
 2711 0008 773A     		sub	r2, r2, #119
 2712 000a 5A62     		str	r2, [r3, #36]
2222:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2713              		.loc 1 2222 0
 2714 000c DB68     		ldr	r3, [r3, #12]
 2715 000e 1B07     		lsl	r3, r3, #28
 2716 0010 0DD5     		bpl	.L208
2225:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 2717              		.loc 1 2225 0
 2718 0012 124B     		ldr	r3, .L214
 2719 0014 DB68     		ldr	r3, [r3, #12]
 2720 0016 1B07     		lsl	r3, r3, #28
 2721 0018 09D5     		bpl	.L208
 2722 001a 8023     		mov	r3, #128
 2723 001c 5B01     		lsl	r3, r3, #5
 2724 001e 0F4D     		ldr	r5, .L214
 2725 0020 0824     		mov	r4, #8
 2726              	.LVL215:
 2727              	.L209:
 2728 0022 EA68     		ldr	r2, [r5, #12]
 2729 0024 1442     		tst	r4, r2
 2730 0026 02D0     		beq	.L208
 2731 0028 013B     		sub	r3, r3, #1
 2732              	.LVL216:
2225:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 2733              		.loc 1 2225 0 is_stmt 0 discriminator 1
 2734 002a 002B     		cmp	r3, #0
 2735 002c F9D1     		bne	.L209
 2736              	.LVL217:
 2737              	.L208:
2232:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2738              		.loc 1 2232 0 is_stmt 1
 2739 002e 0B4B     		ldr	r3, .L214
 2740 0030 DA68     		ldr	r2, [r3, #12]
2256:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2741              		.loc 1 2256 0
 2742 0032 0023     		mov	r3, #0
2232:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2743              		.loc 1 2232 0
 2744 0034 1207     		lsl	r2, r2, #28
 2745 0036 0CD4     		bmi	.L210
2235:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 2746              		.loc 1 2235 0
 2747 0038 084B     		ldr	r3, .L214
 2748 003a 9A68     		ldr	r2, [r3, #8]
2251:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 2749              		.loc 1 2251 0
 2750 003c 0023     		mov	r3, #0
2235:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     {
 2751              		.loc 1 2235 0
 2752 003e D206     		lsl	r2, r2, #27
 2753 0040 07D4     		bmi	.L210
2238:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     
 2754              		.loc 1 2238 0
 2755 0042 0843     		orr	r0, r1
 2756              	.LVL218:
 2757 0044 054B     		ldr	r3, .L214
 2758 0046 D862     		str	r0, [r3, #44]
2240:.\StdPeriphLib\src/stm32f0xx_rtc.c ****       {
 2759              		.loc 1 2240 0
 2760 0048 FFF7FEFF 		bl	RTC_WaitForSynchro
 2761              	.LVL219:
 2762 004c 431E     		sub	r3, r0, #1
 2763 004e 9841     		sbc	r0, r0, r3
2251:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     }
 2764              		.loc 1 2251 0
 2765 0050 C3B2     		uxtb	r3, r0
 2766              	.L210:
 2767              	.LVL220:
2260:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 2768              		.loc 1 2260 0
 2769 0052 FF21     		mov	r1, #255
 2770 0054 014A     		ldr	r2, .L214
 2771 0056 5162     		str	r1, [r2, #36]
2263:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2772              		.loc 1 2263 0
 2773 0058 181C     		mov	r0, r3
 2774              		@ sp needed
 2775 005a 38BD     		pop	{r3, r4, r5, pc}
 2776              	.L215:
 2777              		.align	2
 2778              	.L214:
 2779 005c 00280040 		.word	1073752064
 2780              		.cfi_endproc
 2781              	.LFE78:
 2783              		.section	.text.RTC_ITConfig,"ax",%progbits
 2784              		.align	2
 2785              		.global	RTC_ITConfig
 2786              		.code	16
 2787              		.thumb_func
 2789              	RTC_ITConfig:
 2790              	.LFB79:
2319:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 2791              		.loc 1 2319 0
 2792              		.cfi_startproc
 2793              	.LVL221:
 2794 0000 10B5     		push	{r4, lr}
 2795              	.LCFI25:
 2796              		.cfi_def_cfa_offset 8
 2797              		.cfi_offset 4, -8
 2798              		.cfi_offset 14, -4
2325:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   RTC->WPR = 0x53;
 2799              		.loc 1 2325 0
 2800 0002 104B     		ldr	r3, .L219
 2801 0004 CA22     		mov	r2, #202
 2802 0006 5A62     		str	r2, [r3, #36]
2326:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2803              		.loc 1 2326 0
 2804 0008 773A     		sub	r2, r2, #119
 2805 000a 5A62     		str	r2, [r3, #36]
2328:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2806              		.loc 1 2328 0
 2807 000c 0029     		cmp	r1, #0
 2808 000e 0AD0     		beq	.L217
2331:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Configure the Tamper Interrupt in the RTC_TAFCR */
 2809              		.loc 1 2331 0
 2810 0010 9968     		ldr	r1, [r3, #8]
 2811              	.LVL222:
 2812 0012 4F3A     		sub	r2, r2, #79
 2813 0014 041C     		mov	r4, r0
 2814 0016 9443     		bic	r4, r2
 2815 0018 2143     		orr	r1, r4
 2816 001a 9960     		str	r1, [r3, #8]
2333:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2817              		.loc 1 2333 0
 2818 001c 196C     		ldr	r1, [r3, #64]
 2819 001e 1040     		and	r0, r2
 2820              	.LVL223:
 2821 0020 0843     		orr	r0, r1
 2822 0022 1864     		str	r0, [r3, #64]
 2823 0024 0AE0     		b	.L218
 2824              	.LVL224:
 2825              	.L217:
2338:.\StdPeriphLib\src/stm32f0xx_rtc.c ****     /* Configure the Tamper Interrupt in the RTC_TAFCR */
 2826              		.loc 1 2338 0
 2827 0026 074B     		ldr	r3, .L219
 2828 0028 9A68     		ldr	r2, [r3, #8]
 2829 002a 0421     		mov	r1, #4
 2830              	.LVL225:
 2831 002c 041C     		mov	r4, r0
 2832 002e 8C43     		bic	r4, r1
 2833 0030 A243     		bic	r2, r4
 2834 0032 9A60     		str	r2, [r3, #8]
2340:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2835              		.loc 1 2340 0
 2836 0034 1A6C     		ldr	r2, [r3, #64]
 2837 0036 0840     		and	r0, r1
 2838              	.LVL226:
 2839 0038 8243     		bic	r2, r0
 2840 003a 1A64     		str	r2, [r3, #64]
 2841              	.L218:
2343:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 2842              		.loc 1 2343 0
 2843 003c FF22     		mov	r2, #255
 2844 003e 014B     		ldr	r3, .L219
 2845 0040 5A62     		str	r2, [r3, #36]
2344:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2846              		.loc 1 2344 0
 2847              		@ sp needed
 2848 0042 10BD     		pop	{r4, pc}
 2849              	.L220:
 2850              		.align	2
 2851              	.L219:
 2852 0044 00280040 		.word	1073752064
 2853              		.cfi_endproc
 2854              	.LFE79:
 2856              		.section	.text.RTC_GetFlagStatus,"ax",%progbits
 2857              		.align	2
 2858              		.global	RTC_GetFlagStatus
 2859              		.code	16
 2860              		.thumb_func
 2862              	RTC_GetFlagStatus:
 2863              	.LFB80:
2363:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   FlagStatus bitstatus = RESET;
 2864              		.loc 1 2363 0
 2865              		.cfi_startproc
 2866              	.LVL227:
2371:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 2867              		.loc 1 2371 0
 2868 0000 044B     		ldr	r3, .L222
 2869 0002 DA68     		ldr	r2, [r3, #12]
 2870              	.LVL228:
 2871 0004 044B     		ldr	r3, .L222+4
 2872 0006 1340     		and	r3, r2
 2873              	.LVL229:
2374:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2874              		.loc 1 2374 0
 2875 0008 1840     		and	r0, r3
 2876              	.LVL230:
 2877 000a 431E     		sub	r3, r0, #1
 2878 000c 9841     		sbc	r0, r0, r3
 2879              	.LVL231:
2382:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 2880              		.loc 1 2382 0
 2881 000e C0B2     		uxtb	r0, r0
2383:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2882              		.loc 1 2383 0
 2883              		@ sp needed
 2884 0010 7047     		bx	lr
 2885              	.L223:
 2886 0012 C046     		.align	2
 2887              	.L222:
 2888 0014 00280040 		.word	1073752064
 2889 0018 78790100 		.word	96632
 2890              		.cfi_endproc
 2891              	.LFE80:
 2893              		.section	.text.RTC_ClearFlag,"ax",%progbits
 2894              		.align	2
 2895              		.global	RTC_ClearFlag
 2896              		.code	16
 2897              		.thumb_func
 2899              	RTC_ClearFlag:
 2900              	.LFB81:
2399:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   /* Check the parameters */
 2901              		.loc 1 2399 0
 2902              		.cfi_startproc
 2903              	.LVL232:
2404:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 2904              		.loc 1 2404 0
 2905 0000 0549     		ldr	r1, .L225
 2906 0002 CA68     		ldr	r2, [r1, #12]
 2907 0004 054B     		ldr	r3, .L225+4
 2908 0006 1840     		and	r0, r3
 2909              	.LVL233:
 2910 0008 8023     		mov	r3, #128
 2911 000a 1843     		orr	r0, r3
 2912 000c C043     		mvn	r0, r0
 2913 000e 1340     		and	r3, r2
 2914 0010 1843     		orr	r0, r3
 2915 0012 C860     		str	r0, [r1, #12]
2405:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2916              		.loc 1 2405 0
 2917              		@ sp needed
 2918 0014 7047     		bx	lr
 2919              	.L226:
 2920 0016 C046     		.align	2
 2921              	.L225:
 2922 0018 00280040 		.word	1073752064
 2923 001c 7FFF0100 		.word	130943
 2924              		.cfi_endproc
 2925              	.LFE81:
 2927              		.section	.text.RTC_GetITStatus,"ax",%progbits
 2928              		.align	2
 2929              		.global	RTC_GetITStatus
 2930              		.code	16
 2931              		.thumb_func
 2933              	RTC_GetITStatus:
 2934              	.LFB82:
2419:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   ITStatus bitstatus = RESET;
 2935              		.loc 1 2419 0
 2936              		.cfi_startproc
 2937              	.LVL234:
 2938 0000 30B5     		push	{r4, r5, lr}
 2939              	.LCFI26:
 2940              		.cfi_def_cfa_offset 12
 2941              		.cfi_offset 4, -12
 2942              		.cfi_offset 5, -8
 2943              		.cfi_offset 14, -4
 2944              	.LVL235:
2427:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  
 2945              		.loc 1 2427 0
 2946 0002 0C49     		ldr	r1, .L230
 2947 0004 0B6C     		ldr	r3, [r1, #64]
 2948              	.LVL236:
2430:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 2949              		.loc 1 2430 0
 2950 0006 8A68     		ldr	r2, [r1, #8]
 2951              	.LVL237:
2433:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 2952              		.loc 1 2433 0
 2953 0008 CC68     		ldr	r4, [r1, #12]
 2954              	.LVL238:
2427:.\StdPeriphLib\src/stm32f0xx_rtc.c ****  
 2955              		.loc 1 2427 0
 2956 000a 0421     		mov	r1, #4
 2957 000c 1940     		and	r1, r3
2430:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 2958              		.loc 1 2430 0
 2959 000e 830C     		lsr	r3, r0, #18
 2960              	.LVL239:
 2961 0010 051C     		mov	r5, r0
 2962 0012 DD40     		lsr	r5, r5, r3
 2963 0014 EB0B     		lsr	r3, r5, #15
 2964 0016 0B40     		and	r3, r1
 2965 0018 0240     		and	r2, r0
 2966 001a 1343     		orr	r3, r2
2442:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2967              		.loc 1 2442 0
 2968 001c 0022     		mov	r2, #0
2436:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2969              		.loc 1 2436 0
 2970 001e 002B     		cmp	r3, #0
 2971 0020 06D0     		beq	.L228
 2972 0022 2404     		lsl	r4, r4, #16
 2973              	.LVL240:
 2974 0024 240C     		lsr	r4, r4, #16
2433:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   
 2975              		.loc 1 2433 0 discriminator 1
 2976 0026 0009     		lsr	r0, r0, #4
 2977              	.LVL241:
2436:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   {
 2978              		.loc 1 2436 0 discriminator 1
 2979 0028 2040     		and	r0, r4
 2980 002a 441E     		sub	r4, r0, #1
 2981 002c A041     		sbc	r0, r0, r4
2438:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   }
 2982              		.loc 1 2438 0 discriminator 1
 2983 002e C2B2     		uxtb	r2, r0
 2984              	.L228:
 2985              	.LVL242:
2445:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 2986              		.loc 1 2445 0
 2987 0030 101C     		mov	r0, r2
 2988              		@ sp needed
 2989 0032 30BD     		pop	{r4, r5, pc}
 2990              	.L231:
 2991              		.align	2
 2992              	.L230:
 2993 0034 00280040 		.word	1073752064
 2994              		.cfi_endproc
 2995              	.LFE82:
 2997              		.section	.text.RTC_ClearITPendingBit,"ax",%progbits
 2998              		.align	2
 2999              		.global	RTC_ClearITPendingBit
 3000              		.code	16
 3001              		.thumb_func
 3003              	RTC_ClearITPendingBit:
 3004              	.LFB83:
2459:.\StdPeriphLib\src/stm32f0xx_rtc.c ****   uint32_t tmpreg = 0;
 3005              		.loc 1 2459 0
 3006              		.cfi_startproc
 3007              	.LVL243:
 3008 0000 10B5     		push	{r4, lr}
 3009              	.LCFI27:
 3010              		.cfi_def_cfa_offset 8
 3011              		.cfi_offset 4, -8
 3012              		.cfi_offset 14, -4
 3013              	.LVL244:
2469:.\StdPeriphLib\src/stm32f0xx_rtc.c **** }
 3014              		.loc 1 2469 0
 3015 0002 0649     		ldr	r1, .L233
 3016 0004 CA68     		ldr	r2, [r1, #12]
 3017 0006 0003     		lsl	r0, r0, #12
 3018              	.LVL245:
 3019 0008 000C     		lsr	r0, r0, #16
 3020 000a 8024     		mov	r4, #128
 3021 000c 031C     		mov	r3, r0
 3022 000e 2343     		orr	r3, r4
 3023 0010 D843     		mvn	r0, r3
 3024 0012 231C     		mov	r3, r4
 3025 0014 1340     		and	r3, r2
 3026 0016 1843     		orr	r0, r3
 3027 0018 C860     		str	r0, [r1, #12]
2470:.\StdPeriphLib\src/stm32f0xx_rtc.c **** 
 3028              		.loc 1 2470 0
 3029              		@ sp needed
 3030 001a 10BD     		pop	{r4, pc}
 3031              	.L234:
 3032              		.align	2
 3033              	.L233:
 3034 001c 00280040 		.word	1073752064
 3035              		.cfi_endproc
 3036              	.LFE83:
 3038              		.text
 3039              	.Letext0:
 3040              		.file 2 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 3041              		.file 3 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 3042              		.file 4 ".\\CMSIS/stm32f0xx.h"
 3043              		.file 5 ".\\StdPeriphLib\\inc/stm32f0xx_rtc.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f0xx_rtc.c
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:18     .text.RTC_ByteToBcd2:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:22     .text.RTC_ByteToBcd2:00000000 RTC_ByteToBcd2
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:66     .text.RTC_Bcd2ToByte:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:70     .text.RTC_Bcd2ToByte:00000000 RTC_Bcd2ToByte
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:93     .text.RTC_StructInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:98     .text.RTC_StructInit:00000000 RTC_StructInit
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:119    .text.RTC_WriteProtectionCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:124    .text.RTC_WriteProtectionCmd:00000000 RTC_WriteProtectionCmd
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:152    .text.RTC_WriteProtectionCmd:00000018 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:157    .text.RTC_EnterInitMode:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:162    .text.RTC_EnterInitMode:00000000 RTC_EnterInitMode
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:231    .text.RTC_EnterInitMode:00000044 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:236    .text.RTC_ExitInitMode:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:241    .text.RTC_ExitInitMode:00000000 RTC_ExitInitMode
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:257    .text.RTC_ExitInitMode:0000000c $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:262    .text.RTC_Init:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:267    .text.RTC_Init:00000000 RTC_Init
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:333    .text.RTC_Init:00000048 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:338    .text.RTC_WaitForSynchro:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:343    .text.RTC_WaitForSynchro:00000000 RTC_WaitForSynchro
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:424    .text.RTC_WaitForSynchro:00000054 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:429    .text.RTC_DeInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:434    .text.RTC_DeInit:00000000 RTC_DeInit
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:507    .text.RTC_DeInit:0000004c $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:515    .text.RTC_RefClockCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:520    .text.RTC_RefClockCmd:00000000 RTC_RefClockCmd
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:583    .text.RTC_RefClockCmd:00000044 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:588    .text.RTC_BypassShadowCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:593    .text.RTC_BypassShadowCmd:00000000 RTC_BypassShadowCmd
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:633    .text.RTC_BypassShadowCmd:0000002c $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:638    .text.RTC_SetTime:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:643    .text.RTC_SetTime:00000000 RTC_SetTime
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:787    .text.RTC_SetTime:000000a0 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:793    .text.RTC_TimeStructInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:798    .text.RTC_TimeStructInit:00000000 RTC_TimeStructInit
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:819    .text.RTC_GetTime:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:824    .text.RTC_GetTime:00000000 RTC_GetTime
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:889    .text.RTC_GetTime:00000044 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:894    .text.RTC_GetSubSecond:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:899    .text.RTC_GetSubSecond:00000000 RTC_GetSubSecond
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:916    .text.RTC_GetSubSecond:00000008 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:921    .text.RTC_SetDate:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:926    .text.RTC_SetDate:00000000 RTC_SetDate
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1061   .text.RTC_SetDate:00000094 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1067   .text.RTC_DateStructInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1072   .text.RTC_DateStructInit:00000000 RTC_DateStructInit
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1094   .text.RTC_GetDate:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1099   .text.RTC_GetDate:00000000 RTC_GetDate
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1161   .text.RTC_GetDate:00000040 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1166   .text.RTC_SetAlarm:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1171   .text.RTC_SetAlarm:00000000 RTC_SetAlarm
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1302   .text.RTC_SetAlarm:00000098 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1307   .text.RTC_AlarmStructInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1312   .text.RTC_AlarmStructInit:00000000 RTC_AlarmStructInit
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1340   .text.RTC_GetAlarm:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1345   .text.RTC_GetAlarm:00000000 RTC_GetAlarm
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1440   .text.RTC_GetAlarm:00000070 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1446   .text.RTC_AlarmCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1451   .text.RTC_AlarmCmd:00000000 RTC_AlarmCmd
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1543   .text.RTC_AlarmCmd:00000060 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1548   .text.RTC_AlarmSubSecondConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1553   .text.RTC_AlarmSubSecondConfig:00000000 RTC_AlarmSubSecondConfig
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1582   .text.RTC_AlarmSubSecondConfig:00000018 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1587   .text.RTC_GetAlarmSubSecond:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1592   .text.RTC_GetAlarmSubSecond:00000000 RTC_GetAlarmSubSecond
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1610   .text.RTC_GetAlarmSubSecond:0000000c $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1615   .text.RTC_WakeUpClockConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1620   .text.RTC_WakeUpClockConfig:00000000 RTC_WakeUpClockConfig
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1651   .text.RTC_WakeUpClockConfig:00000020 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1656   .text.RTC_SetWakeUpCounter:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1661   .text.RTC_SetWakeUpCounter:00000000 RTC_SetWakeUpCounter
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1684   .text.RTC_SetWakeUpCounter:00000014 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1689   .text.RTC_GetWakeUpCounter:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1694   .text.RTC_GetWakeUpCounter:00000000 RTC_GetWakeUpCounter
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1709   .text.RTC_GetWakeUpCounter:0000000c $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1714   .text.RTC_WakeUpCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1719   .text.RTC_WakeUpCmd:00000000 RTC_WakeUpCmd
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1811   .text.RTC_WakeUpCmd:00000060 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1817   .text.RTC_DayLightSavingConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1822   .text.RTC_DayLightSavingConfig:00000000 RTC_DayLightSavingConfig
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1860   .text.RTC_DayLightSavingConfig:00000024 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1866   .text.RTC_GetStoreOperation:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1871   .text.RTC_GetStoreOperation:00000000 RTC_GetStoreOperation
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1887   .text.RTC_GetStoreOperation:0000000c $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1892   .text.RTC_OutputConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1897   .text.RTC_OutputConfig:00000000 RTC_OutputConfig
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1935   .text.RTC_OutputConfig:00000024 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1941   .text.RTC_CalibOutputCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1946   .text.RTC_CalibOutputCmd:00000000 RTC_CalibOutputCmd
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1987   .text.RTC_CalibOutputCmd:00000030 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1993   .text.RTC_CalibOutputConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:1998   .text.RTC_CalibOutputConfig:00000000 RTC_CalibOutputConfig
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2029   .text.RTC_CalibOutputConfig:00000020 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2035   .text.RTC_SmoothCalibConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2040   .text.RTC_SmoothCalibConfig:00000000 RTC_SmoothCalibConfig
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2120   .text.RTC_SmoothCalibConfig:00000050 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2125   .text.RTC_TimeStampCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2130   .text.RTC_TimeStampCmd:00000000 RTC_TimeStampCmd
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2176   .text.RTC_TimeStampCmd:0000002c $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2182   .text.RTC_GetTimeStamp:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2187   .text.RTC_GetTimeStamp:00000000 RTC_GetTimeStamp
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2286   .text.RTC_GetTimeStamp:00000074 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2291   .text.RTC_GetTimeStampSubSecond:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2296   .text.RTC_GetTimeStampSubSecond:00000000 RTC_GetTimeStampSubSecond
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2309   .text.RTC_GetTimeStampSubSecond:00000008 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2314   .text.RTC_TamperTriggerConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2319   .text.RTC_TamperTriggerConfig:00000000 RTC_TamperTriggerConfig
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2351   .text.RTC_TamperTriggerConfig:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2356   .text.RTC_TamperCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2361   .text.RTC_TamperCmd:00000000 RTC_TamperCmd
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2391   .text.RTC_TamperCmd:00000018 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2396   .text.RTC_TamperFilterConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2401   .text.RTC_TamperFilterConfig:00000000 RTC_TamperFilterConfig
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2423   .text.RTC_TamperFilterConfig:00000014 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2429   .text.RTC_TamperSamplingFreqConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2434   .text.RTC_TamperSamplingFreqConfig:00000000 RTC_TamperSamplingFreqConfig
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2456   .text.RTC_TamperSamplingFreqConfig:00000014 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2462   .text.RTC_TamperPinsPrechargeDuration:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2467   .text.RTC_TamperPinsPrechargeDuration:00000000 RTC_TamperPinsPrechargeDuration
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2489   .text.RTC_TamperPinsPrechargeDuration:00000014 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2495   .text.RTC_TimeStampOnTamperDetectionCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2500   .text.RTC_TimeStampOnTamperDetectionCmd:00000000 RTC_TimeStampOnTamperDetectionCmd
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2529   .text.RTC_TimeStampOnTamperDetectionCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2534   .text.RTC_TamperPullUpCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2539   .text.RTC_TamperPullUpCmd:00000000 RTC_TamperPullUpCmd
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2569   .text.RTC_TamperPullUpCmd:00000020 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2575   .text.RTC_WriteBackupRegister:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2580   .text.RTC_WriteBackupRegister:00000000 RTC_WriteBackupRegister
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2610   .text.RTC_WriteBackupRegister:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2615   .text.RTC_ReadBackupRegister:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2620   .text.RTC_ReadBackupRegister:00000000 RTC_ReadBackupRegister
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2650   .text.RTC_ReadBackupRegister:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2655   .text.RTC_OutputTypeConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2660   .text.RTC_OutputTypeConfig:00000000 RTC_OutputTypeConfig
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2682   .text.RTC_OutputTypeConfig:00000014 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2688   .text.RTC_SynchroShiftConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2693   .text.RTC_SynchroShiftConfig:00000000 RTC_SynchroShiftConfig
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2779   .text.RTC_SynchroShiftConfig:0000005c $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2784   .text.RTC_ITConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2789   .text.RTC_ITConfig:00000000 RTC_ITConfig
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2852   .text.RTC_ITConfig:00000044 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2857   .text.RTC_GetFlagStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2862   .text.RTC_GetFlagStatus:00000000 RTC_GetFlagStatus
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2888   .text.RTC_GetFlagStatus:00000014 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2894   .text.RTC_ClearFlag:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2899   .text.RTC_ClearFlag:00000000 RTC_ClearFlag
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2922   .text.RTC_ClearFlag:00000018 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2928   .text.RTC_GetITStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2933   .text.RTC_GetITStatus:00000000 RTC_GetITStatus
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2993   .text.RTC_GetITStatus:00000034 $d
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:2998   .text.RTC_ClearITPendingBit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:3003   .text.RTC_ClearITPendingBit:00000000 RTC_ClearITPendingBit
C:\Users\Dima\AppData\Local\Temp\ccRBvZUk.s:3034   .text.RTC_ClearITPendingBit:0000001c $d
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
