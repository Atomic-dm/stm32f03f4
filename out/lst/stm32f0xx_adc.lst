   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"stm32f0xx_adc.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.ADC_DeInit,"ax",%progbits
  18              		.align	2
  19              		.global	ADC_DeInit
  20              		.code	16
  21              		.thumb_func
  23              	ADC_DeInit:
  24              	.LFB33:
  25              		.file 1 ".\\StdPeriphLib\\src/stm32f0xx_adc.c"
   1:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
   2:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ******************************************************************************
   3:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @file    stm32f0xx_adc.c
   4:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @author  MCD Application Team
   5:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @version V1.5.0
   6:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @date    05-December-2014
   7:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief   This file provides firmware functions to manage the following 
   8:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          functionalities of the Analog to Digital Convertor (ADC) peripheral:
   9:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *           + Initialization and Configuration
  10:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *           + Power saving
  11:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *           + Analog Watchdog configuration
  12:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *           + Temperature Sensor, Vrefint (Internal Reference Voltage) and 
  13:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *             Vbat (Voltage battery) management 
  14:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *           + ADC Channels Configuration
  15:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *           + ADC Channels DMA Configuration
  16:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *           + Interrupts and flags management
  17:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *
  18:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *  @verbatim
  19:.\StdPeriphLib\src/stm32f0xx_adc.c **** ================================================================================
  20:.\StdPeriphLib\src/stm32f0xx_adc.c ****                       ##### How to use this driver #####
  21:.\StdPeriphLib\src/stm32f0xx_adc.c **** ================================================================================
  22:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..]
  23:.\StdPeriphLib\src/stm32f0xx_adc.c ****     (#) Enable the ADC interface clock using 
  24:.\StdPeriphLib\src/stm32f0xx_adc.c ****         RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); 
  25:.\StdPeriphLib\src/stm32f0xx_adc.c ****     (#) ADC pins configuration
  26:.\StdPeriphLib\src/stm32f0xx_adc.c ****        (++) Enable the clock for the ADC GPIOs using the following function:
  27:.\StdPeriphLib\src/stm32f0xx_adc.c ****             RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOx, ENABLE);   
  28:.\StdPeriphLib\src/stm32f0xx_adc.c ****        (++) Configure these ADC pins in analog mode using GPIO_Init();  
  29:.\StdPeriphLib\src/stm32f0xx_adc.c ****     (#) Configure the ADC conversion resolution, data alignment, external
  30:.\StdPeriphLib\src/stm32f0xx_adc.c ****         trigger and edge, scan direction and Enable/Disable the continuous mode
  31:.\StdPeriphLib\src/stm32f0xx_adc.c ****         using the ADC_Init() function.
  32:.\StdPeriphLib\src/stm32f0xx_adc.c ****     (#) Activate the ADC peripheral using ADC_Cmd() function.
  33:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
  34:.\StdPeriphLib\src/stm32f0xx_adc.c ****     *** ADC channels group configuration ***
  35:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ============================================
  36:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] 
  37:.\StdPeriphLib\src/stm32f0xx_adc.c ****     (+) To configure the ADC channels features, use ADC_Init() and 
  38:.\StdPeriphLib\src/stm32f0xx_adc.c ****         ADC_ChannelConfig() functions.
  39:.\StdPeriphLib\src/stm32f0xx_adc.c ****     (+) To activate the continuous mode, use the ADC_ContinuousModeCmd()
  40:.\StdPeriphLib\src/stm32f0xx_adc.c ****         function.
  41:.\StdPeriphLib\src/stm32f0xx_adc.c ****     (+) To activate the Discontinuous mode, use the ADC_DiscModeCmd() functions. 
  42:.\StdPeriphLib\src/stm32f0xx_adc.c ****     (+) To activate the overrun mode, use the ADC_OverrunModeCmd() functions.
  43:.\StdPeriphLib\src/stm32f0xx_adc.c ****     (+) To activate the calibration mode, use the ADC_GetCalibrationFactor() functions.
  44:.\StdPeriphLib\src/stm32f0xx_adc.c ****     (+) To read the ADC converted values, use the ADC_GetConversionValue()
  45:.\StdPeriphLib\src/stm32f0xx_adc.c ****         function.
  46:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
  47:.\StdPeriphLib\src/stm32f0xx_adc.c ****     *** DMA for ADC channels features configuration ***
  48:.\StdPeriphLib\src/stm32f0xx_adc.c ****     =============================================================
  49:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] 
  50:.\StdPeriphLib\src/stm32f0xx_adc.c ****     (+) To enable the DMA mode for ADC channels group, use the ADC_DMACmd() function.
  51:.\StdPeriphLib\src/stm32f0xx_adc.c ****     (+) To configure the DMA transfer request, use ADC_DMARequestModeConfig() function.
  52:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
  53:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *  @endverbatim
  54:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *
  55:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ******************************************************************************
  56:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @attention
  57:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *
  58:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  59:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *
  60:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  61:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * You may not use this file except in compliance with the License.
  62:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * You may obtain a copy of the License at:
  63:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *
  64:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  65:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *
  66:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * Unless required by applicable law or agreed to in writing, software 
  67:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  68:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  69:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * See the License for the specific language governing permissions and
  70:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * limitations under the License.
  71:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *
  72:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ******************************************************************************
  73:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
  74:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
  75:.\StdPeriphLib\src/stm32f0xx_adc.c **** /* Includes ------------------------------------------------------------------*/
  76:.\StdPeriphLib\src/stm32f0xx_adc.c **** #include "stm32f0xx_adc.h"
  77:.\StdPeriphLib\src/stm32f0xx_adc.c **** #include "stm32f0xx_rcc.h"
  78:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
  79:.\StdPeriphLib\src/stm32f0xx_adc.c **** /** @addtogroup STM32F0xx_StdPeriph_Driver
  80:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @{
  81:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
  82:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
  83:.\StdPeriphLib\src/stm32f0xx_adc.c **** /** @defgroup ADC 
  84:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief ADC driver modules
  85:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @{
  86:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
  87:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
  88:.\StdPeriphLib\src/stm32f0xx_adc.c **** /* Private typedef -----------------------------------------------------------*/
  89:.\StdPeriphLib\src/stm32f0xx_adc.c **** /* Private define ------------------------------------------------------------*/
  90:.\StdPeriphLib\src/stm32f0xx_adc.c **** /* ADC CFGR mask */
  91:.\StdPeriphLib\src/stm32f0xx_adc.c **** #define CFGR1_CLEAR_MASK           ((uint32_t)0xFFFFD203)
  92:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
  93:.\StdPeriphLib\src/stm32f0xx_adc.c **** /* Calibration time out */
  94:.\StdPeriphLib\src/stm32f0xx_adc.c **** #define CALIBRATION_TIMEOUT       ((uint32_t)0x0000F000)
  95:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
  96:.\StdPeriphLib\src/stm32f0xx_adc.c **** /* Private macro -------------------------------------------------------------*/
  97:.\StdPeriphLib\src/stm32f0xx_adc.c **** /* Private variables ---------------------------------------------------------*/
  98:.\StdPeriphLib\src/stm32f0xx_adc.c **** /* Private function prototypes -----------------------------------------------*/
  99:.\StdPeriphLib\src/stm32f0xx_adc.c **** /* Private functions ---------------------------------------------------------*/
 100:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 101:.\StdPeriphLib\src/stm32f0xx_adc.c **** /** @defgroup ADC_Private_Functions
 102:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @{
 103:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 104:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 105:.\StdPeriphLib\src/stm32f0xx_adc.c **** /** @defgroup ADC_Group1 Initialization and Configuration functions
 106:.\StdPeriphLib\src/stm32f0xx_adc.c ****  *  @brief   Initialization and Configuration functions 
 107:.\StdPeriphLib\src/stm32f0xx_adc.c ****  *
 108:.\StdPeriphLib\src/stm32f0xx_adc.c **** @verbatim
 109:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ===============================================================================
 110:.\StdPeriphLib\src/stm32f0xx_adc.c ****           ##### Initialization and Configuration functions #####
 111:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ===============================================================================
 112:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] This section provides functions allowing to:
 113:.\StdPeriphLib\src/stm32f0xx_adc.c ****         (+) Initialize and configure the ADC Prescaler
 114:.\StdPeriphLib\src/stm32f0xx_adc.c ****         (+) ADC Conversion Resolution (12bit..6bit)
 115:.\StdPeriphLib\src/stm32f0xx_adc.c ****         (+) ADC Continuous Conversion Mode (Continuous or Single conversion)
 116:.\StdPeriphLib\src/stm32f0xx_adc.c ****         (+) External trigger Edge and source 
 117:.\StdPeriphLib\src/stm32f0xx_adc.c ****         (+) Converted data alignment (left or right)
 118:.\StdPeriphLib\src/stm32f0xx_adc.c ****         (+) The direction in which the channels will be scanned in the sequence
 119:.\StdPeriphLib\src/stm32f0xx_adc.c ****         (+) Enable or disable the ADC peripheral
 120:.\StdPeriphLib\src/stm32f0xx_adc.c ****    
 121:.\StdPeriphLib\src/stm32f0xx_adc.c **** @endverbatim
 122:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @{
 123:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 124:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 125:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 126:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Deinitializes ADC1 peripheral registers to their default reset values.
 127:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC peripheral.
 128:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 129:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 130:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_DeInit(ADC_TypeDef* ADCx)
 131:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
  26              		.loc 1 131 0
  27              		.cfi_startproc
  28              	.LVL0:
  29 0000 10B5     		push	{r4, lr}
  30              	.LCFI0:
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 4, -8
  33              		.cfi_offset 14, -4
 132:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 133:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 134:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 135:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if(ADCx == ADC1)
  34              		.loc 1 135 0
  35 0002 074B     		ldr	r3, .L3
  36 0004 9842     		cmp	r0, r3
  37 0006 09D1     		bne	.L1
 136:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 137:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Enable ADC1 reset state */
 138:.\StdPeriphLib\src/stm32f0xx_adc.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
  38              		.loc 1 138 0
  39 0008 8024     		mov	r4, #128
  40 000a A400     		lsl	r4, r4, #2
  41 000c 201C     		mov	r0, r4
  42              	.LVL1:
  43 000e 0121     		mov	r1, #1
  44 0010 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  45              	.LVL2:
 139:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 140:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Release ADC1 from reset state */
 141:.\StdPeriphLib\src/stm32f0xx_adc.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
  46              		.loc 1 141 0
  47 0014 201C     		mov	r0, r4
  48 0016 0021     		mov	r1, #0
  49 0018 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  50              	.LVL3:
  51              	.L1:
 142:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 143:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
  52              		.loc 1 143 0
  53              		@ sp needed
  54 001c 10BD     		pop	{r4, pc}
  55              	.L4:
  56 001e C046     		.align	2
  57              	.L3:
  58 0020 00240140 		.word	1073816576
  59              		.cfi_endproc
  60              	.LFE33:
  62              		.section	.text.ADC_Init,"ax",%progbits
  63              		.align	2
  64              		.global	ADC_Init
  65              		.code	16
  66              		.thumb_func
  68              	ADC_Init:
  69              	.LFB34:
 144:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 145:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 146:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Initializes the ADCx peripheral according to the specified parameters
 147:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         in the ADC_InitStruct.
 148:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   This function is used to configure the global features of the ADC ( 
 149:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         Resolution, Data Alignment, continuous mode activation, External 
 150:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         trigger source and edge, Sequence Scan Direction).   
 151:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC peripheral.
 152:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains 
 153:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         the configuration information for the specified ADC peripheral.
 154:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 155:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 156:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
 157:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
  70              		.loc 1 157 0
  71              		.cfi_startproc
  72              	.LVL4:
  73 0000 10B5     		push	{r4, lr}
  74              	.LCFI1:
  75              		.cfi_def_cfa_offset 8
  76              		.cfi_offset 4, -8
  77              		.cfi_offset 14, -4
  78              	.LVL5:
 158:.\StdPeriphLib\src/stm32f0xx_adc.c ****   uint32_t tmpreg = 0;
 159:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 160:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 161:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 162:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution));
 163:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
 164:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge));
 165:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_EXTERNAL_TRIG_CONV(ADC_InitStruct->ADC_ExternalTrigConv));
 166:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign));
 167:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_SCAN_DIRECTION(ADC_InitStruct->ADC_ScanDirection)); 
 168:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 169:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Get the ADCx CFGR value */
 170:.\StdPeriphLib\src/stm32f0xx_adc.c ****   tmpreg = ADCx->CFGR1;
  79              		.loc 1 170 0
  80 0002 C368     		ldr	r3, [r0, #12]
  81              	.LVL6:
  82 0004 8C68     		ldr	r4, [r1, #8]
  83 0006 0A68     		ldr	r2, [r1]
  84 0008 1443     		orr	r4, r2
  85 000a CA68     		ldr	r2, [r1, #12]
  86 000c 1443     		orr	r4, r2
  87 000e 0A69     		ldr	r2, [r1, #16]
  88 0010 1443     		orr	r4, r2
  89 0012 4A69     		ldr	r2, [r1, #20]
  90 0014 1443     		orr	r4, r2
 171:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 172:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Clear SCANDIR, RES[1:0], ALIGN, EXTSEL[2:0], EXTEN[1:0] and CONT bits */
 173:.\StdPeriphLib\src/stm32f0xx_adc.c ****   tmpreg &= CFGR1_CLEAR_MASK;
  91              		.loc 1 173 0
  92 0016 044A     		ldr	r2, .L6
  93 0018 1340     		and	r3, r2
  94              	.LVL7:
  95 001a 2343     		orr	r3, r4
  96              	.LVL8:
 174:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 175:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /*---------------------------- ADCx CFGR Configuration ---------------------*/
 176:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 177:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Set RES[1:0] bits according to ADC_Resolution value */
 178:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Set CONT bit according to ADC_ContinuousConvMode value */
 179:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Set EXTEN[1:0] bits according to ADC_ExternalTrigConvEdge value */
 180:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Set EXTSEL[2:0] bits according to ADC_ExternalTrigConv value */
 181:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Set ALIGN bit according to ADC_DataAlign value */
 182:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Set SCANDIR bit according to ADC_ScanDirection value */
 183:.\StdPeriphLib\src/stm32f0xx_adc.c ****  
 184:.\StdPeriphLib\src/stm32f0xx_adc.c ****   tmpreg  |= (uint32_t)(ADC_InitStruct->ADC_Resolution | ((uint32_t)(ADC_InitStruct->ADC_Continuous
  97              		.loc 1 184 0
  98 001c 0A79     		ldrb	r2, [r1, #4]
  99 001e 5203     		lsl	r2, r2, #13
 100 0020 1343     		orr	r3, r2
 101              	.LVL9:
 185:.\StdPeriphLib\src/stm32f0xx_adc.c ****              ADC_InitStruct->ADC_ExternalTrigConvEdge | ADC_InitStruct->ADC_ExternalTrigConv |
 186:.\StdPeriphLib\src/stm32f0xx_adc.c ****              ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ScanDirection);
 187:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 188:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Write to ADCx CFGR */
 189:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADCx->CFGR1 = tmpreg;
 102              		.loc 1 189 0
 103 0022 C360     		str	r3, [r0, #12]
 190:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 104              		.loc 1 190 0
 105              		@ sp needed
 106 0024 10BD     		pop	{r4, pc}
 107              	.L7:
 108 0026 C046     		.align	2
 109              	.L6:
 110 0028 03D2FFFF 		.word	-11773
 111              		.cfi_endproc
 112              	.LFE34:
 114              		.section	.text.ADC_StructInit,"ax",%progbits
 115              		.align	2
 116              		.global	ADC_StructInit
 117              		.code	16
 118              		.thumb_func
 120              	ADC_StructInit:
 121              	.LFB35:
 191:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 192:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 193:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Fills each ADC_InitStruct member with its default value.
 194:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   This function is used to initialize the global features of the ADC ( 
 195:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         Resolution, Data Alignment, continuous mode activation, External 
 196:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         trigger source and edge, Sequence Scan Direction).
 197:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
 198:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         be initialized.
 199:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 200:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 201:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
 202:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 122              		.loc 1 202 0
 123              		.cfi_startproc
 124              	.LVL10:
 203:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Reset ADC init structure parameters values */
 204:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Initialize the ADC_Resolution member */
 205:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
 125              		.loc 1 205 0
 126 0000 0023     		mov	r3, #0
 127 0002 0360     		str	r3, [r0]
 206:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 207:.\StdPeriphLib\src/stm32f0xx_adc.c ****    /* Initialize the ADC_ContinuousConvMode member */
 208:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 128              		.loc 1 208 0
 129 0004 0371     		strb	r3, [r0, #4]
 209:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 210:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Initialize the ADC_ExternalTrigConvEdge member */
 211:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 130              		.loc 1 211 0
 131 0006 8360     		str	r3, [r0, #8]
 212:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 213:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Initialize the ADC_ExternalTrigConv member */
 214:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_TRGO;
 132              		.loc 1 214 0
 133 0008 C360     		str	r3, [r0, #12]
 215:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 216:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Initialize the ADC_DataAlign member */
 217:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 134              		.loc 1 217 0
 135 000a 0361     		str	r3, [r0, #16]
 218:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 219:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Initialize the ADC_ScanDirection member */
 220:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADC_InitStruct->ADC_ScanDirection = ADC_ScanDirection_Upward;
 136              		.loc 1 220 0
 137 000c 4361     		str	r3, [r0, #20]
 221:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 138              		.loc 1 221 0
 139              		@ sp needed
 140 000e 7047     		bx	lr
 141              		.cfi_endproc
 142              	.LFE35:
 144              		.section	.text.ADC_Cmd,"ax",%progbits
 145              		.align	2
 146              		.global	ADC_Cmd
 147              		.code	16
 148              		.thumb_func
 150              	ADC_Cmd:
 151              	.LFB36:
 222:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 223:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 224:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enables or disables the specified ADC peripheral.
 225:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 226:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  NewState: new state of the ADCx peripheral. 
 227:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be: ENABLE or DISABLE.
 228:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 229:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 230:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 231:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 152              		.loc 1 231 0
 153              		.cfi_startproc
 154              	.LVL11:
 232:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 233:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 234:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 235:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 236:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if (NewState != DISABLE)
 155              		.loc 1 236 0
 156 0000 0029     		cmp	r1, #0
 157 0002 04D0     		beq	.L10
 237:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 238:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Set the ADEN bit to Enable the ADC peripheral */
 239:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CR |= (uint32_t)ADC_CR_ADEN;
 158              		.loc 1 239 0
 159 0004 8268     		ldr	r2, [r0, #8]
 160 0006 0123     		mov	r3, #1
 161 0008 1343     		orr	r3, r2
 162 000a 8360     		str	r3, [r0, #8]
 163 000c 03E0     		b	.L9
 164              	.L10:
 240:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 241:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
 242:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 243:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Set the ADDIS to Disable the ADC peripheral */
 244:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CR |= (uint32_t)ADC_CR_ADDIS;
 165              		.loc 1 244 0
 166 000e 8268     		ldr	r2, [r0, #8]
 167 0010 0223     		mov	r3, #2
 168 0012 1343     		orr	r3, r2
 169 0014 8360     		str	r3, [r0, #8]
 170              	.L9:
 245:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 246:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 171              		.loc 1 246 0
 172              		@ sp needed
 173 0016 7047     		bx	lr
 174              		.cfi_endproc
 175              	.LFE36:
 177              		.section	.text.ADC_ClockModeConfig,"ax",%progbits
 178              		.align	2
 179              		.global	ADC_ClockModeConfig
 180              		.code	16
 181              		.thumb_func
 183              	ADC_ClockModeConfig:
 184              	.LFB37:
 247:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 248:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 249:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Configure the ADC to either be clocked by the asynchronous clock(which is
 250:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         independent, the dedicated 14MHz clock) or the synchronous clock derived from
 251:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         the APB clock of the ADC bus interface divided by 2 or 4
 252:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   This function can be called only when ADC is disabled.
 253:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 254:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADC_ClockMode: This parameter can be :
 255:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_ClockMode_AsynClk: ADC clocked by the dedicated 14MHz clock
 256:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_ClockMode_SynClkDiv2: ADC clocked by PCLK/2
 257:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_ClockMode_SynClkDiv4: ADC clocked by PCLK/4  
 258:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 259:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 260:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_ClockModeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ClockMode)
 261:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 185              		.loc 1 261 0
 186              		.cfi_startproc
 187              	.LVL12:
 262:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 263:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 264:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_CLOCKMODE(ADC_ClockMode));
 265:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 266:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Configure the ADC Clock mode according to ADC_ClockMode */
 267:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR2 = (uint32_t)ADC_ClockMode;
 188              		.loc 1 267 0
 189 0000 0161     		str	r1, [r0, #16]
 268:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 269:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 190              		.loc 1 269 0
 191              		@ sp needed
 192 0002 7047     		bx	lr
 193              		.cfi_endproc
 194              	.LFE37:
 196              		.section	.text.ADC_JitterCmd,"ax",%progbits
 197              		.align	2
 198              		.global	ADC_JitterCmd
 199              		.code	16
 200              		.thumb_func
 202              	ADC_JitterCmd:
 203              	.LFB38:
 270:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 271:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 272:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enables or disables the jitter when the ADC is clocked by PCLK div2
 273:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         or div4
 274:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   This function is obsolete and maintained for legacy purpose only. ADC_ClockModeConfig()
 275:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         function should be used instead.  
 276:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 277:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADC_JitterOff: This parameter can be :
 278:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_JitterOff_PCLKDiv2: Remove jitter when ADC is clocked by PLCK divided by 2
 279:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_JitterOff_PCLKDiv4: Remove jitter when ADC is clocked by PLCK divided by 4
 280:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  NewState: new state of the ADCx jitter. 
 281:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be: ENABLE or DISABLE.
 282:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 283:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 284:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_JitterCmd(ADC_TypeDef* ADCx, uint32_t ADC_JitterOff, FunctionalState NewState)
 285:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 204              		.loc 1 285 0
 205              		.cfi_startproc
 206              	.LVL13:
 286:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 287:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 288:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_JITTEROFF(ADC_JitterOff));
 289:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 290:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 291:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if (NewState != DISABLE)
 207              		.loc 1 291 0
 208 0000 002A     		cmp	r2, #0
 209 0002 03D0     		beq	.L14
 292:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 293:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Disable Jitter */
 294:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR2 |= (uint32_t)ADC_JitterOff;
 210              		.loc 1 294 0
 211 0004 0369     		ldr	r3, [r0, #16]
 212 0006 1943     		orr	r1, r3
 213              	.LVL14:
 214 0008 0161     		str	r1, [r0, #16]
 215 000a 02E0     		b	.L13
 216              	.LVL15:
 217              	.L14:
 295:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 296:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
 297:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 298:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Enable Jitter */
 299:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR2 &= (uint32_t)(~ADC_JitterOff);
 218              		.loc 1 299 0
 219 000c 0369     		ldr	r3, [r0, #16]
 220 000e 8B43     		bic	r3, r1
 221 0010 0361     		str	r3, [r0, #16]
 222              	.LVL16:
 223              	.L13:
 300:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 301:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 224              		.loc 1 301 0
 225              		@ sp needed
 226 0012 7047     		bx	lr
 227              		.cfi_endproc
 228              	.LFE38:
 230              		.section	.text.ADC_AutoPowerOffCmd,"ax",%progbits
 231              		.align	2
 232              		.global	ADC_AutoPowerOffCmd
 233              		.code	16
 234              		.thumb_func
 236              	ADC_AutoPowerOffCmd:
 237              	.LFB39:
 302:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 303:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 304:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @}
 305:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 306:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 307:.\StdPeriphLib\src/stm32f0xx_adc.c **** /** @defgroup ADC_Group2 Power saving functions
 308:.\StdPeriphLib\src/stm32f0xx_adc.c ****  *  @brief   Power saving functions 
 309:.\StdPeriphLib\src/stm32f0xx_adc.c ****  *
 310:.\StdPeriphLib\src/stm32f0xx_adc.c **** @verbatim
 311:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ===============================================================================
 312:.\StdPeriphLib\src/stm32f0xx_adc.c ****           ##### Power saving functions #####
 313:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ===============================================================================
 314:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] This section provides functions allowing to reduce power consumption.
 315:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] The two function must be combined to get the maximal benefits:
 316:.\StdPeriphLib\src/stm32f0xx_adc.c ****          When the ADC frequency is higher than the CPU one, it is recommended to 
 317:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (#) Enable the Auto Delayed Conversion mode : 
 318:.\StdPeriphLib\src/stm32f0xx_adc.c ****              ==> using ADC_WaitModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
 319:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (#) Enable the power off in Delay phases :
 320:.\StdPeriphLib\src/stm32f0xx_adc.c ****              ==> using ADC_AutoPowerOffCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
 321:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 322:.\StdPeriphLib\src/stm32f0xx_adc.c **** @endverbatim
 323:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @{
 324:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 325:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 326:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 327:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enables or disables the ADC Power Off.
 328:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   ADC power-on and power-off can be managed by hardware to cut the 
 329:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         consumption when the ADC is not converting. 
 330:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 331:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   The ADC can be powered down: 
 332:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         - During the Auto delay phase:  The ADC is powered on again at the end
 333:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *           of the delay (until the previous data is read from the ADC data register). 
 334:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         - During the ADC is waiting for a trigger event: The ADC is powered up
 335:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *           at the next trigger event (when the conversion is started).
 336:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  NewState: new state of the ADCx power Off. 
 337:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be: ENABLE or DISABLE.
 338:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 339:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 340:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_AutoPowerOffCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 341:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 238              		.loc 1 341 0
 239              		.cfi_startproc
 240              	.LVL17:
 342:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 343:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 344:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 345:.\StdPeriphLib\src/stm32f0xx_adc.c ****   
 346:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if (NewState != DISABLE)
 241              		.loc 1 346 0
 242 0000 0029     		cmp	r1, #0
 243 0002 05D0     		beq	.L17
 347:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 348:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Enable the ADC Automatic Power-Off */
 349:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 |= ADC_CFGR1_AUTOFF;
 244              		.loc 1 349 0
 245 0004 C368     		ldr	r3, [r0, #12]
 246 0006 8022     		mov	r2, #128
 247 0008 1202     		lsl	r2, r2, #8
 248 000a 1343     		orr	r3, r2
 249 000c C360     		str	r3, [r0, #12]
 250 000e 03E0     		b	.L16
 251              	.L17:
 350:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 351:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
 352:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 353:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Disable the ADC Automatic Power-Off */
 354:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_AUTOFF;
 252              		.loc 1 354 0
 253 0010 C268     		ldr	r2, [r0, #12]
 254 0012 024B     		ldr	r3, .L19
 255 0014 1340     		and	r3, r2
 256 0016 C360     		str	r3, [r0, #12]
 257              	.L16:
 355:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 356:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 258              		.loc 1 356 0
 259              		@ sp needed
 260 0018 7047     		bx	lr
 261              	.L20:
 262 001a C046     		.align	2
 263              	.L19:
 264 001c FF7FFFFF 		.word	-32769
 265              		.cfi_endproc
 266              	.LFE39:
 268              		.section	.text.ADC_WaitModeCmd,"ax",%progbits
 269              		.align	2
 270              		.global	ADC_WaitModeCmd
 271              		.code	16
 272              		.thumb_func
 274              	ADC_WaitModeCmd:
 275              	.LFB40:
 357:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 358:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 359:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enables or disables the Wait conversion mode.
 360:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   When the CPU clock is not fast enough to manage the data rate, a 
 361:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         Hardware delay can be introduced between ADC conversions to reduce 
 362:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         this data rate. 
 363:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   The Hardware delay is inserted after each conversions and until the
 364:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         previous data is read from the ADC data register
 365:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   This is a way to automatically adapt the speed of the ADC to the speed 
 366:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         of the system which will read the data.
 367:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   Any hardware triggers wich occur while a conversion is on going or 
 368:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         while the automatic Delay is applied are ignored 
 369:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 370:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  NewState: new state of the ADCx Auto-Delay.
 371:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be: ENABLE or DISABLE.
 372:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 373:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 374:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_WaitModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 375:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 276              		.loc 1 375 0
 277              		.cfi_startproc
 278              	.LVL18:
 376:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 377:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 378:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 379:.\StdPeriphLib\src/stm32f0xx_adc.c ****   
 380:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if (NewState != DISABLE)
 279              		.loc 1 380 0
 280 0000 0029     		cmp	r1, #0
 281 0002 05D0     		beq	.L22
 381:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 382:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Enable the ADC Automatic Delayed conversion */
 383:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 |= ADC_CFGR1_WAIT;
 282              		.loc 1 383 0
 283 0004 C368     		ldr	r3, [r0, #12]
 284 0006 8022     		mov	r2, #128
 285 0008 D201     		lsl	r2, r2, #7
 286 000a 1343     		orr	r3, r2
 287 000c C360     		str	r3, [r0, #12]
 288 000e 03E0     		b	.L21
 289              	.L22:
 384:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 385:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
 386:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 387:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Disable the ADC Automatic Delayed conversion */
 388:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_WAIT;
 290              		.loc 1 388 0
 291 0010 C268     		ldr	r2, [r0, #12]
 292 0012 024B     		ldr	r3, .L24
 293 0014 1340     		and	r3, r2
 294 0016 C360     		str	r3, [r0, #12]
 295              	.L21:
 389:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 390:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 296              		.loc 1 390 0
 297              		@ sp needed
 298 0018 7047     		bx	lr
 299              	.L25:
 300 001a C046     		.align	2
 301              	.L24:
 302 001c FFBFFFFF 		.word	-16385
 303              		.cfi_endproc
 304              	.LFE40:
 306              		.section	.text.ADC_AnalogWatchdogCmd,"ax",%progbits
 307              		.align	2
 308              		.global	ADC_AnalogWatchdogCmd
 309              		.code	16
 310              		.thumb_func
 312              	ADC_AnalogWatchdogCmd:
 313              	.LFB41:
 391:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 392:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 393:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @}
 394:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 395:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 396:.\StdPeriphLib\src/stm32f0xx_adc.c **** /** @defgroup ADC_Group3 Analog Watchdog configuration functions
 397:.\StdPeriphLib\src/stm32f0xx_adc.c ****  *  @brief   Analog Watchdog configuration functions 
 398:.\StdPeriphLib\src/stm32f0xx_adc.c ****  *
 399:.\StdPeriphLib\src/stm32f0xx_adc.c **** @verbatim
 400:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ===============================================================================
 401:.\StdPeriphLib\src/stm32f0xx_adc.c ****                    ##### Analog Watchdog configuration functions #####
 402:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ===============================================================================  
 403:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] This section provides functions allowing to configure the Analog Watchdog
 404:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (AWD) feature in the ADC.
 405:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] A typical configuration Analog Watchdog is done following these steps :
 406:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (#) the ADC guarded channel(s) is (are) selected using the 
 407:.\StdPeriphLib\src/stm32f0xx_adc.c ****              ADC_AnalogWatchdogSingleChannelConfig() function.
 408:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (#) The Analog watchdog lower and higher threshold are configured using the  
 409:.\StdPeriphLib\src/stm32f0xx_adc.c ****              ADC_AnalogWatchdogThresholdsConfig() function.
 410:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (#) The Analog watchdog is enabled and configured to enable the check, on one
 411:.\StdPeriphLib\src/stm32f0xx_adc.c ****              or more channels, using the  ADC_AnalogWatchdogCmd() function.
 412:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (#) Enable the analog watchdog on the selected channel using
 413:.\StdPeriphLib\src/stm32f0xx_adc.c ****              ADC_AnalogWatchdogSingleChannelCmd() function
 414:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 415:.\StdPeriphLib\src/stm32f0xx_adc.c **** @endverbatim
 416:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @{
 417:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 418:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 419:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 420:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enables or disables the analog watchdog 
 421:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 422:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  NewState: new state of the ADCx Analog Watchdog.
 423:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be: ENABLE or DISABLE.
 424:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 425:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 426:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 427:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 314              		.loc 1 427 0
 315              		.cfi_startproc
 316              	.LVL19:
 428:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 429:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 430:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 431:.\StdPeriphLib\src/stm32f0xx_adc.c ****   
 432:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if (NewState != DISABLE)
 317              		.loc 1 432 0
 318 0000 0029     		cmp	r1, #0
 319 0002 05D0     		beq	.L27
 433:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 434:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Enable the ADC Analog Watchdog */
 435:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 |= ADC_CFGR1_AWDEN;
 320              		.loc 1 435 0
 321 0004 C368     		ldr	r3, [r0, #12]
 322 0006 8022     		mov	r2, #128
 323 0008 1204     		lsl	r2, r2, #16
 324 000a 1343     		orr	r3, r2
 325 000c C360     		str	r3, [r0, #12]
 326 000e 03E0     		b	.L26
 327              	.L27:
 436:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 437:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
 438:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 439:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Disable the ADC Analog Watchdog */
 440:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_AWDEN;
 328              		.loc 1 440 0
 329 0010 C268     		ldr	r2, [r0, #12]
 330 0012 024B     		ldr	r3, .L29
 331 0014 1340     		and	r3, r2
 332 0016 C360     		str	r3, [r0, #12]
 333              	.L26:
 441:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 442:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 334              		.loc 1 442 0
 335              		@ sp needed
 336 0018 7047     		bx	lr
 337              	.L30:
 338 001a C046     		.align	2
 339              	.L29:
 340 001c FFFF7FFF 		.word	-8388609
 341              		.cfi_endproc
 342              	.LFE41:
 344              		.section	.text.ADC_AnalogWatchdogThresholdsConfig,"ax",%progbits
 345              		.align	2
 346              		.global	ADC_AnalogWatchdogThresholdsConfig
 347              		.code	16
 348              		.thumb_func
 350              	ADC_AnalogWatchdogThresholdsConfig:
 351              	.LFB42:
 443:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 444:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 445:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Configures the high and low thresholds of the analog watchdog. 
 446:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 447:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  HighThreshold: the ADC analog watchdog High threshold value.
 448:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter must be a 12bit value.
 449:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  LowThreshold: the ADC analog watchdog Low threshold value.
 450:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter must be a 12bit value.
 451:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 452:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 453:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
 454:.\StdPeriphLib\src/stm32f0xx_adc.c ****                                         uint16_t LowThreshold)
 455:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 352              		.loc 1 455 0
 353              		.cfi_startproc
 354              	.LVL20:
 456:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 457:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 458:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_THRESHOLD(HighThreshold));
 459:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_THRESHOLD(LowThreshold));
 460:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 461:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Set the ADCx high and low threshold */
 462:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADCx->TR = LowThreshold | ((uint32_t)HighThreshold << 16);
 355              		.loc 1 462 0
 356 0000 0904     		lsl	r1, r1, #16
 357              	.LVL21:
 358 0002 0A43     		orr	r2, r1
 359              	.LVL22:
 360 0004 0262     		str	r2, [r0, #32]
 463:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 464:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 361              		.loc 1 464 0
 362              		@ sp needed
 363 0006 7047     		bx	lr
 364              		.cfi_endproc
 365              	.LFE42:
 367              		.section	.text.ADC_AnalogWatchdogSingleChannelConfig,"ax",%progbits
 368              		.align	2
 369              		.global	ADC_AnalogWatchdogSingleChannelConfig
 370              		.code	16
 371              		.thumb_func
 373              	ADC_AnalogWatchdogSingleChannelConfig:
 374              	.LFB43:
 465:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 466:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 467:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Configures the analog watchdog guarded single channel
 468:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 469:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADC_AnalogWatchdog_Channel: the ADC channel to configure for the analog watchdog.
 470:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be one of the following values:
 471:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_0: ADC Channel0 selected
 472:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_1: ADC Channel1 selected
 473:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_2: ADC Channel2 selected
 474:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_3: ADC Channel3 selected
 475:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_4: ADC Channel4 selected
 476:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_5: ADC Channel5 selected
 477:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_6: ADC Channel6 selected
 478:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_7: ADC Channel7 selected
 479:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_8: ADC Channel8 selected
 480:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_9: ADC Channel9 selected
 481:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_10: ADC Channel10 selected, not available for STM32F
 482:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_11: ADC Channel11 selected, not available for STM32F
 483:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_12: ADC Channel12 selected, not available for STM32F
 484:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_13: ADC Channel13 selected, not available for STM32F
 485:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_14: ADC Channel14 selected, not available for STM32F
 486:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_15: ADC Channel15 selected, not available for STM32F
 487:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_16: ADC Channel16 selected
 488:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_17: ADC Channel17 selected
 489:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_AnalogWatchdog_Channel_18: ADC Channel18 selected, not available for STM32F
 490:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   The channel selected on the AWDCH must be also set into the CHSELR 
 491:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         register 
 492:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 493:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 494:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog_Channel)
 495:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 375              		.loc 1 495 0
 376              		.cfi_startproc
 377              	.LVL23:
 496:.\StdPeriphLib\src/stm32f0xx_adc.c ****   uint32_t tmpreg = 0;
 497:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 498:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 499:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 500:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ANALOG_WATCHDOG_CHANNEL(ADC_AnalogWatchdog_Channel));
 501:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 502:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Get the old register value */
 503:.\StdPeriphLib\src/stm32f0xx_adc.c ****   tmpreg = ADCx->CFGR1;
 378              		.loc 1 503 0
 379 0000 C268     		ldr	r2, [r0, #12]
 380              	.LVL24:
 504:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 505:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Clear the Analog watchdog channel select bits */
 506:.\StdPeriphLib\src/stm32f0xx_adc.c ****   tmpreg &= ~ADC_CFGR1_AWDCH;
 381              		.loc 1 506 0
 382 0002 024B     		ldr	r3, .L33
 383 0004 1340     		and	r3, r2
 384              	.LVL25:
 507:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 508:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Set the Analog watchdog channel */
 509:.\StdPeriphLib\src/stm32f0xx_adc.c ****   tmpreg |= ADC_AnalogWatchdog_Channel;
 385              		.loc 1 509 0
 386 0006 1943     		orr	r1, r3
 387              	.LVL26:
 510:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 511:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Store the new register value */
 512:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADCx->CFGR1 = tmpreg;
 388              		.loc 1 512 0
 389 0008 C160     		str	r1, [r0, #12]
 513:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 390              		.loc 1 513 0
 391              		@ sp needed
 392 000a 7047     		bx	lr
 393              	.L34:
 394              		.align	2
 395              	.L33:
 396 000c FFFFFF83 		.word	-2080374785
 397              		.cfi_endproc
 398              	.LFE43:
 400              		.section	.text.ADC_AnalogWatchdogSingleChannelCmd,"ax",%progbits
 401              		.align	2
 402              		.global	ADC_AnalogWatchdogSingleChannelCmd
 403              		.code	16
 404              		.thumb_func
 406              	ADC_AnalogWatchdogSingleChannelCmd:
 407              	.LFB44:
 514:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 515:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 516:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enables or disables the ADC Analog Watchdog Single Channel.
 517:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 518:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  NewState: new state of the ADCx ADC Analog Watchdog Single Channel.
 519:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be: ENABLE or DISABLE.
 520:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 521:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 522:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_AnalogWatchdogSingleChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 523:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 408              		.loc 1 523 0
 409              		.cfi_startproc
 410              	.LVL27:
 524:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 525:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 526:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 527:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 528:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if (NewState != DISABLE)
 411              		.loc 1 528 0
 412 0000 0029     		cmp	r1, #0
 413 0002 05D0     		beq	.L36
 529:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 530:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Enable the ADC Analog Watchdog Single Channel */
 531:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 |= ADC_CFGR1_AWDSGL;
 414              		.loc 1 531 0
 415 0004 C368     		ldr	r3, [r0, #12]
 416 0006 8022     		mov	r2, #128
 417 0008 D203     		lsl	r2, r2, #15
 418 000a 1343     		orr	r3, r2
 419 000c C360     		str	r3, [r0, #12]
 420 000e 03E0     		b	.L35
 421              	.L36:
 532:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 533:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
 534:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 535:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Disable the ADC Analog Watchdog Single Channel */
 536:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_AWDSGL;
 422              		.loc 1 536 0
 423 0010 C268     		ldr	r2, [r0, #12]
 424 0012 024B     		ldr	r3, .L38
 425 0014 1340     		and	r3, r2
 426 0016 C360     		str	r3, [r0, #12]
 427              	.L35:
 537:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 538:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 428              		.loc 1 538 0
 429              		@ sp needed
 430 0018 7047     		bx	lr
 431              	.L39:
 432 001a C046     		.align	2
 433              	.L38:
 434 001c FFFFBFFF 		.word	-4194305
 435              		.cfi_endproc
 436              	.LFE44:
 438              		.section	.text.ADC_TempSensorCmd,"ax",%progbits
 439              		.align	2
 440              		.global	ADC_TempSensorCmd
 441              		.code	16
 442              		.thumb_func
 444              	ADC_TempSensorCmd:
 445              	.LFB45:
 539:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 540:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 541:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @}
 542:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 543:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 544:.\StdPeriphLib\src/stm32f0xx_adc.c **** /** @defgroup ADC_Group4 Temperature Sensor, Vrefint  and Vbat management functions
 545:.\StdPeriphLib\src/stm32f0xx_adc.c ****  *  @brief   Temperature Sensor, Vrefint  and Vbat management functions
 546:.\StdPeriphLib\src/stm32f0xx_adc.c ****  *
 547:.\StdPeriphLib\src/stm32f0xx_adc.c **** @verbatim
 548:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ===============================================================================
 549:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ##### Temperature Sensor, Vrefint  and Vbat management function #####
 550:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ===============================================================================
 551:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] This section provides a function allowing to enable/disable the internal 
 552:.\StdPeriphLib\src/stm32f0xx_adc.c ****          connections between the ADC and the Temperature Sensor, the Vrefint and
 553:.\StdPeriphLib\src/stm32f0xx_adc.c ****          Vbat source.
 554:.\StdPeriphLib\src/stm32f0xx_adc.c ****      
 555:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] A typical configuration to get the Temperature sensor, Vrefint and Vbat channels 
 556:.\StdPeriphLib\src/stm32f0xx_adc.c ****          voltages is done following these steps :
 557:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (#) Enable the internal connection of Temperature sensor, Vrefint or Vbat sources 
 558:.\StdPeriphLib\src/stm32f0xx_adc.c ****              with the ADC channels using ADC_TempSensorCmd(), ADC_VrefintCmd() or ADC_VbatCmd()
 559:.\StdPeriphLib\src/stm32f0xx_adc.c ****              functions. 
 560:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (#) select the ADC_Channel_16(Temperature sensor), ADC_Channel_17(Vrefint)
 561:.\StdPeriphLib\src/stm32f0xx_adc.c ****              or ADC_Channel_18(Voltage battery) using ADC_ChannelConfig() function 
 562:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (#) Get the voltage values, using ADC_GetConversionValue() function
 563:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 564:.\StdPeriphLib\src/stm32f0xx_adc.c **** @endverbatim
 565:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @{
 566:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 567:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 568:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 569:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enables or disables the temperature sensor channel.
 570:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  NewState: new state of the temperature sensor input channel.
 571:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be: ENABLE or DISABLE.
 572:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 573:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 574:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_TempSensorCmd(FunctionalState NewState)
 575:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 446              		.loc 1 575 0
 447              		.cfi_startproc
 448              	.LVL28:
 576:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 577:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 578:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 579:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if (NewState != DISABLE)
 449              		.loc 1 579 0
 450 0000 0028     		cmp	r0, #0
 451 0002 06D0     		beq	.L41
 580:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 581:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Enable the temperature sensor channel*/
 582:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADC->CCR |= (uint32_t)ADC_CCR_TSEN;
 452              		.loc 1 582 0
 453 0004 064A     		ldr	r2, .L43
 454 0006 1368     		ldr	r3, [r2]
 455 0008 8021     		mov	r1, #128
 456 000a 0904     		lsl	r1, r1, #16
 457 000c 0B43     		orr	r3, r1
 458 000e 1360     		str	r3, [r2]
 459 0010 04E0     		b	.L40
 460              	.L41:
 583:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 584:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
 585:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 586:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Disable the temperature sensor channel*/
 587:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADC->CCR &= (uint32_t)(~ADC_CCR_TSEN);
 461              		.loc 1 587 0
 462 0012 034A     		ldr	r2, .L43
 463 0014 1168     		ldr	r1, [r2]
 464 0016 034B     		ldr	r3, .L43+4
 465 0018 0B40     		and	r3, r1
 466 001a 1360     		str	r3, [r2]
 467              	.L40:
 588:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 589:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 468              		.loc 1 589 0
 469              		@ sp needed
 470 001c 7047     		bx	lr
 471              	.L44:
 472 001e C046     		.align	2
 473              	.L43:
 474 0020 08270140 		.word	1073817352
 475 0024 FFFF7FFF 		.word	-8388609
 476              		.cfi_endproc
 477              	.LFE45:
 479              		.section	.text.ADC_VrefintCmd,"ax",%progbits
 480              		.align	2
 481              		.global	ADC_VrefintCmd
 482              		.code	16
 483              		.thumb_func
 485              	ADC_VrefintCmd:
 486              	.LFB46:
 590:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 591:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 592:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enables or disables the Vrefint channel.
 593:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  NewState: new state of the Vref input channel.
 594:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be: ENABLE or DISABLE.
 595:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 596:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 597:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_VrefintCmd(FunctionalState NewState)
 598:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 487              		.loc 1 598 0
 488              		.cfi_startproc
 489              	.LVL29:
 599:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 600:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 601:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 602:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if (NewState != DISABLE)
 490              		.loc 1 602 0
 491 0000 0028     		cmp	r0, #0
 492 0002 06D0     		beq	.L46
 603:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 604:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Enable the Vrefint channel*/
 605:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADC->CCR |= (uint32_t)ADC_CCR_VREFEN;
 493              		.loc 1 605 0
 494 0004 064A     		ldr	r2, .L48
 495 0006 1368     		ldr	r3, [r2]
 496 0008 8021     		mov	r1, #128
 497 000a C903     		lsl	r1, r1, #15
 498 000c 0B43     		orr	r3, r1
 499 000e 1360     		str	r3, [r2]
 500 0010 04E0     		b	.L45
 501              	.L46:
 606:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 607:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
 608:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 609:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Disable the Vrefint channel*/
 610:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADC->CCR &= (uint32_t)(~ADC_CCR_VREFEN);
 502              		.loc 1 610 0
 503 0012 034A     		ldr	r2, .L48
 504 0014 1168     		ldr	r1, [r2]
 505 0016 034B     		ldr	r3, .L48+4
 506 0018 0B40     		and	r3, r1
 507 001a 1360     		str	r3, [r2]
 508              	.L45:
 611:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 612:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 509              		.loc 1 612 0
 510              		@ sp needed
 511 001c 7047     		bx	lr
 512              	.L49:
 513 001e C046     		.align	2
 514              	.L48:
 515 0020 08270140 		.word	1073817352
 516 0024 FFFFBFFF 		.word	-4194305
 517              		.cfi_endproc
 518              	.LFE46:
 520              		.section	.text.ADC_VbatCmd,"ax",%progbits
 521              		.align	2
 522              		.global	ADC_VbatCmd
 523              		.code	16
 524              		.thumb_func
 526              	ADC_VbatCmd:
 527              	.LFB47:
 613:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 614:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 615:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enables or disables the Vbat channel. 
 616:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   This feature is not applicable for STM32F030 devices. 
 617:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  NewState: new state of the Vbat input channel.
 618:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be: ENABLE or DISABLE.
 619:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 620:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 621:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_VbatCmd(FunctionalState NewState)
 622:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 528              		.loc 1 622 0
 529              		.cfi_startproc
 530              	.LVL30:
 623:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 624:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 625:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 626:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if (NewState != DISABLE)
 531              		.loc 1 626 0
 532 0000 0028     		cmp	r0, #0
 533 0002 06D0     		beq	.L51
 627:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 628:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Enable the Vbat channel*/
 629:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADC->CCR |= (uint32_t)ADC_CCR_VBATEN;
 534              		.loc 1 629 0
 535 0004 064A     		ldr	r2, .L53
 536 0006 1368     		ldr	r3, [r2]
 537 0008 8021     		mov	r1, #128
 538 000a 4904     		lsl	r1, r1, #17
 539 000c 0B43     		orr	r3, r1
 540 000e 1360     		str	r3, [r2]
 541 0010 04E0     		b	.L50
 542              	.L51:
 630:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 631:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
 632:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 633:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Disable the Vbat channel*/
 634:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADC->CCR &= (uint32_t)(~ADC_CCR_VBATEN);
 543              		.loc 1 634 0
 544 0012 034A     		ldr	r2, .L53
 545 0014 1168     		ldr	r1, [r2]
 546 0016 034B     		ldr	r3, .L53+4
 547 0018 0B40     		and	r3, r1
 548 001a 1360     		str	r3, [r2]
 549              	.L50:
 635:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 636:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 550              		.loc 1 636 0
 551              		@ sp needed
 552 001c 7047     		bx	lr
 553              	.L54:
 554 001e C046     		.align	2
 555              	.L53:
 556 0020 08270140 		.word	1073817352
 557 0024 FFFFFFFE 		.word	-16777217
 558              		.cfi_endproc
 559              	.LFE47:
 561              		.section	.text.ADC_ChannelConfig,"ax",%progbits
 562              		.align	2
 563              		.global	ADC_ChannelConfig
 564              		.code	16
 565              		.thumb_func
 567              	ADC_ChannelConfig:
 568              	.LFB48:
 637:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 638:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 639:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @}
 640:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 641:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 642:.\StdPeriphLib\src/stm32f0xx_adc.c **** /** @defgroup ADC_Group5 Channels Configuration functions
 643:.\StdPeriphLib\src/stm32f0xx_adc.c ****  *  @brief    Channels Configuration functions 
 644:.\StdPeriphLib\src/stm32f0xx_adc.c ****  *
 645:.\StdPeriphLib\src/stm32f0xx_adc.c **** @verbatim
 646:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ===============================================================================
 647:.\StdPeriphLib\src/stm32f0xx_adc.c ****             ##### Channels Configuration functions #####
 648:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ===============================================================================
 649:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] This section provides functions allowing to manage the ADC channels,
 650:.\StdPeriphLib\src/stm32f0xx_adc.c ****          it is composed of 3 sub sections :
 651:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (#) Configuration and management functions for ADC channels: This subsection 
 652:.\StdPeriphLib\src/stm32f0xx_adc.c ****              provides functions allowing to configure the ADC channels :    
 653:.\StdPeriphLib\src/stm32f0xx_adc.c ****              (++) Select the ADC channels
 654:.\StdPeriphLib\src/stm32f0xx_adc.c ****              (++) Activate ADC Calibration
 655:.\StdPeriphLib\src/stm32f0xx_adc.c ****              (++) Activate the Overrun Mode.
 656:.\StdPeriphLib\src/stm32f0xx_adc.c ****              (++) Activate the Discontinuous Mode 
 657:.\StdPeriphLib\src/stm32f0xx_adc.c ****              (++) Activate the Continuous Mode.
 658:.\StdPeriphLib\src/stm32f0xx_adc.c ****              (++) Configure the sampling time for each channel
 659:.\StdPeriphLib\src/stm32f0xx_adc.c ****              (++) Select the conversion Trigger and Edge for ADC channels
 660:.\StdPeriphLib\src/stm32f0xx_adc.c ****              (++) Select the scan direction.
 661:.\StdPeriphLib\src/stm32f0xx_adc.c ****              -@@- Please Note that the following features for ADC channels are configurated
 662:.\StdPeriphLib\src/stm32f0xx_adc.c ****                   using the ADC_Init() function : 
 663:.\StdPeriphLib\src/stm32f0xx_adc.c ****                   (+@@) Activate the Continuous Mode (can be also activated by ADC_OverrunModeCmd()
 664:.\StdPeriphLib\src/stm32f0xx_adc.c ****                   (+@@) Select the conversion Trigger and Edge for ADC channels
 665:.\StdPeriphLib\src/stm32f0xx_adc.c ****                   (+@@) Select the scan direction.
 666:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (#) Control the ADC peripheral : This subsection permits to command the ADC:
 667:.\StdPeriphLib\src/stm32f0xx_adc.c ****              (++) Stop or discard an on-going conversion (ADSTP command)
 668:.\StdPeriphLib\src/stm32f0xx_adc.c ****              (++) Start the ADC conversion .
 669:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (#) Get the conversion data: This subsection provides an important function in 
 670:.\StdPeriphLib\src/stm32f0xx_adc.c ****              the ADC peripheral since it returns the converted data of the current 
 671:.\StdPeriphLib\src/stm32f0xx_adc.c ****              ADC channel. When the Conversion value is read, the EOC Flag is 
 672:.\StdPeriphLib\src/stm32f0xx_adc.c ****              automatically cleared.
 673:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 674:.\StdPeriphLib\src/stm32f0xx_adc.c **** @endverbatim
 675:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @{
 676:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 677:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 678:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 679:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Configures for the selected ADC and its sampling time.
 680:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC peripheral.
 681:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADC_Channel: the ADC channel to configure. 
 682:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be any combination of the following values:
 683:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_0: ADC Channel0 selected
 684:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_1: ADC Channel1 selected
 685:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_2: ADC Channel2 selected
 686:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_3: ADC Channel3 selected
 687:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_4: ADC Channel4 selected
 688:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_5: ADC Channel5 selected
 689:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_6: ADC Channel6 selected
 690:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_7: ADC Channel7 selected
 691:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_8: ADC Channel8 selected
 692:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_9: ADC Channel9 selected
 693:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_10: ADC Channel10 selected, not available for STM32F031 devices
 694:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_11: ADC Channel11 selected, not available for STM32F031 devices
 695:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_12: ADC Channel12 selected, not available for STM32F031 devices
 696:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_13: ADC Channel13 selected, not available for STM32F031 devices
 697:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_14: ADC Channel14 selected, not available for STM32F031 devices
 698:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_15: ADC Channel15 selected, not available for STM32F031 devices
 699:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_16: ADC Channel16 selected
 700:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_17: ADC Channel17 selected
 701:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_Channel_18: ADC Channel18 selected, not available for STM32F030 devices
 702:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
 703:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be one of the following values:
 704:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_SampleTime_1_5Cycles: Sample time equal to 1.5 cycles  
 705:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_SampleTime_7_5Cycles: Sample time equal to 7.5 cycles
 706:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_SampleTime_13_5Cycles: Sample time equal to 13.5 cycles
 707:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_SampleTime_28_5Cycles: Sample time equal to 28.5 cycles
 708:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_SampleTime_41_5Cycles: Sample time equal to 41.5 cycles
 709:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_SampleTime_55_5Cycles: Sample time equal to 55.5 cycles
 710:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_SampleTime_71_5Cycles: Sample time equal to 71.5 cycles
 711:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_SampleTime_239_5Cycles: Sample time equal to 239.5 cycles
 712:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 713:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 714:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_ChannelConfig(ADC_TypeDef* ADCx, uint32_t ADC_Channel, uint32_t ADC_SampleTime)
 715:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 569              		.loc 1 715 0
 570              		.cfi_startproc
 571              	.LVL31:
 716:.\StdPeriphLib\src/stm32f0xx_adc.c ****   uint32_t tmpreg = 0;
 717:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 718:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 719:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 720:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_CHANNEL(ADC_Channel));
 721:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
 722:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 723:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Configure the ADC Channel */
 724:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADCx->CHSELR |= (uint32_t)ADC_Channel;
 572              		.loc 1 724 0
 573 0000 836A     		ldr	r3, [r0, #40]
 574 0002 1943     		orr	r1, r3
 575              	.LVL32:
 576 0004 8162     		str	r1, [r0, #40]
 577              	.LVL33:
 725:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 726:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Clear the Sampling time Selection bits */
 727:.\StdPeriphLib\src/stm32f0xx_adc.c ****   tmpreg &= ~ADC_SMPR1_SMPR;
 728:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 729:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Set the ADC Sampling Time register */
 730:.\StdPeriphLib\src/stm32f0xx_adc.c ****   tmpreg |= (uint32_t)ADC_SampleTime;
 731:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 732:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Configure the ADC Sample time register */
 733:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADCx->SMPR = tmpreg ;
 578              		.loc 1 733 0
 579 0006 4261     		str	r2, [r0, #20]
 734:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 580              		.loc 1 734 0
 581              		@ sp needed
 582 0008 7047     		bx	lr
 583              		.cfi_endproc
 584              	.LFE48:
 586 000a C046     		.section	.text.ADC_ContinuousModeCmd,"ax",%progbits
 587              		.align	2
 588              		.global	ADC_ContinuousModeCmd
 589              		.code	16
 590              		.thumb_func
 592              	ADC_ContinuousModeCmd:
 593              	.LFB49:
 735:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 736:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 737:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enable the Continuous mode for the selected ADCx channels.
 738:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 739:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  NewState: new state of the Continuous mode.
 740:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be: ENABLE or DISABLE.
 741:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   It is not possible to have both discontinuous mode and continuous mode
 742:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         enabled. In this case (If DISCEN and CONT are Set), the ADC behaves 
 743:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         as if continuous mode was disabled
 744:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 745:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 746:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 747:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 594              		.loc 1 747 0
 595              		.cfi_startproc
 596              	.LVL34:
 748:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 749:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 750:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 751:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 752:.\StdPeriphLib\src/stm32f0xx_adc.c ****     if (NewState != DISABLE)
 597              		.loc 1 752 0
 598 0000 0029     		cmp	r1, #0
 599 0002 05D0     		beq	.L57
 753:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 754:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Enable the Continuous mode*/
 755:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_CONT;
 600              		.loc 1 755 0
 601 0004 C368     		ldr	r3, [r0, #12]
 602 0006 8022     		mov	r2, #128
 603 0008 9201     		lsl	r2, r2, #6
 604 000a 1343     		orr	r3, r2
 605 000c C360     		str	r3, [r0, #12]
 606 000e 03E0     		b	.L56
 607              	.L57:
 756:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 757:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
 758:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 759:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Disable the Continuous mode */
 760:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_CONT);
 608              		.loc 1 760 0
 609 0010 C268     		ldr	r2, [r0, #12]
 610 0012 024B     		ldr	r3, .L59
 611 0014 1340     		and	r3, r2
 612 0016 C360     		str	r3, [r0, #12]
 613              	.L56:
 761:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 762:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 614              		.loc 1 762 0
 615              		@ sp needed
 616 0018 7047     		bx	lr
 617              	.L60:
 618 001a C046     		.align	2
 619              	.L59:
 620 001c FFDFFFFF 		.word	-8193
 621              		.cfi_endproc
 622              	.LFE49:
 624              		.section	.text.ADC_DiscModeCmd,"ax",%progbits
 625              		.align	2
 626              		.global	ADC_DiscModeCmd
 627              		.code	16
 628              		.thumb_func
 630              	ADC_DiscModeCmd:
 631              	.LFB50:
 763:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 764:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 765:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enable the discontinuous mode for the selected ADC channels.
 766:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 767:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  NewState: new state of the discontinuous mode.
 768:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be: ENABLE or DISABLE.
 769:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   It is not possible to have both discontinuous mode and continuous mode
 770:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         enabled. In this case (If DISCEN and CONT are Set), the ADC behaves 
 771:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         as if continuous mode was disabled
 772:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 773:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 774:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 775:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 632              		.loc 1 775 0
 633              		.cfi_startproc
 634              	.LVL35:
 776:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 777:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 778:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 779:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 780:.\StdPeriphLib\src/stm32f0xx_adc.c ****     if (NewState != DISABLE)
 635              		.loc 1 780 0
 636 0000 0029     		cmp	r1, #0
 637 0002 05D0     		beq	.L62
 781:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 782:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Enable the Discontinuous mode */
 783:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_DISCEN;
 638              		.loc 1 783 0
 639 0004 C368     		ldr	r3, [r0, #12]
 640 0006 8022     		mov	r2, #128
 641 0008 5202     		lsl	r2, r2, #9
 642 000a 1343     		orr	r3, r2
 643 000c C360     		str	r3, [r0, #12]
 644 000e 03E0     		b	.L61
 645              	.L62:
 784:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 785:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
 786:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 787:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Disable the Discontinuous mode */
 788:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_DISCEN);
 646              		.loc 1 788 0
 647 0010 C268     		ldr	r2, [r0, #12]
 648 0012 024B     		ldr	r3, .L64
 649 0014 1340     		and	r3, r2
 650 0016 C360     		str	r3, [r0, #12]
 651              	.L61:
 789:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 790:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 652              		.loc 1 790 0
 653              		@ sp needed
 654 0018 7047     		bx	lr
 655              	.L65:
 656 001a C046     		.align	2
 657              	.L64:
 658 001c FFFFFEFF 		.word	-65537
 659              		.cfi_endproc
 660              	.LFE50:
 662              		.section	.text.ADC_OverrunModeCmd,"ax",%progbits
 663              		.align	2
 664              		.global	ADC_OverrunModeCmd
 665              		.code	16
 666              		.thumb_func
 668              	ADC_OverrunModeCmd:
 669              	.LFB51:
 791:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 792:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 793:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enable the Overrun mode for the selected ADC channels.
 794:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 795:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  NewState: new state of the Overrun mode.
 796:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be: ENABLE or DISABLE.
 797:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 798:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 799:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_OverrunModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 800:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 670              		.loc 1 800 0
 671              		.cfi_startproc
 672              	.LVL36:
 801:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 802:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 803:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 804:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 805:.\StdPeriphLib\src/stm32f0xx_adc.c ****     if (NewState != DISABLE)
 673              		.loc 1 805 0
 674 0000 0029     		cmp	r1, #0
 675 0002 05D0     		beq	.L67
 806:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 807:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Enable the Overrun mode */
 808:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_OVRMOD;
 676              		.loc 1 808 0
 677 0004 C368     		ldr	r3, [r0, #12]
 678 0006 8022     		mov	r2, #128
 679 0008 5201     		lsl	r2, r2, #5
 680 000a 1343     		orr	r3, r2
 681 000c C360     		str	r3, [r0, #12]
 682 000e 03E0     		b	.L66
 683              	.L67:
 809:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 810:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
 811:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 812:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Disable the Overrun mode */
 813:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_OVRMOD);
 684              		.loc 1 813 0
 685 0010 C268     		ldr	r2, [r0, #12]
 686 0012 024B     		ldr	r3, .L69
 687 0014 1340     		and	r3, r2
 688 0016 C360     		str	r3, [r0, #12]
 689              	.L66:
 814:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 815:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 690              		.loc 1 815 0
 691              		@ sp needed
 692 0018 7047     		bx	lr
 693              	.L70:
 694 001a C046     		.align	2
 695              	.L69:
 696 001c FFEFFFFF 		.word	-4097
 697              		.cfi_endproc
 698              	.LFE51:
 700              		.section	.text.ADC_GetCalibrationFactor,"ax",%progbits
 701              		.align	2
 702              		.global	ADC_GetCalibrationFactor
 703              		.code	16
 704              		.thumb_func
 706              	ADC_GetCalibrationFactor:
 707              	.LFB52:
 816:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 817:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 818:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Active the Calibration operation for the selected ADC.
 819:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   The Calibration can be initiated only when ADC is still in the 
 820:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         reset configuration (ADEN must be equal to 0).
 821:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 822:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval ADC Calibration factor 
 823:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 824:.\StdPeriphLib\src/stm32f0xx_adc.c **** uint32_t ADC_GetCalibrationFactor(ADC_TypeDef* ADCx)
 825:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 708              		.loc 1 825 0
 709              		.cfi_startproc
 710              	.LVL37:
 826:.\StdPeriphLib\src/stm32f0xx_adc.c ****   uint32_t tmpreg = 0, calibrationcounter = 0, calibrationstatus = 0;
 827:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 828:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 829:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 830:.\StdPeriphLib\src/stm32f0xx_adc.c ****   
 831:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Set the ADC calibartion */
 832:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADCx->CR |= (uint32_t)ADC_CR_ADCAL;
 711              		.loc 1 832 0
 712 0000 8368     		ldr	r3, [r0, #8]
 713 0002 8022     		mov	r2, #128
 714 0004 1206     		lsl	r2, r2, #24
 715 0006 1343     		orr	r3, r2
 716 0008 8360     		str	r3, [r0, #8]
 833:.\StdPeriphLib\src/stm32f0xx_adc.c ****   
 834:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Wait until no ADC calibration is completed */
 835:.\StdPeriphLib\src/stm32f0xx_adc.c ****   do
 836:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 837:.\StdPeriphLib\src/stm32f0xx_adc.c ****     calibrationstatus = ADCx->CR & ADC_CR_ADCAL;
 717              		.loc 1 837 0
 718 000a 8368     		ldr	r3, [r0, #8]
 719 000c DB0F     		lsr	r3, r3, #31
 720 000e DB07     		lsl	r3, r3, #31
 721              	.LVL38:
 722 0010 084A     		ldr	r2, .L77
 723 0012 05E0     		b	.L72
 724              	.LVL39:
 725              	.L74:
 726              		.loc 1 837 0 is_stmt 0 discriminator 2
 727 0014 8368     		ldr	r3, [r0, #8]
 728              	.LVL40:
 729 0016 DB0F     		lsr	r3, r3, #31
 730 0018 DB07     		lsl	r3, r3, #31
 731              	.LVL41:
 732 001a 013A     		sub	r2, r2, #1
 733              	.LVL42:
 838:.\StdPeriphLib\src/stm32f0xx_adc.c ****     calibrationcounter++;  
 839:.\StdPeriphLib\src/stm32f0xx_adc.c ****   } while((calibrationcounter != CALIBRATION_TIMEOUT) && (calibrationstatus != 0x00));
 734              		.loc 1 839 0 is_stmt 1 discriminator 2
 735 001c 002A     		cmp	r2, #0
 736 001e 01D0     		beq	.L73
 737              	.LVL43:
 738              	.L72:
 739              		.loc 1 839 0 is_stmt 0 discriminator 1
 740 0020 002B     		cmp	r3, #0
 741 0022 F7D1     		bne	.L74
 742              	.LVL44:
 743              	.L73:
 840:.\StdPeriphLib\src/stm32f0xx_adc.c ****     
 841:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if((uint32_t)(ADCx->CR & ADC_CR_ADCAL) == RESET)
 744              		.loc 1 841 0 is_stmt 1
 745 0024 8368     		ldr	r3, [r0, #8]
 746              	.LVL45:
 747 0026 002B     		cmp	r3, #0
 748 0028 01DB     		blt	.L76
 842:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 843:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /*Get the calibration factor from the ADC data register */
 844:.\StdPeriphLib\src/stm32f0xx_adc.c ****     tmpreg = ADCx->DR;
 749              		.loc 1 844 0
 750 002a 006C     		ldr	r0, [r0, #64]
 751              	.LVL46:
 752 002c 00E0     		b	.L75
 753              	.LVL47:
 754              	.L76:
 845:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 846:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
 847:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 848:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Error factor */
 849:.\StdPeriphLib\src/stm32f0xx_adc.c ****     tmpreg = 0x00000000;
 755              		.loc 1 849 0
 756 002e 0020     		mov	r0, #0
 757              	.LVL48:
 758              	.L75:
 850:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 851:.\StdPeriphLib\src/stm32f0xx_adc.c ****   return tmpreg;
 852:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 759              		.loc 1 852 0
 760              		@ sp needed
 761 0030 7047     		bx	lr
 762              	.L78:
 763 0032 C046     		.align	2
 764              	.L77:
 765 0034 FFEF0000 		.word	61439
 766              		.cfi_endproc
 767              	.LFE52:
 769              		.section	.text.ADC_StopOfConversion,"ax",%progbits
 770              		.align	2
 771              		.global	ADC_StopOfConversion
 772              		.code	16
 773              		.thumb_func
 775              	ADC_StopOfConversion:
 776              	.LFB53:
 853:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 854:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 855:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Stop the on going conversions for the selected ADC.
 856:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   When ADSTP is set, any on going conversion is aborted, and the ADC 
 857:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         data register is not updated with current conversion. 
 858:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 859:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 860:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 861:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_StopOfConversion(ADC_TypeDef* ADCx)
 862:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 777              		.loc 1 862 0
 778              		.cfi_startproc
 779              	.LVL49:
 863:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 864:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 865:.\StdPeriphLib\src/stm32f0xx_adc.c ****   
 866:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADCx->CR |= (uint32_t)ADC_CR_ADSTP;
 780              		.loc 1 866 0
 781 0000 8268     		ldr	r2, [r0, #8]
 782 0002 1023     		mov	r3, #16
 783 0004 1343     		orr	r3, r2
 784 0006 8360     		str	r3, [r0, #8]
 867:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 785              		.loc 1 867 0
 786              		@ sp needed
 787 0008 7047     		bx	lr
 788              		.cfi_endproc
 789              	.LFE53:
 791 000a C046     		.section	.text.ADC_StartOfConversion,"ax",%progbits
 792              		.align	2
 793              		.global	ADC_StartOfConversion
 794              		.code	16
 795              		.thumb_func
 797              	ADC_StartOfConversion:
 798              	.LFB54:
 868:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 869:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 870:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Start Conversion for the selected ADC channels.
 871:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @note   In continuous mode, ADSTART is not cleared by hardware with the 
 872:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *         assertion of EOSEQ because the sequence is automatic relaunched
 873:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 874:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 875:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 876:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_StartOfConversion(ADC_TypeDef* ADCx)
 877:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 799              		.loc 1 877 0
 800              		.cfi_startproc
 801              	.LVL50:
 878:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 879:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 880:.\StdPeriphLib\src/stm32f0xx_adc.c ****   
 881:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADCx->CR |= (uint32_t)ADC_CR_ADSTART;
 802              		.loc 1 881 0
 803 0000 8268     		ldr	r2, [r0, #8]
 804 0002 0423     		mov	r3, #4
 805 0004 1343     		orr	r3, r2
 806 0006 8360     		str	r3, [r0, #8]
 882:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 807              		.loc 1 882 0
 808              		@ sp needed
 809 0008 7047     		bx	lr
 810              		.cfi_endproc
 811              	.LFE54:
 813 000a C046     		.section	.text.ADC_GetConversionValue,"ax",%progbits
 814              		.align	2
 815              		.global	ADC_GetConversionValue
 816              		.code	16
 817              		.thumb_func
 819              	ADC_GetConversionValue:
 820              	.LFB55:
 883:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 884:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 885:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Returns the last ADCx conversion result data for ADC channel.  
 886:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 887:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval The Data conversion value.
 888:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 889:.\StdPeriphLib\src/stm32f0xx_adc.c **** uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
 890:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 821              		.loc 1 890 0
 822              		.cfi_startproc
 823              	.LVL51:
 891:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 892:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 893:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 894:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Return the selected ADC conversion value */
 895:.\StdPeriphLib\src/stm32f0xx_adc.c ****   return (uint16_t) ADCx->DR;
 824              		.loc 1 895 0
 825 0000 006C     		ldr	r0, [r0, #64]
 826              	.LVL52:
 827 0002 80B2     		uxth	r0, r0
 896:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 828              		.loc 1 896 0
 829              		@ sp needed
 830 0004 7047     		bx	lr
 831              		.cfi_endproc
 832              	.LFE55:
 834 0006 C046     		.section	.text.ADC_DMACmd,"ax",%progbits
 835              		.align	2
 836              		.global	ADC_DMACmd
 837              		.code	16
 838              		.thumb_func
 840              	ADC_DMACmd:
 841              	.LFB56:
 897:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 898:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 899:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @}
 900:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 901:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 902:.\StdPeriphLib\src/stm32f0xx_adc.c **** /** @defgroup ADC_Group6 DMA Configuration functions
 903:.\StdPeriphLib\src/stm32f0xx_adc.c ****  *  @brief   Regular Channels DMA Configuration functions 
 904:.\StdPeriphLib\src/stm32f0xx_adc.c ****  *
 905:.\StdPeriphLib\src/stm32f0xx_adc.c **** @verbatim
 906:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ===============================================================================
 907:.\StdPeriphLib\src/stm32f0xx_adc.c ****           ##### DMA Configuration functions #####
 908:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ===============================================================================
 909:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] This section provides functions allowing to configure the DMA for ADC hannels.
 910:.\StdPeriphLib\src/stm32f0xx_adc.c ****          Since converted channel values are stored into a unique data register, 
 911:.\StdPeriphLib\src/stm32f0xx_adc.c ****          it is useful to use DMA for conversion of more than one channel. This 
 912:.\StdPeriphLib\src/stm32f0xx_adc.c ****          avoids the loss of the data already stored in the ADC Data register. 
 913:.\StdPeriphLib\src/stm32f0xx_adc.c ****          When the DMA mode is enabled (using the ADC_DMACmd() function), after each
 914:.\StdPeriphLib\src/stm32f0xx_adc.c ****          conversion of a channel, a DMA request is generated.
 915:.\StdPeriphLib\src/stm32f0xx_adc.c ****   
 916:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] Depending on the "DMA disable selection" configuration (using the 
 917:.\StdPeriphLib\src/stm32f0xx_adc.c ****          ADC_DMARequestModeConfig() function), at the end of the last DMA 
 918:.\StdPeriphLib\src/stm32f0xx_adc.c ****          transfer, two possibilities are allowed:
 919:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (+) No new DMA request is issued to the DMA controller (One Shot Mode) 
 920:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (+) Requests can continue to be generated (Circular Mode).
 921:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 922:.\StdPeriphLib\src/stm32f0xx_adc.c **** @endverbatim
 923:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @{
 924:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 925:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 926:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 927:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enables or disables the specified ADC DMA request.
 928:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 929:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  NewState: new state of the selected ADC DMA transfer.
 930:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be: ENABLE or DISABLE.
 931:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
 932:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 933:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 934:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 842              		.loc 1 934 0
 843              		.cfi_startproc
 844              	.LVL53:
 935:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 936:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 937:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 938:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 939:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if (NewState != DISABLE)
 845              		.loc 1 939 0
 846 0000 0029     		cmp	r1, #0
 847 0002 04D0     		beq	.L83
 940:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 941:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Enable the selected ADC DMA request */
 942:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_DMAEN;
 848              		.loc 1 942 0
 849 0004 C268     		ldr	r2, [r0, #12]
 850 0006 0123     		mov	r3, #1
 851 0008 1343     		orr	r3, r2
 852 000a C360     		str	r3, [r0, #12]
 853 000c 03E0     		b	.L82
 854              	.L83:
 943:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 944:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
 945:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 946:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Disable the selected ADC DMA request */
 947:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_DMAEN);
 855              		.loc 1 947 0
 856 000e C368     		ldr	r3, [r0, #12]
 857 0010 0122     		mov	r2, #1
 858 0012 9343     		bic	r3, r2
 859 0014 C360     		str	r3, [r0, #12]
 860              	.L82:
 948:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 949:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 861              		.loc 1 949 0
 862              		@ sp needed
 863 0016 7047     		bx	lr
 864              		.cfi_endproc
 865              	.LFE56:
 867              		.section	.text.ADC_DMARequestModeConfig,"ax",%progbits
 868              		.align	2
 869              		.global	ADC_DMARequestModeConfig
 870              		.code	16
 871              		.thumb_func
 873              	ADC_DMARequestModeConfig:
 874              	.LFB57:
 950:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 951:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 952:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enables or disables the ADC DMA request after last transfer (Single-ADC mode)
 953:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
 954:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADC_DMARequestMode: the ADC channel to configure. 
 955:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be one of the following values:
 956:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_DMAMode_OneShot: DMA One Shot Mode 
 957:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_DMAMode_Circular: DMA Circular Mode  
 958:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *  @retval None
 959:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 960:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_DMARequestModeConfig(ADC_TypeDef* ADCx, uint32_t ADC_DMARequestMode)
 961:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 875              		.loc 1 961 0
 876              		.cfi_startproc
 877              	.LVL54:
 962:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
 963:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 964:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 965:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_DMACFG;
 878              		.loc 1 965 0
 879 0000 C368     		ldr	r3, [r0, #12]
 880 0002 0222     		mov	r2, #2
 881 0004 9343     		bic	r3, r2
 882 0006 C360     		str	r3, [r0, #12]
 966:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADCx->CFGR1 |= (uint32_t)ADC_DMARequestMode;
 883              		.loc 1 966 0
 884 0008 C368     		ldr	r3, [r0, #12]
 885 000a 1943     		orr	r1, r3
 886              	.LVL55:
 887 000c C160     		str	r1, [r0, #12]
 967:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 888              		.loc 1 967 0
 889              		@ sp needed
 890 000e 7047     		bx	lr
 891              		.cfi_endproc
 892              	.LFE57:
 894              		.section	.text.ADC_ITConfig,"ax",%progbits
 895              		.align	2
 896              		.global	ADC_ITConfig
 897              		.code	16
 898              		.thumb_func
 900              	ADC_ITConfig:
 901              	.LFB58:
 968:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 969:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
 970:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @}
 971:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
 972:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 973:.\StdPeriphLib\src/stm32f0xx_adc.c **** /** @defgroup ADC_Group7 Interrupts and flags management functions
 974:.\StdPeriphLib\src/stm32f0xx_adc.c ****  *  @brief   Interrupts and flags management functions.
 975:.\StdPeriphLib\src/stm32f0xx_adc.c ****  *
 976:.\StdPeriphLib\src/stm32f0xx_adc.c **** @verbatim   
 977:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ===============================================================================
 978:.\StdPeriphLib\src/stm32f0xx_adc.c ****             ##### Interrupts and flags management functions #####
 979:.\StdPeriphLib\src/stm32f0xx_adc.c ****  ===============================================================================
 980:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] This section provides functions allowing to configure the ADC Interrupts 
 981:.\StdPeriphLib\src/stm32f0xx_adc.c ****          and get the status and clear flags and Interrupts pending bits.
 982:.\StdPeriphLib\src/stm32f0xx_adc.c ****   
 983:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] The ADC provide 6 Interrupts sources and 11 Flags which can be divided into 
 984:.\StdPeriphLib\src/stm32f0xx_adc.c ****          3 groups:
 985:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 986:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *** Flags for ADC status ***
 987:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ======================================================
 988:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..]
 989:.\StdPeriphLib\src/stm32f0xx_adc.c ****         (+)Flags :
 990:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_FLAG_ADRDY : This flag is set after the ADC has been enabled (bit ADEN=1)
 991:.\StdPeriphLib\src/stm32f0xx_adc.c ****                and when the ADC reaches a state where it is ready to accept conversion requests
 992:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_FLAG_ADEN : This flag is set by software to enable the ADC.
 993:.\StdPeriphLib\src/stm32f0xx_adc.c ****                 The ADC will be effectively ready to operate once the ADRDY flag has been set.
 994:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_FLAG_ADDIS : This flag is cleared once the ADC is effectively
 995:.\StdPeriphLib\src/stm32f0xx_adc.c ****                 disabled.
 996:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_FLAG_ADSTART : This flag is cleared after the execution of
 997:.\StdPeriphLib\src/stm32f0xx_adc.c ****                 ADC_StopOfConversion() function, at the same time as the ADSTP bit is
 998:.\StdPeriphLib\src/stm32f0xx_adc.c ****                 cleared by hardware
 999:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_FLAG_ADSTP : This flag is cleared by hardware when the conversion
1000:.\StdPeriphLib\src/stm32f0xx_adc.c ****                 is effectively discarded and the ADC is ready to accept a new start conversion
1001:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_FLAG_ADCAL : This flag is set once the calibration is complete.
1002:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1003:.\StdPeriphLib\src/stm32f0xx_adc.c ****         (+)Interrupts 
1004:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_IT_ADRDY : specifies the interrupt source for ADC ready event.
1005:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1006:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *** Flags and Interrupts for ADC channel conversion ***
1007:.\StdPeriphLib\src/stm32f0xx_adc.c ****   =====================================================
1008:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..]
1009:.\StdPeriphLib\src/stm32f0xx_adc.c ****         (+)Flags :
1010:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_FLAG_EOC : This flag is set by hardware at the end of each conversion
1011:.\StdPeriphLib\src/stm32f0xx_adc.c ****                 of a channel when a new data result is available in the data register
1012:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_FLAG_EOSEQ : This bit is set by hardware at the end of the conversion
1013:.\StdPeriphLib\src/stm32f0xx_adc.c ****                 of a sequence of channels selected by ADC_ChannelConfig() function.
1014:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_FLAG_EOSMP : This bit is set by hardware at the end of the sampling phase.
1015:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_FLAG_OVR : This flag is set by hardware when an overrun occurs,
1016:.\StdPeriphLib\src/stm32f0xx_adc.c ****                 meaning that a new conversion has complete while the EOC flag was already set.
1017:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1018:.\StdPeriphLib\src/stm32f0xx_adc.c ****         (+)Interrupts :
1019:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_IT_EOC : specifies the interrupt source for end of conversion event.
1020:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_IT_EOSEQ : specifies the interrupt source for end of sequence event.
1021:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_IT_EOSMP : specifies the interrupt source for end of sampling event.
1022:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_IT_OVR : specifies the interrupt source for Overrun detection 
1023:.\StdPeriphLib\src/stm32f0xx_adc.c ****                 event.
1024:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1025:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *** Flags and Interrupts for the Analog Watchdog ***
1026:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ================================================
1027:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..]
1028:.\StdPeriphLib\src/stm32f0xx_adc.c ****         (+)Flags :
1029:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_FLAG_AWD: This flag is set by hardware when the converted
1030:.\StdPeriphLib\src/stm32f0xx_adc.c ****                 voltage crosses the values programmed thrsholds
1031:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1032:.\StdPeriphLib\src/stm32f0xx_adc.c ****         (+)Interrupts :
1033:.\StdPeriphLib\src/stm32f0xx_adc.c ****            (##) ADC_IT_AWD : specifies the interrupt source for Analog watchdog 
1034:.\StdPeriphLib\src/stm32f0xx_adc.c ****                 event.
1035:.\StdPeriphLib\src/stm32f0xx_adc.c ****   
1036:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] The user should identify which mode will be used in his application to 
1037:.\StdPeriphLib\src/stm32f0xx_adc.c ****          manage the ADC controller events: Polling mode or Interrupt mode.
1038:.\StdPeriphLib\src/stm32f0xx_adc.c ****   
1039:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] In the Polling Mode it is advised to use the following functions:
1040:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (+) ADC_GetFlagStatus() : to check if flags events occur.
1041:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (+) ADC_ClearFlag()     : to clear the flags events.
1042:.\StdPeriphLib\src/stm32f0xx_adc.c ****   
1043:.\StdPeriphLib\src/stm32f0xx_adc.c ****     [..] In the Interrupt Mode it is advised to use the following functions:
1044:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (+) ADC_ITConfig()       : to enable or disable the interrupt source.
1045:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (+) ADC_GetITStatus()    : to check if Interrupt occurs.
1046:.\StdPeriphLib\src/stm32f0xx_adc.c ****          (+) ADC_ClearITPendingBit() : to clear the Interrupt pending Bit 
1047:.\StdPeriphLib\src/stm32f0xx_adc.c ****              (corresponding Flag).
1048:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1049:.\StdPeriphLib\src/stm32f0xx_adc.c **** @endverbatim
1050:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @{
1051:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
1052:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1053:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
1054:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Enables or disables the specified ADC interrupts.
1055:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC peripheral.
1056:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled.
1057:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be one of the following values:
1058:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_ADRDY: ADC ready interrupt 
1059:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_EOSMP: End of sampling interrupt
1060:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_EOC: End of conversion interrupt 
1061:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_EOSEQ: End of sequence of conversion interrupt
1062:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_OVR: overrun interrupt
1063:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_AWD: Analog watchdog interrupt
1064:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  NewState: new state of the specified ADC interrupts.
1065:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be: ENABLE or DISABLE.
1066:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
1067:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
1068:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_ITConfig(ADC_TypeDef* ADCx, uint32_t ADC_IT, FunctionalState NewState)
1069:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 902              		.loc 1 1069 0
 903              		.cfi_startproc
 904              	.LVL56:
1070:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
1071:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1072:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1073:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_CONFIG_IT(ADC_IT)); 
1074:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1075:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if (NewState != DISABLE)
 905              		.loc 1 1075 0
 906 0000 002A     		cmp	r2, #0
 907 0002 03D0     		beq	.L87
1076:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
1077:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Enable the selected ADC interrupts */
1078:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->IER |= ADC_IT;
 908              		.loc 1 1078 0
 909 0004 4368     		ldr	r3, [r0, #4]
 910 0006 1943     		orr	r1, r3
 911              	.LVL57:
 912 0008 4160     		str	r1, [r0, #4]
 913 000a 02E0     		b	.L86
 914              	.LVL58:
 915              	.L87:
1079:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
1080:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
1081:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
1082:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* Disable the selected ADC interrupts */
1083:.\StdPeriphLib\src/stm32f0xx_adc.c ****     ADCx->IER &= (~(uint32_t)ADC_IT);
 916              		.loc 1 1083 0
 917 000c 4368     		ldr	r3, [r0, #4]
 918 000e 8B43     		bic	r3, r1
 919 0010 4360     		str	r3, [r0, #4]
 920              	.LVL59:
 921              	.L86:
1084:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
1085:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 922              		.loc 1 1085 0
 923              		@ sp needed
 924 0012 7047     		bx	lr
 925              		.cfi_endproc
 926              	.LFE58:
 928              		.section	.text.ADC_GetFlagStatus,"ax",%progbits
 929              		.align	2
 930              		.global	ADC_GetFlagStatus
 931              		.code	16
 932              		.thumb_func
 934              	ADC_GetFlagStatus:
 935              	.LFB59:
1086:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1087:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
1088:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Checks whether the specified ADC flag is set or not.
1089:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
1090:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADC_FLAG: specifies the flag to check. 
1091:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be one of the following values:
1092:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_AWD: Analog watchdog flag
1093:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_OVR: Overrun flag 
1094:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_EOSEQ: End of Sequence flag
1095:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_EOC: End of conversion flag
1096:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_EOSMP: End of sampling flag
1097:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_ADRDY: ADC Ready flag
1098:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_ADEN: ADC enable flag 
1099:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_ADDIS: ADC disable flag 
1100:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_ADSTART: ADC start flag 
1101:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_ADSTP: ADC stop flag
1102:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_ADCAL: ADC Calibration flag
1103:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval The new state of ADC_FLAG (SET or RESET).
1104:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
1105:.\StdPeriphLib\src/stm32f0xx_adc.c **** FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint32_t ADC_FLAG)
1106:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 936              		.loc 1 1106 0
 937              		.cfi_startproc
 938              	.LVL60:
1107:.\StdPeriphLib\src/stm32f0xx_adc.c ****   FlagStatus bitstatus = RESET;
1108:.\StdPeriphLib\src/stm32f0xx_adc.c ****   uint32_t tmpreg = 0;
1109:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1110:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
1111:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1112:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
1113:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1114:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if((uint32_t)(ADC_FLAG & 0x01000000))
 939              		.loc 1 1114 0
 940 0000 CB01     		lsl	r3, r1, #7
 941 0002 03D5     		bpl	.L90
1115:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
1116:.\StdPeriphLib\src/stm32f0xx_adc.c ****     tmpreg = ADCx->CR & 0xFEFFFFFF;
 942              		.loc 1 1116 0
 943 0004 8068     		ldr	r0, [r0, #8]
 944              	.LVL61:
 945 0006 044B     		ldr	r3, .L92
 946 0008 1840     		and	r0, r3
 947              	.LVL62:
 948 000a 00E0     		b	.L91
 949              	.LVL63:
 950              	.L90:
1117:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
1118:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
1119:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
1120:.\StdPeriphLib\src/stm32f0xx_adc.c ****     tmpreg = ADCx->ISR;
 951              		.loc 1 1120 0
 952 000c 0068     		ldr	r0, [r0]
 953              	.LVL64:
 954              	.L91:
1121:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
1122:.\StdPeriphLib\src/stm32f0xx_adc.c ****   
1123:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the status of the specified ADC flag */
1124:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if ((tmpreg & ADC_FLAG) != (uint32_t)RESET)
 955              		.loc 1 1124 0
 956 000e 0840     		and	r0, r1
 957              	.LVL65:
 958 0010 411E     		sub	r1, r0, #1
 959 0012 8841     		sbc	r0, r0, r1
 960              	.LVL66:
1125:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
1126:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* ADC_FLAG is set */
1127:.\StdPeriphLib\src/stm32f0xx_adc.c ****     bitstatus = SET;
1128:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
1129:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
1130:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
1131:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* ADC_FLAG is reset */
1132:.\StdPeriphLib\src/stm32f0xx_adc.c ****     bitstatus = RESET;
1133:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
1134:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Return the ADC_FLAG status */
1135:.\StdPeriphLib\src/stm32f0xx_adc.c ****   return  bitstatus;
 961              		.loc 1 1135 0
 962 0014 C0B2     		uxtb	r0, r0
1136:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 963              		.loc 1 1136 0
 964              		@ sp needed
 965 0016 7047     		bx	lr
 966              	.L93:
 967              		.align	2
 968              	.L92:
 969 0018 FFFFFFFE 		.word	-16777217
 970              		.cfi_endproc
 971              	.LFE59:
 973              		.section	.text.ADC_ClearFlag,"ax",%progbits
 974              		.align	2
 975              		.global	ADC_ClearFlag
 976              		.code	16
 977              		.thumb_func
 979              	ADC_ClearFlag:
 980              	.LFB60:
1137:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1138:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
1139:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Clears the ADCx's pending flags.
1140:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
1141:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADC_FLAG: specifies the flag to clear. 
1142:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be any combination of the following values:
1143:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_AWD: Analog watchdog flag
1144:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_EOC: End of conversion flag
1145:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_ADRDY: ADC Ready flag
1146:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_EOSMP: End of sampling flag
1147:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_EOSEQ: End of Sequence flag
1148:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_FLAG_OVR: Overrun flag 
1149:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
1150:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
1151:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_ClearFlag(ADC_TypeDef* ADCx, uint32_t ADC_FLAG)
1152:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 981              		.loc 1 1152 0
 982              		.cfi_startproc
 983              	.LVL67:
1153:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
1154:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1155:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
1156:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1157:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Clear the selected ADC flags */
1158:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADCx->ISR = (uint32_t)ADC_FLAG;
 984              		.loc 1 1158 0
 985 0000 0160     		str	r1, [r0]
1159:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 986              		.loc 1 1159 0
 987              		@ sp needed
 988 0002 7047     		bx	lr
 989              		.cfi_endproc
 990              	.LFE60:
 992              		.section	.text.ADC_GetITStatus,"ax",%progbits
 993              		.align	2
 994              		.global	ADC_GetITStatus
 995              		.code	16
 996              		.thumb_func
 998              	ADC_GetITStatus:
 999              	.LFB61:
1160:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1161:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
1162:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Checks whether the specified ADC interrupt has occurred or not.
1163:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral
1164:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADC_IT: specifies the ADC interrupt source to check.
1165:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be one of the following values:
1166:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_ADRDY: ADC ready interrupt 
1167:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_EOSMP: End of sampling interrupt
1168:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_EOC: End of conversion interrupt 
1169:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_EOSEQ: End of sequence of conversion interrupt
1170:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_OVR: overrun interrupt
1171:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_AWD: Analog watchdog interrupt
1172:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval The new state of ADC_IT (SET or RESET).
1173:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
1174:.\StdPeriphLib\src/stm32f0xx_adc.c **** ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint32_t ADC_IT)
1175:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 1000              		.loc 1 1175 0
 1001              		.cfi_startproc
 1002              	.LVL68:
1176:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ITStatus bitstatus = RESET;
1177:.\StdPeriphLib\src/stm32f0xx_adc.c ****   uint32_t enablestatus = 0;
1178:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1179:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
1180:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1181:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_GET_IT(ADC_IT));
1182:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1183:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Get the ADC_IT enable bit status */
1184:.\StdPeriphLib\src/stm32f0xx_adc.c ****   enablestatus = (uint32_t)(ADCx->IER & ADC_IT); 
 1003              		.loc 1 1184 0
 1004 0000 4268     		ldr	r2, [r0, #4]
 1005              	.LVL69:
1185:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1186:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the status of the specified ADC interrupt */
1187:.\StdPeriphLib\src/stm32f0xx_adc.c ****   if (((uint32_t)(ADCx->ISR & ADC_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 1006              		.loc 1 1187 0
 1007 0002 0368     		ldr	r3, [r0]
1188:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
1189:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* ADC_IT is set */
1190:.\StdPeriphLib\src/stm32f0xx_adc.c ****     bitstatus = SET;
1191:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
1192:.\StdPeriphLib\src/stm32f0xx_adc.c ****   else
1193:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
1194:.\StdPeriphLib\src/stm32f0xx_adc.c ****     /* ADC_IT is reset */
1195:.\StdPeriphLib\src/stm32f0xx_adc.c ****     bitstatus = RESET;
 1008              		.loc 1 1195 0
 1009 0004 0020     		mov	r0, #0
 1010              	.LVL70:
1187:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 1011              		.loc 1 1187 0
 1012 0006 0B42     		tst	r3, r1
 1013 0008 03D0     		beq	.L96
1184:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
 1014              		.loc 1 1184 0 discriminator 1
 1015 000a 1140     		and	r1, r2
 1016              	.LVL71:
1187:.\StdPeriphLib\src/stm32f0xx_adc.c ****   {
 1017              		.loc 1 1187 0 discriminator 1
 1018 000c 481E     		sub	r0, r1, #1
 1019 000e 8141     		sbc	r1, r1, r0
 1020              	.LVL72:
1190:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
 1021              		.loc 1 1190 0 discriminator 1
 1022 0010 C8B2     		uxtb	r0, r1
 1023              	.L96:
 1024              	.LVL73:
1196:.\StdPeriphLib\src/stm32f0xx_adc.c ****   }
1197:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Return the ADC_IT status */
1198:.\StdPeriphLib\src/stm32f0xx_adc.c ****   return  bitstatus;
1199:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 1025              		.loc 1 1199 0
 1026              		@ sp needed
 1027 0012 7047     		bx	lr
 1028              		.cfi_endproc
 1029              	.LFE61:
 1031              		.section	.text.ADC_ClearITPendingBit,"ax",%progbits
 1032              		.align	2
 1033              		.global	ADC_ClearITPendingBit
 1034              		.code	16
 1035              		.thumb_func
 1037              	ADC_ClearITPendingBit:
 1038              	.LFB62:
1200:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1201:.\StdPeriphLib\src/stm32f0xx_adc.c **** /**
1202:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @brief  Clears the ADCx's interrupt pending bits.
1203:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
1204:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
1205:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *          This parameter can be one of the following values:
1206:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_ADRDY: ADC ready interrupt
1207:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_EOSMP: End of sampling interrupt
1208:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_EOC: End of conversion interrupt
1209:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_EOSEQ: End of sequence of conversion interrupt
1210:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_OVR: overrun interrupt
1211:.\StdPeriphLib\src/stm32f0xx_adc.c ****   *            @arg ADC_IT_AWD: Analog watchdog interrupt
1212:.\StdPeriphLib\src/stm32f0xx_adc.c ****   * @retval None
1213:.\StdPeriphLib\src/stm32f0xx_adc.c ****   */
1214:.\StdPeriphLib\src/stm32f0xx_adc.c **** void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint32_t ADC_IT)
1215:.\StdPeriphLib\src/stm32f0xx_adc.c **** {
 1039              		.loc 1 1215 0
 1040              		.cfi_startproc
 1041              	.LVL74:
1216:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Check the parameters */
1217:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1218:.\StdPeriphLib\src/stm32f0xx_adc.c ****   assert_param(IS_ADC_CLEAR_IT(ADC_IT));
1219:.\StdPeriphLib\src/stm32f0xx_adc.c **** 
1220:.\StdPeriphLib\src/stm32f0xx_adc.c ****   /* Clear the selected ADC interrupt pending bits */
1221:.\StdPeriphLib\src/stm32f0xx_adc.c ****   ADCx->ISR = (uint32_t)ADC_IT; 
 1042              		.loc 1 1221 0
 1043 0000 0160     		str	r1, [r0]
1222:.\StdPeriphLib\src/stm32f0xx_adc.c **** }
 1044              		.loc 1 1222 0
 1045              		@ sp needed
 1046 0002 7047     		bx	lr
 1047              		.cfi_endproc
 1048              	.LFE62:
 1050              		.text
 1051              	.Letext0:
 1052              		.file 2 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 1053              		.file 3 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 1054              		.file 4 ".\\CMSIS/stm32f0xx.h"
 1055              		.file 5 ".\\StdPeriphLib\\inc/stm32f0xx_adc.h"
 1056              		.file 6 ".\\StdPeriphLib\\inc/stm32f0xx_rcc.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f0xx_adc.c
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:18     .text.ADC_DeInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:23     .text.ADC_DeInit:00000000 ADC_DeInit
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:58     .text.ADC_DeInit:00000020 $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:63     .text.ADC_Init:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:68     .text.ADC_Init:00000000 ADC_Init
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:110    .text.ADC_Init:00000028 $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:115    .text.ADC_StructInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:120    .text.ADC_StructInit:00000000 ADC_StructInit
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:145    .text.ADC_Cmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:150    .text.ADC_Cmd:00000000 ADC_Cmd
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:178    .text.ADC_ClockModeConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:183    .text.ADC_ClockModeConfig:00000000 ADC_ClockModeConfig
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:197    .text.ADC_JitterCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:202    .text.ADC_JitterCmd:00000000 ADC_JitterCmd
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:231    .text.ADC_AutoPowerOffCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:236    .text.ADC_AutoPowerOffCmd:00000000 ADC_AutoPowerOffCmd
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:264    .text.ADC_AutoPowerOffCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:269    .text.ADC_WaitModeCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:274    .text.ADC_WaitModeCmd:00000000 ADC_WaitModeCmd
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:302    .text.ADC_WaitModeCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:307    .text.ADC_AnalogWatchdogCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:312    .text.ADC_AnalogWatchdogCmd:00000000 ADC_AnalogWatchdogCmd
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:340    .text.ADC_AnalogWatchdogCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:345    .text.ADC_AnalogWatchdogThresholdsConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:350    .text.ADC_AnalogWatchdogThresholdsConfig:00000000 ADC_AnalogWatchdogThresholdsConfig
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:368    .text.ADC_AnalogWatchdogSingleChannelConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:373    .text.ADC_AnalogWatchdogSingleChannelConfig:00000000 ADC_AnalogWatchdogSingleChannelConfig
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:396    .text.ADC_AnalogWatchdogSingleChannelConfig:0000000c $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:401    .text.ADC_AnalogWatchdogSingleChannelCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:406    .text.ADC_AnalogWatchdogSingleChannelCmd:00000000 ADC_AnalogWatchdogSingleChannelCmd
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:434    .text.ADC_AnalogWatchdogSingleChannelCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:439    .text.ADC_TempSensorCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:444    .text.ADC_TempSensorCmd:00000000 ADC_TempSensorCmd
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:474    .text.ADC_TempSensorCmd:00000020 $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:480    .text.ADC_VrefintCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:485    .text.ADC_VrefintCmd:00000000 ADC_VrefintCmd
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:515    .text.ADC_VrefintCmd:00000020 $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:521    .text.ADC_VbatCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:526    .text.ADC_VbatCmd:00000000 ADC_VbatCmd
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:556    .text.ADC_VbatCmd:00000020 $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:562    .text.ADC_ChannelConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:567    .text.ADC_ChannelConfig:00000000 ADC_ChannelConfig
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:587    .text.ADC_ContinuousModeCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:592    .text.ADC_ContinuousModeCmd:00000000 ADC_ContinuousModeCmd
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:620    .text.ADC_ContinuousModeCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:625    .text.ADC_DiscModeCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:630    .text.ADC_DiscModeCmd:00000000 ADC_DiscModeCmd
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:658    .text.ADC_DiscModeCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:663    .text.ADC_OverrunModeCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:668    .text.ADC_OverrunModeCmd:00000000 ADC_OverrunModeCmd
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:696    .text.ADC_OverrunModeCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:701    .text.ADC_GetCalibrationFactor:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:706    .text.ADC_GetCalibrationFactor:00000000 ADC_GetCalibrationFactor
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:765    .text.ADC_GetCalibrationFactor:00000034 $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:770    .text.ADC_StopOfConversion:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:775    .text.ADC_StopOfConversion:00000000 ADC_StopOfConversion
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:792    .text.ADC_StartOfConversion:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:797    .text.ADC_StartOfConversion:00000000 ADC_StartOfConversion
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:814    .text.ADC_GetConversionValue:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:819    .text.ADC_GetConversionValue:00000000 ADC_GetConversionValue
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:835    .text.ADC_DMACmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:840    .text.ADC_DMACmd:00000000 ADC_DMACmd
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:868    .text.ADC_DMARequestModeConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:873    .text.ADC_DMARequestModeConfig:00000000 ADC_DMARequestModeConfig
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:895    .text.ADC_ITConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:900    .text.ADC_ITConfig:00000000 ADC_ITConfig
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:929    .text.ADC_GetFlagStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:934    .text.ADC_GetFlagStatus:00000000 ADC_GetFlagStatus
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:969    .text.ADC_GetFlagStatus:00000018 $d
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:974    .text.ADC_ClearFlag:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:979    .text.ADC_ClearFlag:00000000 ADC_ClearFlag
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:993    .text.ADC_GetITStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:998    .text.ADC_GetITStatus:00000000 ADC_GetITStatus
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:1032   .text.ADC_ClearITPendingBit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cchItYrc.s:1037   .text.ADC_ClearITPendingBit:00000000 ADC_ClearITPendingBit
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
RCC_APB2PeriphResetCmd
