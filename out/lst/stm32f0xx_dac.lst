   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"stm32f0xx_dac.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.DAC_DeInit,"ax",%progbits
  18              		.align	2
  19              		.global	DAC_DeInit
  20              		.code	16
  21              		.thumb_func
  23              	DAC_DeInit:
  24              	.LFB33:
  25              		.file 1 ".\\StdPeriphLib\\src/stm32f0xx_dac.c"
   1:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
   2:.\StdPeriphLib\src/stm32f0xx_dac.c ****   ******************************************************************************
   3:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @file    stm32f0xx_dac.c
   4:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @author  MCD Application Team
   5:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @version V1.5.0
   6:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @date    05-December-2014
   7:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief   This file provides firmware functions to manage the following 
   8:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          functionalities of the Digital-to-Analog Converter (DAC) peripheral
   9:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          applicable only on STM32F051 and STM32F072 devices:
  10:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *           + DAC channel configuration: trigger, output buffer, data format
  11:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *           + DMA management
  12:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *           + Interrupts and flags management
  13:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *
  14:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *  @verbatim
  15:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *
  16:.\StdPeriphLib\src/stm32f0xx_dac.c ****  ===============================================================================
  17:.\StdPeriphLib\src/stm32f0xx_dac.c ****                         ##### DAC Peripheral features #####
  18:.\StdPeriphLib\src/stm32f0xx_dac.c ****  ===============================================================================
  19:.\StdPeriphLib\src/stm32f0xx_dac.c ****     [..] The device integrates two 12-bit Digital Analog Converters refered as
  20:.\StdPeriphLib\src/stm32f0xx_dac.c ****          DAC channel1 with DAC_OUT1 (PA4) and DAC_OUT2 (PA5) as outputs.
  21:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
  22:.\StdPeriphLib\src/stm32f0xx_dac.c ****     [..] Digital to Analog conversion can be non-triggered using DAC_Trigger_None
  23:.\StdPeriphLib\src/stm32f0xx_dac.c ****          and DAC_OUTx is available once writing to DHRx register using 
  24:.\StdPeriphLib\src/stm32f0xx_dac.c ****          DAC_SetChannel1Data() or DAC_SetChannel2Data() 
  25:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
  26:.\StdPeriphLib\src/stm32f0xx_dac.c ****     [..] Digital to Analog conversion can be triggered by:
  27:.\StdPeriphLib\src/stm32f0xx_dac.c ****          (#) External event: EXTI Line 9 (any GPIOx_Pin9) using DAC_Trigger_Ext_IT9.
  28:.\StdPeriphLib\src/stm32f0xx_dac.c ****              The used pin (GPIOx_Pin9) must be configured in input mode.
  29:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
  30:.\StdPeriphLib\src/stm32f0xx_dac.c ****          (#) Timers TRGO: TIM2, TIM3,TIM7, TIM6 and TIM15 
  31:.\StdPeriphLib\src/stm32f0xx_dac.c ****              (DAC_Trigger_T2_TRGO, DAC_Trigger_T3_TRGO...)
  32:.\StdPeriphLib\src/stm32f0xx_dac.c ****              The timer TRGO event should be selected using TIM_SelectOutputTrigger()
  33:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
  34:.\StdPeriphLib\src/stm32f0xx_dac.c ****          (#) Software using DAC_Trigger_Software
  35:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
  36:.\StdPeriphLib\src/stm32f0xx_dac.c ****     [..] Each DAC integrates an output buffer that can be used to 
  37:.\StdPeriphLib\src/stm32f0xx_dac.c ****          reduce the output impedance, and to drive external loads directly
  38:.\StdPeriphLib\src/stm32f0xx_dac.c ****          without having to add an external operational amplifier.
  39:.\StdPeriphLib\src/stm32f0xx_dac.c ****          To enable the output buffer use  
  40:.\StdPeriphLib\src/stm32f0xx_dac.c ****          DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
  41:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
  42:.\StdPeriphLib\src/stm32f0xx_dac.c ****     [..] Refer to the device datasheet for more details about output impedance
  43:.\StdPeriphLib\src/stm32f0xx_dac.c ****          value with and without output buffer.
  44:.\StdPeriphLib\src/stm32f0xx_dac.c ****          
  45:.\StdPeriphLib\src/stm32f0xx_dac.c ****     [..] DAC wave generation feature
  46:.\StdPeriphLib\src/stm32f0xx_dac.c ****          Both DAC channels can be used to generate
  47:.\StdPeriphLib\src/stm32f0xx_dac.c ****              1- Noise wave using DAC_WaveGeneration_Noise
  48:.\StdPeriphLib\src/stm32f0xx_dac.c ****              2- Triangle wave using DAC_WaveGeneration_Triangle
  49:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
  50:.\StdPeriphLib\src/stm32f0xx_dac.c ****     [..] The DAC data format can be:
  51:.\StdPeriphLib\src/stm32f0xx_dac.c ****          (#) 8-bit right alignment using DAC_Align_8b_R
  52:.\StdPeriphLib\src/stm32f0xx_dac.c ****          (#) 12-bit left alignment using DAC_Align_12b_L
  53:.\StdPeriphLib\src/stm32f0xx_dac.c ****          (#) 12-bit right alignment using DAC_Align_12b_R
  54:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
  55:.\StdPeriphLib\src/stm32f0xx_dac.c ****     [..] The analog output voltage on each DAC channel pin is determined
  56:.\StdPeriphLib\src/stm32f0xx_dac.c ****          by the following equation: DAC_OUTx = VREF+ * DOR / 4095
  57:.\StdPeriphLib\src/stm32f0xx_dac.c ****          with  DOR is the Data Output Register
  58:.\StdPeriphLib\src/stm32f0xx_dac.c ****          VEF+ is the input voltage reference (refer to the device datasheet)
  59:.\StdPeriphLib\src/stm32f0xx_dac.c ****          e.g. To set DAC_OUT1 to 0.7V, use
  60:.\StdPeriphLib\src/stm32f0xx_dac.c ****          DAC_SetChannel1Data(DAC_Align_12b_R, 868);
  61:.\StdPeriphLib\src/stm32f0xx_dac.c ****          Assuming that VREF+ = 3.3, DAC_OUT1 = (3.3 * 868) / 4095 = 0.7V
  62:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
  63:.\StdPeriphLib\src/stm32f0xx_dac.c ****     [..] A DMA1 request can be generated when an external trigger (but not
  64:.\StdPeriphLib\src/stm32f0xx_dac.c ****          a software trigger) occurs if DMA1 requests are enabled using
  65:.\StdPeriphLib\src/stm32f0xx_dac.c ****          DAC_DMACmd()
  66:.\StdPeriphLib\src/stm32f0xx_dac.c ****          DMA1 requests are mapped as following:
  67:.\StdPeriphLib\src/stm32f0xx_dac.c ****          (+) DAC channel1 is mapped on DMA1 channel3 which must be already 
  68:.\StdPeriphLib\src/stm32f0xx_dac.c ****              configured
  69:.\StdPeriphLib\src/stm32f0xx_dac.c ****          (+) DAC channel2 is mapped on DMA1 channel4 which must be already 
  70:.\StdPeriphLib\src/stm32f0xx_dac.c ****              configured
  71:.\StdPeriphLib\src/stm32f0xx_dac.c ****     
  72:.\StdPeriphLib\src/stm32f0xx_dac.c ****                       ##### How to use this driver #####
  73:.\StdPeriphLib\src/stm32f0xx_dac.c ****  ===============================================================================
  74:.\StdPeriphLib\src/stm32f0xx_dac.c ****     [..]
  75:.\StdPeriphLib\src/stm32f0xx_dac.c ****          (+) Enable DAC APB1 clock to get write access to DAC registers
  76:.\StdPeriphLib\src/stm32f0xx_dac.c ****              using RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE)
  77:.\StdPeriphLib\src/stm32f0xx_dac.c ****               
  78:.\StdPeriphLib\src/stm32f0xx_dac.c ****          (+) Configure DAC_OUTx (DAC_OUT1: PA4, DAC_OUT2: PA5) in analog mode
  79:.\StdPeriphLib\src/stm32f0xx_dac.c ****              using GPIO_Init() function  
  80:.\StdPeriphLib\src/stm32f0xx_dac.c ****               
  81:.\StdPeriphLib\src/stm32f0xx_dac.c ****          (+) Configure the DAC channel using DAC_Init()
  82:.\StdPeriphLib\src/stm32f0xx_dac.c ****               
  83:.\StdPeriphLib\src/stm32f0xx_dac.c ****          (+) Enable the DAC channel using DAC_Cmd()
  84:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
  85:.\StdPeriphLib\src/stm32f0xx_dac.c ****     @endverbatim
  86:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *
  87:.\StdPeriphLib\src/stm32f0xx_dac.c ****   ******************************************************************************
  88:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @attention
  89:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *
  90:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  91:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *
  92:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  93:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * You may not use this file except in compliance with the License.
  94:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * You may obtain a copy of the License at:
  95:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *
  96:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  97:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *
  98:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * Unless required by applicable law or agreed to in writing, software 
  99:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
 100:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 101:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * See the License for the specific language governing permissions and
 102:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * limitations under the License.
 103:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *
 104:.\StdPeriphLib\src/stm32f0xx_dac.c ****   ******************************************************************************
 105:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 106:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 107:.\StdPeriphLib\src/stm32f0xx_dac.c **** /* Includes ------------------------------------------------------------------*/
 108:.\StdPeriphLib\src/stm32f0xx_dac.c **** #include "stm32f0xx_dac.h"
 109:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 110:.\StdPeriphLib\src/stm32f0xx_dac.c **** /** @addtogroup STM32F0xx_StdPeriph_Driver
 111:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @{
 112:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 113:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 114:.\StdPeriphLib\src/stm32f0xx_dac.c **** /** @defgroup DAC 
 115:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief DAC driver modules
 116:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @{
 117:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */ 
 118:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 119:.\StdPeriphLib\src/stm32f0xx_dac.c **** /* Private typedef -----------------------------------------------------------*/
 120:.\StdPeriphLib\src/stm32f0xx_dac.c **** /* Private define ------------------------------------------------------------*/
 121:.\StdPeriphLib\src/stm32f0xx_dac.c **** /* CR register Mask */
 122:.\StdPeriphLib\src/stm32f0xx_dac.c **** #define CR_CLEAR_MASK              ((uint32_t)0x00000FFE) /* check the value of the mask */
 123:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 124:.\StdPeriphLib\src/stm32f0xx_dac.c **** /* DAC Dual Channels SWTRIG masks */
 125:.\StdPeriphLib\src/stm32f0xx_dac.c **** #define DUAL_SWTRIG_SET            ((uint32_t)0x00000003) /*!< Only applicable for STM32F072 device
 126:.\StdPeriphLib\src/stm32f0xx_dac.c **** #define DUAL_SWTRIG_RESET          ((uint32_t)0xFFFFFFFC) /*!< Only applicable for STM32F072 device
 127:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 128:.\StdPeriphLib\src/stm32f0xx_dac.c **** /* DHR registers offsets */
 129:.\StdPeriphLib\src/stm32f0xx_dac.c **** #define DHR12R1_OFFSET             ((uint32_t)0x00000008)
 130:.\StdPeriphLib\src/stm32f0xx_dac.c **** #define DHR12R2_OFFSET             ((uint32_t)0x00000014) /*!< Only applicable for STM32F072 device
 131:.\StdPeriphLib\src/stm32f0xx_dac.c **** #define DHR12RD_OFFSET             ((uint32_t)0x00000020) /*!< Only applicable for STM32F072 device
 132:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 133:.\StdPeriphLib\src/stm32f0xx_dac.c **** /* DOR register offset */
 134:.\StdPeriphLib\src/stm32f0xx_dac.c **** #define DOR_OFFSET                 ((uint32_t)0x0000002C)
 135:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 136:.\StdPeriphLib\src/stm32f0xx_dac.c **** /* Private macro -------------------------------------------------------------*/
 137:.\StdPeriphLib\src/stm32f0xx_dac.c **** /* Private variables ---------------------------------------------------------*/
 138:.\StdPeriphLib\src/stm32f0xx_dac.c **** /* Private function prototypes -----------------------------------------------*/
 139:.\StdPeriphLib\src/stm32f0xx_dac.c **** /* Private functions ---------------------------------------------------------*/
 140:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 141:.\StdPeriphLib\src/stm32f0xx_dac.c **** /** @defgroup DAC_Private_Functions
 142:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @{
 143:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */ 
 144:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 145:.\StdPeriphLib\src/stm32f0xx_dac.c **** /** @defgroup DAC_Group1 DAC channels configuration
 146:.\StdPeriphLib\src/stm32f0xx_dac.c ****  *  @brief   DAC channels configuration: trigger, output buffer, data format 
 147:.\StdPeriphLib\src/stm32f0xx_dac.c ****  *
 148:.\StdPeriphLib\src/stm32f0xx_dac.c **** @verbatim
 149:.\StdPeriphLib\src/stm32f0xx_dac.c ****  ===============================================================================
 150:.\StdPeriphLib\src/stm32f0xx_dac.c ****   ##### DAC channels configuration: trigger, output buffer, data format #####
 151:.\StdPeriphLib\src/stm32f0xx_dac.c ****  ===============================================================================  
 152:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 153:.\StdPeriphLib\src/stm32f0xx_dac.c **** @endverbatim
 154:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @{
 155:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 156:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 157:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 158:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Deinitializes the DAC peripheral registers to their default reset values.
 159:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  None
 160:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval None
 161:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 162:.\StdPeriphLib\src/stm32f0xx_dac.c **** void DAC_DeInit(void)
 163:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
  26              		.loc 1 163 0
  27              		.cfi_startproc
  28 0000 10B5     		push	{r4, lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 4, -8
  32              		.cfi_offset 14, -4
 164:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Enable DAC reset state */
 165:.\StdPeriphLib\src/stm32f0xx_dac.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
  33              		.loc 1 165 0
  34 0002 8024     		mov	r4, #128
  35 0004 A405     		lsl	r4, r4, #22
  36 0006 201C     		mov	r0, r4
  37 0008 0121     		mov	r1, #1
  38 000a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  39              	.LVL0:
 166:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Release DAC from reset state */
 167:.\StdPeriphLib\src/stm32f0xx_dac.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
  40              		.loc 1 167 0
  41 000e 201C     		mov	r0, r4
  42 0010 0021     		mov	r1, #0
  43 0012 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  44              	.LVL1:
 168:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
  45              		.loc 1 168 0
  46              		@ sp needed
  47 0016 10BD     		pop	{r4, pc}
  48              		.cfi_endproc
  49              	.LFE33:
  51              		.section	.text.DAC_Init,"ax",%progbits
  52              		.align	2
  53              		.global	DAC_Init
  54              		.code	16
  55              		.thumb_func
  57              	DAC_Init:
  58              	.LFB34:
 169:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 170:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 171:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Initializes the DAC peripheral according to the specified parameters
 172:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *         in the DAC_InitStruct.
 173:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Channel: the selected DAC channel. 
 174:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be:
 175:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_1: DAC Channel1 selected
 176:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_2: DAC Channel2 selected, applicable only for STM32F072 devices
 177:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that contains
 178:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *         the configuration information for the  specified DAC channel.
 179:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval None
 180:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 181:.\StdPeriphLib\src/stm32f0xx_dac.c **** void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
 182:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
  59              		.loc 1 182 0
  60              		.cfi_startproc
  61              	.LVL2:
  62 0000 30B5     		push	{r4, r5, lr}
  63              	.LCFI1:
  64              		.cfi_def_cfa_offset 12
  65              		.cfi_offset 4, -12
  66              		.cfi_offset 5, -8
  67              		.cfi_offset 14, -4
  68              	.LVL3:
 183:.\StdPeriphLib\src/stm32f0xx_dac.c ****   uint32_t tmpreg1 = 0, tmpreg2 = 0;
 184:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 185:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the DAC parameters */
 186:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
 187:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
 188:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitu
 189:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
 190:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 191:.\StdPeriphLib\src/stm32f0xx_dac.c **** /*---------------------------- DAC CR Configuration --------------------------*/
 192:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Get the DAC CR value */
 193:.\StdPeriphLib\src/stm32f0xx_dac.c ****   tmpreg1 = DAC->CR;
  69              		.loc 1 193 0
  70 0002 084D     		ldr	r5, .L3
  71 0004 2C68     		ldr	r4, [r5]
  72              	.LVL4:
 194:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
 195:.\StdPeriphLib\src/stm32f0xx_dac.c ****   tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
  73              		.loc 1 195 0
  74 0006 084B     		ldr	r3, .L3+4
  75 0008 8340     		lsl	r3, r3, r0
  76 000a 9C43     		bic	r4, r3
  77              	.LVL5:
 196:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Configure for the selected DAC channel: buffer output, trigger, 
 197:.\StdPeriphLib\src/stm32f0xx_dac.c ****      wave generation, mask/amplitude for wave generation */
 198:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Set TSELx and TENx bits according to DAC_Trigger value */
 199:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Set WAVEx bits according to DAC_WaveGeneration value */
 200:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
 201:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Set BOFFx bit according to DAC_OutputBuffer value */   
 202:.\StdPeriphLib\src/stm32f0xx_dac.c ****   tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
  78              		.loc 1 202 0
  79 000c 4B68     		ldr	r3, [r1, #4]
  80 000e 0A68     		ldr	r2, [r1]
  81 0010 1343     		orr	r3, r2
  82 0012 8A68     		ldr	r2, [r1, #8]
  83 0014 1343     		orr	r3, r2
  84 0016 CA68     		ldr	r2, [r1, #12]
  85 0018 1343     		orr	r3, r2
 203:.\StdPeriphLib\src/stm32f0xx_dac.c ****              DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
 204:.\StdPeriphLib\src/stm32f0xx_dac.c ****              DAC_InitStruct->DAC_OutputBuffer);
 205:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Calculate CR register value depending on DAC_Channel */
 206:.\StdPeriphLib\src/stm32f0xx_dac.c ****   tmpreg1 |= tmpreg2 << DAC_Channel;
  86              		.loc 1 206 0
  87 001a 8340     		lsl	r3, r3, r0
  88 001c 181C     		mov	r0, r3
  89              	.LVL6:
  90 001e 2043     		orr	r0, r4
  91              	.LVL7:
 207:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Write to DAC CR */
 208:.\StdPeriphLib\src/stm32f0xx_dac.c ****   DAC->CR = tmpreg1;
  92              		.loc 1 208 0
  93 0020 2860     		str	r0, [r5]
  94              	.LVL8:
 209:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
  95              		.loc 1 209 0
  96              		@ sp needed
  97 0022 30BD     		pop	{r4, r5, pc}
  98              	.L4:
  99              		.align	2
 100              	.L3:
 101 0024 00740040 		.word	1073771520
 102 0028 FE0F0000 		.word	4094
 103              		.cfi_endproc
 104              	.LFE34:
 106              		.section	.text.DAC_StructInit,"ax",%progbits
 107              		.align	2
 108              		.global	DAC_StructInit
 109              		.code	16
 110              		.thumb_func
 112              	DAC_StructInit:
 113              	.LFB35:
 210:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 211:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 212:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Fills each DAC_InitStruct member with its default value.
 213:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure which will 
 214:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *         be initialized.
 215:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval None
 216:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 217:.\StdPeriphLib\src/stm32f0xx_dac.c **** void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
 218:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
 114              		.loc 1 218 0
 115              		.cfi_startproc
 116              	.LVL9:
 219:.\StdPeriphLib\src/stm32f0xx_dac.c **** /*--------------- Reset DAC init structure parameters values -----------------*/
 220:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Initialize the DAC_Trigger member */
 221:.\StdPeriphLib\src/stm32f0xx_dac.c ****   DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
 117              		.loc 1 221 0
 118 0000 0023     		mov	r3, #0
 119 0002 0360     		str	r3, [r0]
 222:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 223:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Initialize the DAC_WaveGeneration member */
 224:.\StdPeriphLib\src/stm32f0xx_dac.c ****   DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
 120              		.loc 1 224 0
 121 0004 4360     		str	r3, [r0, #4]
 225:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 226:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
 227:.\StdPeriphLib\src/stm32f0xx_dac.c ****   DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
 122              		.loc 1 227 0
 123 0006 8360     		str	r3, [r0, #8]
 228:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 229:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Initialize the DAC_OutputBuffer member */
 230:.\StdPeriphLib\src/stm32f0xx_dac.c ****   DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
 124              		.loc 1 230 0
 125 0008 C360     		str	r3, [r0, #12]
 231:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 126              		.loc 1 231 0
 127              		@ sp needed
 128 000a 7047     		bx	lr
 129              		.cfi_endproc
 130              	.LFE35:
 132              		.section	.text.DAC_Cmd,"ax",%progbits
 133              		.align	2
 134              		.global	DAC_Cmd
 135              		.code	16
 136              		.thumb_func
 138              	DAC_Cmd:
 139              	.LFB36:
 232:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 233:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 234:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Enables or disables the specified DAC channel.
 235:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Channel: The selected DAC channel. 
 236:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be one of the following values:
 237:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_1: DAC Channel1 selected
 238:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_2: DAC Channel2 selected, applicable only for STM32F072 devices
 239:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  NewState: new state of the DAC channel. 
 240:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be: ENABLE or DISABLE.
 241:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @note   When the DAC channel is enabled the trigger source can no more be modified.
 242:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval None
 243:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 244:.\StdPeriphLib\src/stm32f0xx_dac.c **** void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
 245:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
 140              		.loc 1 245 0
 141              		.cfi_startproc
 142              	.LVL10:
 246:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the parameters */
 247:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_CHANNEL(DAC_Channel));
 248:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 249:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 250:.\StdPeriphLib\src/stm32f0xx_dac.c ****   if (NewState != DISABLE)
 143              		.loc 1 250 0
 144 0000 0029     		cmp	r1, #0
 145 0002 07D0     		beq	.L7
 251:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 252:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* Enable the selected DAC channel */
 253:.\StdPeriphLib\src/stm32f0xx_dac.c ****     DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
 146              		.loc 1 253 0
 147 0004 0749     		ldr	r1, .L9
 148              	.LVL11:
 149 0006 0B68     		ldr	r3, [r1]
 150 0008 0122     		mov	r2, #1
 151 000a 8240     		lsl	r2, r2, r0
 152 000c 101C     		mov	r0, r2
 153              	.LVL12:
 154 000e 1843     		orr	r0, r3
 155 0010 0860     		str	r0, [r1]
 156 0012 05E0     		b	.L6
 157              	.LVL13:
 158              	.L7:
 254:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 255:.\StdPeriphLib\src/stm32f0xx_dac.c ****   else
 256:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 257:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* Disable the selected DAC channel */
 258:.\StdPeriphLib\src/stm32f0xx_dac.c ****     DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
 159              		.loc 1 258 0
 160 0014 0349     		ldr	r1, .L9
 161              	.LVL14:
 162 0016 0B68     		ldr	r3, [r1]
 163 0018 0122     		mov	r2, #1
 164 001a 8240     		lsl	r2, r2, r0
 165 001c 9343     		bic	r3, r2
 166 001e 0B60     		str	r3, [r1]
 167              	.LVL15:
 168              	.L6:
 259:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 260:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 169              		.loc 1 260 0
 170              		@ sp needed
 171 0020 7047     		bx	lr
 172              	.L10:
 173 0022 C046     		.align	2
 174              	.L9:
 175 0024 00740040 		.word	1073771520
 176              		.cfi_endproc
 177              	.LFE36:
 179              		.section	.text.DAC_SoftwareTriggerCmd,"ax",%progbits
 180              		.align	2
 181              		.global	DAC_SoftwareTriggerCmd
 182              		.code	16
 183              		.thumb_func
 185              	DAC_SoftwareTriggerCmd:
 186              	.LFB37:
 261:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 262:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 263:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Enables or disables the selected DAC channel software trigger.
 264:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Channel: The selected DAC channel. 
 265:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be one of the following values:
 266:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_1: DAC Channel1 selected
 267:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_2: DAC Channel2 selected, applicable only for STM32F072 devices
 268:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  NewState: new state of the selected DAC channel software trigger.
 269:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be: ENABLE or DISABLE.
 270:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval None
 271:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 272:.\StdPeriphLib\src/stm32f0xx_dac.c **** void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
 273:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
 187              		.loc 1 273 0
 188              		.cfi_startproc
 189              	.LVL16:
 274:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the parameters */
 275:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_CHANNEL(DAC_Channel));
 276:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 277:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 278:.\StdPeriphLib\src/stm32f0xx_dac.c ****   if (NewState != DISABLE)
 190              		.loc 1 278 0
 191 0000 0029     		cmp	r1, #0
 192 0002 08D0     		beq	.L12
 279:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 280:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* Enable software trigger for the selected DAC channel */
 281:.\StdPeriphLib\src/stm32f0xx_dac.c ****     DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
 193              		.loc 1 281 0
 194 0004 0849     		ldr	r1, .L14
 195              	.LVL17:
 196 0006 4B68     		ldr	r3, [r1, #4]
 197 0008 0009     		lsr	r0, r0, #4
 198              	.LVL18:
 199 000a 0122     		mov	r2, #1
 200 000c 8240     		lsl	r2, r2, r0
 201 000e 101C     		mov	r0, r2
 202 0010 1843     		orr	r0, r3
 203 0012 4860     		str	r0, [r1, #4]
 204 0014 06E0     		b	.L11
 205              	.LVL19:
 206              	.L12:
 282:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 283:.\StdPeriphLib\src/stm32f0xx_dac.c ****   else
 284:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 285:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* Disable software trigger for the selected DAC channel */
 286:.\StdPeriphLib\src/stm32f0xx_dac.c ****     DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
 207              		.loc 1 286 0
 208 0016 0449     		ldr	r1, .L14
 209              	.LVL20:
 210 0018 4B68     		ldr	r3, [r1, #4]
 211 001a 0009     		lsr	r0, r0, #4
 212              	.LVL21:
 213 001c 0122     		mov	r2, #1
 214 001e 8240     		lsl	r2, r2, r0
 215 0020 9343     		bic	r3, r2
 216 0022 4B60     		str	r3, [r1, #4]
 217              	.L11:
 287:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 288:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 218              		.loc 1 288 0
 219              		@ sp needed
 220 0024 7047     		bx	lr
 221              	.L15:
 222 0026 C046     		.align	2
 223              	.L14:
 224 0028 00740040 		.word	1073771520
 225              		.cfi_endproc
 226              	.LFE37:
 228              		.section	.text.DAC_DualSoftwareTriggerCmd,"ax",%progbits
 229              		.align	2
 230              		.global	DAC_DualSoftwareTriggerCmd
 231              		.code	16
 232              		.thumb_func
 234              	DAC_DualSoftwareTriggerCmd:
 235              	.LFB38:
 289:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 290:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 291:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Enables or disables simultaneously the two DAC channels software triggers.
 292:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *         This function is applicable only for STM32F072 devices.  
 293:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  NewState: new state of the DAC channels software triggers.
 294:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be: ENABLE or DISABLE.
 295:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval None
 296:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 297:.\StdPeriphLib\src/stm32f0xx_dac.c **** void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
 298:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
 236              		.loc 1 298 0
 237              		.cfi_startproc
 238              	.LVL22:
 299:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the parameters */
 300:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 301:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 302:.\StdPeriphLib\src/stm32f0xx_dac.c ****   if (NewState != DISABLE)
 239              		.loc 1 302 0
 240 0000 0028     		cmp	r0, #0
 241 0002 05D0     		beq	.L17
 303:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 304:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* Enable software trigger for both DAC channels */
 305:.\StdPeriphLib\src/stm32f0xx_dac.c ****     DAC->SWTRIGR |= DUAL_SWTRIG_SET;
 242              		.loc 1 305 0
 243 0004 054A     		ldr	r2, .L19
 244 0006 5168     		ldr	r1, [r2, #4]
 245 0008 0323     		mov	r3, #3
 246 000a 0B43     		orr	r3, r1
 247 000c 5360     		str	r3, [r2, #4]
 248 000e 04E0     		b	.L16
 249              	.L17:
 306:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 307:.\StdPeriphLib\src/stm32f0xx_dac.c ****   else
 308:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 309:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* Disable software trigger for both DAC channels */
 310:.\StdPeriphLib\src/stm32f0xx_dac.c ****     DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
 250              		.loc 1 310 0
 251 0010 024A     		ldr	r2, .L19
 252 0012 5368     		ldr	r3, [r2, #4]
 253 0014 0321     		mov	r1, #3
 254 0016 8B43     		bic	r3, r1
 255 0018 5360     		str	r3, [r2, #4]
 256              	.L16:
 311:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 312:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 257              		.loc 1 312 0
 258              		@ sp needed
 259 001a 7047     		bx	lr
 260              	.L20:
 261              		.align	2
 262              	.L19:
 263 001c 00740040 		.word	1073771520
 264              		.cfi_endproc
 265              	.LFE38:
 267              		.section	.text.DAC_WaveGenerationCmd,"ax",%progbits
 268              		.align	2
 269              		.global	DAC_WaveGenerationCmd
 270              		.code	16
 271              		.thumb_func
 273              	DAC_WaveGenerationCmd:
 274              	.LFB39:
 313:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 314:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 315:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Enables or disables the selected DAC channel wave generation.
 316:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *         This function is applicable only for STM32F072 devices.  
 317:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Channel: The selected DAC channel. 
 318:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be:
 319:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_1: DAC Channel1 selected
 320:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_2: DAC Channel2 selected
 321:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Wave: specifies the wave type to enable or disable.
 322:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be:
 323:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Wave_Noise: noise wave generation
 324:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Wave_Triangle: triangle wave generation
 325:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  NewState: new state of the selected DAC channel wave generation.
 326:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be: ENABLE or DISABLE.  
 327:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval None
 328:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 329:.\StdPeriphLib\src/stm32f0xx_dac.c **** void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
 330:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
 275              		.loc 1 330 0
 276              		.cfi_startproc
 277              	.LVL23:
 331:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the parameters */
 332:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_CHANNEL(DAC_Channel));
 333:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_WAVE(DAC_Wave)); 
 334:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 335:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 336:.\StdPeriphLib\src/stm32f0xx_dac.c ****   if (NewState != DISABLE)
 278              		.loc 1 336 0
 279 0000 002A     		cmp	r2, #0
 280 0002 05D0     		beq	.L22
 337:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 338:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* Enable the selected wave generation for the selected DAC channel */
 339:.\StdPeriphLib\src/stm32f0xx_dac.c ****     DAC->CR |= DAC_Wave << DAC_Channel;
 281              		.loc 1 339 0
 282 0004 054A     		ldr	r2, .L24
 283              	.LVL24:
 284 0006 1368     		ldr	r3, [r2]
 285 0008 8140     		lsl	r1, r1, r0
 286              	.LVL25:
 287 000a 1943     		orr	r1, r3
 288 000c 1160     		str	r1, [r2]
 289 000e 04E0     		b	.L21
 290              	.LVL26:
 291              	.L22:
 340:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 341:.\StdPeriphLib\src/stm32f0xx_dac.c ****   else
 342:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 343:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* Disable the selected wave generation for the selected DAC channel */
 344:.\StdPeriphLib\src/stm32f0xx_dac.c ****     DAC->CR &= ~(DAC_Wave << DAC_Channel);
 292              		.loc 1 344 0
 293 0010 024A     		ldr	r2, .L24
 294              	.LVL27:
 295 0012 1368     		ldr	r3, [r2]
 296 0014 8140     		lsl	r1, r1, r0
 297              	.LVL28:
 298 0016 8B43     		bic	r3, r1
 299 0018 1360     		str	r3, [r2]
 300              	.L21:
 345:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 346:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 301              		.loc 1 346 0
 302              		@ sp needed
 303 001a 7047     		bx	lr
 304              	.L25:
 305              		.align	2
 306              	.L24:
 307 001c 00740040 		.word	1073771520
 308              		.cfi_endproc
 309              	.LFE39:
 311              		.section	.text.DAC_SetChannel1Data,"ax",%progbits
 312              		.align	2
 313              		.global	DAC_SetChannel1Data
 314              		.code	16
 315              		.thumb_func
 317              	DAC_SetChannel1Data:
 318              	.LFB40:
 347:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 348:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 349:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Set the specified data holding register value for DAC channel1.
 350:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Align: Specifies the data alignment for DAC channel1.
 351:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be one of the following values:
 352:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Align_8b_R: 8bit right data alignment selected
 353:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Align_12b_L: 12bit left data alignment selected
 354:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Align_12b_R: 12bit right data alignment selected
 355:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  Data: Data to be loaded in the selected data holding register.
 356:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval None
 357:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 358:.\StdPeriphLib\src/stm32f0xx_dac.c **** void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
 359:.\StdPeriphLib\src/stm32f0xx_dac.c **** {  
 319              		.loc 1 359 0
 320              		.cfi_startproc
 321              	.LVL29:
 322 0000 82B0     		sub	sp, sp, #8
 323              	.LCFI2:
 324              		.cfi_def_cfa_offset 8
 360:.\StdPeriphLib\src/stm32f0xx_dac.c ****   __IO uint32_t tmp = 0;
 325              		.loc 1 360 0
 326 0002 0023     		mov	r3, #0
 327 0004 0193     		str	r3, [sp, #4]
 361:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 362:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the parameters */
 363:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_ALIGN(DAC_Align));
 364:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_DATA(Data));
 365:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 366:.\StdPeriphLib\src/stm32f0xx_dac.c ****   tmp = (uint32_t)DAC_BASE; 
 328              		.loc 1 366 0
 329 0006 054B     		ldr	r3, .L27
 330 0008 0193     		str	r3, [sp, #4]
 367:.\StdPeriphLib\src/stm32f0xx_dac.c ****   tmp += DHR12R1_OFFSET + DAC_Align;
 331              		.loc 1 367 0
 332 000a 019B     		ldr	r3, [sp, #4]
 333 000c 0833     		add	r3, r3, #8
 334 000e 1818     		add	r0, r3, r0
 335              	.LVL30:
 336 0010 0190     		str	r0, [sp, #4]
 368:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 369:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Set the DAC channel1 selected data holding register */
 370:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *(__IO uint32_t *) tmp = Data;
 337              		.loc 1 370 0
 338 0012 019B     		ldr	r3, [sp, #4]
 339 0014 1960     		str	r1, [r3]
 371:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 340              		.loc 1 371 0
 341 0016 02B0     		add	sp, sp, #8
 342              		@ sp needed
 343 0018 7047     		bx	lr
 344              	.L28:
 345 001a C046     		.align	2
 346              	.L27:
 347 001c 00740040 		.word	1073771520
 348              		.cfi_endproc
 349              	.LFE40:
 351              		.section	.text.DAC_SetChannel2Data,"ax",%progbits
 352              		.align	2
 353              		.global	DAC_SetChannel2Data
 354              		.code	16
 355              		.thumb_func
 357              	DAC_SetChannel2Data:
 358              	.LFB41:
 372:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 373:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 374:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Sets the specified data holding register value for DAC channel2.
 375:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *         This function is applicable only for STM32F072 devices.  
 376:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Align: Specifies the data alignment for DAC channel2.
 377:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be:
 378:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Align_8b_R: 8bit right data alignment selected
 379:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Align_12b_L: 12bit left data alignment selected
 380:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Align_12b_R: 12bit right data alignment selected
 381:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  Data: Data to be loaded in the selected data holding register.
 382:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval None
 383:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 384:.\StdPeriphLib\src/stm32f0xx_dac.c **** void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
 385:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
 359              		.loc 1 385 0
 360              		.cfi_startproc
 361              	.LVL31:
 362 0000 82B0     		sub	sp, sp, #8
 363              	.LCFI3:
 364              		.cfi_def_cfa_offset 8
 386:.\StdPeriphLib\src/stm32f0xx_dac.c ****   __IO uint32_t tmp = 0;
 365              		.loc 1 386 0
 366 0002 0023     		mov	r3, #0
 367 0004 0193     		str	r3, [sp, #4]
 387:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 388:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the parameters */
 389:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_ALIGN(DAC_Align));
 390:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_DATA(Data));
 391:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 392:.\StdPeriphLib\src/stm32f0xx_dac.c ****   tmp = (uint32_t)DAC_BASE;
 368              		.loc 1 392 0
 369 0006 054B     		ldr	r3, .L30
 370 0008 0193     		str	r3, [sp, #4]
 393:.\StdPeriphLib\src/stm32f0xx_dac.c ****   tmp += DHR12R2_OFFSET + DAC_Align;
 371              		.loc 1 393 0
 372 000a 019B     		ldr	r3, [sp, #4]
 373 000c 1433     		add	r3, r3, #20
 374 000e 1818     		add	r0, r3, r0
 375              	.LVL32:
 376 0010 0190     		str	r0, [sp, #4]
 394:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 395:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Set the DAC channel2 selected data holding register */
 396:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *(__IO uint32_t *)tmp = Data;
 377              		.loc 1 396 0
 378 0012 019B     		ldr	r3, [sp, #4]
 379 0014 1960     		str	r1, [r3]
 397:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 380              		.loc 1 397 0
 381 0016 02B0     		add	sp, sp, #8
 382              		@ sp needed
 383 0018 7047     		bx	lr
 384              	.L31:
 385 001a C046     		.align	2
 386              	.L30:
 387 001c 00740040 		.word	1073771520
 388              		.cfi_endproc
 389              	.LFE41:
 391              		.section	.text.DAC_SetDualChannelData,"ax",%progbits
 392              		.align	2
 393              		.global	DAC_SetDualChannelData
 394              		.code	16
 395              		.thumb_func
 397              	DAC_SetDualChannelData:
 398              	.LFB42:
 398:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 399:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 400:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Sets the specified data holding register value for dual channel DAC.
 401:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *         This function is applicable only for STM32F072 devices.  
 402:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Align: Specifies the data alignment for dual channel DAC.
 403:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be:
 404:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Align_8b_R: 8bit right data alignment selected
 405:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Align_12b_L: 12bit left data alignment selected
 406:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Align_12b_R: 12bit right data alignment selected
 407:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  Data2: Data for DAC Channel2 to be loaded in the selected data holding register.
 408:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  Data1: Data for DAC Channel1 to be loaded in the selected data  holding register.
 409:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @note   In dual mode, a unique register access is required to write in both
 410:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          DAC channels at the same time.
 411:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval None
 412:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 413:.\StdPeriphLib\src/stm32f0xx_dac.c **** void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
 414:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
 399              		.loc 1 414 0
 400              		.cfi_startproc
 401              	.LVL33:
 415:.\StdPeriphLib\src/stm32f0xx_dac.c ****   uint32_t data = 0, tmp = 0;
 416:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 417:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the parameters */
 418:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_ALIGN(DAC_Align));
 419:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_DATA(Data1));
 420:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_DATA(Data2));
 421:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 422:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Calculate and set dual DAC data holding register value */
 423:.\StdPeriphLib\src/stm32f0xx_dac.c ****   if (DAC_Align == DAC_Align_8b_R)
 402              		.loc 1 423 0
 403 0000 0828     		cmp	r0, #8
 404 0002 02D1     		bne	.L33
 424:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 425:.\StdPeriphLib\src/stm32f0xx_dac.c ****     data = ((uint32_t)Data2 << 8) | Data1; 
 405              		.loc 1 425 0
 406 0004 0902     		lsl	r1, r1, #8
 407              	.LVL34:
 408 0006 0A43     		orr	r2, r1
 409              	.LVL35:
 410 0008 01E0     		b	.L34
 411              	.LVL36:
 412              	.L33:
 426:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 427:.\StdPeriphLib\src/stm32f0xx_dac.c ****   else
 428:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 429:.\StdPeriphLib\src/stm32f0xx_dac.c ****     data = ((uint32_t)Data2 << 16) | Data1;
 413              		.loc 1 429 0
 414 000a 0904     		lsl	r1, r1, #16
 415              	.LVL37:
 416 000c 0A43     		orr	r2, r1
 417              	.LVL38:
 418              	.L34:
 430:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 431:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 432:.\StdPeriphLib\src/stm32f0xx_dac.c ****   tmp = (uint32_t)DAC_BASE;
 433:.\StdPeriphLib\src/stm32f0xx_dac.c ****   tmp += DHR12RD_OFFSET + DAC_Align;
 419              		.loc 1 433 0
 420 000e 024B     		ldr	r3, .L35
 421 0010 9C46     		mov	ip, r3
 422 0012 6044     		add	r0, r0, ip
 423              	.LVL39:
 434:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 435:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Set the dual DAC selected data holding register */
 436:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *(__IO uint32_t *)tmp = data;
 424              		.loc 1 436 0
 425 0014 0260     		str	r2, [r0]
 437:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 426              		.loc 1 437 0
 427              		@ sp needed
 428 0016 7047     		bx	lr
 429              	.L36:
 430              		.align	2
 431              	.L35:
 432 0018 20740040 		.word	1073771552
 433              		.cfi_endproc
 434              	.LFE42:
 436              		.section	.text.DAC_GetDataOutputValue,"ax",%progbits
 437              		.align	2
 438              		.global	DAC_GetDataOutputValue
 439              		.code	16
 440              		.thumb_func
 442              	DAC_GetDataOutputValue:
 443              	.LFB43:
 438:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 439:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 440:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Returns the last data output value of the selected DAC channel.
 441:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Channel: The selected DAC channel. 
 442:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be one of the following values:
 443:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_1: DAC Channel1 selected
 444:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_2: DAC Channel2 selected, applicable only for STM32F072 devices
 445:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval The selected DAC channel data output value.
 446:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 447:.\StdPeriphLib\src/stm32f0xx_dac.c **** uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
 448:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
 444              		.loc 1 448 0
 445              		.cfi_startproc
 446              	.LVL40:
 447 0000 82B0     		sub	sp, sp, #8
 448              	.LCFI4:
 449              		.cfi_def_cfa_offset 8
 449:.\StdPeriphLib\src/stm32f0xx_dac.c ****   __IO uint32_t tmp = 0;
 450              		.loc 1 449 0
 451 0002 0023     		mov	r3, #0
 452 0004 0193     		str	r3, [sp, #4]
 450:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 451:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the parameters */
 452:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_CHANNEL(DAC_Channel));
 453:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 454:.\StdPeriphLib\src/stm32f0xx_dac.c ****   tmp = (uint32_t) DAC_BASE ;
 453              		.loc 1 454 0
 454 0006 064B     		ldr	r3, .L38
 455 0008 0193     		str	r3, [sp, #4]
 455:.\StdPeriphLib\src/stm32f0xx_dac.c ****   tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
 456              		.loc 1 455 0
 457 000a 019B     		ldr	r3, [sp, #4]
 458 000c 2C33     		add	r3, r3, #44
 459 000e 8008     		lsr	r0, r0, #2
 460              	.LVL41:
 461 0010 1818     		add	r0, r3, r0
 462 0012 0190     		str	r0, [sp, #4]
 456:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 457:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Returns the DAC channel data output register value */
 458:.\StdPeriphLib\src/stm32f0xx_dac.c ****   return (uint16_t) (*(__IO uint32_t*) tmp);
 463              		.loc 1 458 0
 464 0014 019B     		ldr	r3, [sp, #4]
 465 0016 1868     		ldr	r0, [r3]
 466 0018 80B2     		uxth	r0, r0
 459:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 467              		.loc 1 459 0
 468 001a 02B0     		add	sp, sp, #8
 469              		@ sp needed
 470 001c 7047     		bx	lr
 471              	.L39:
 472 001e C046     		.align	2
 473              	.L38:
 474 0020 00740040 		.word	1073771520
 475              		.cfi_endproc
 476              	.LFE43:
 478              		.section	.text.DAC_DMACmd,"ax",%progbits
 479              		.align	2
 480              		.global	DAC_DMACmd
 481              		.code	16
 482              		.thumb_func
 484              	DAC_DMACmd:
 485              	.LFB44:
 460:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 461:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 462:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @}
 463:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 464:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 465:.\StdPeriphLib\src/stm32f0xx_dac.c **** /** @defgroup DAC_Group2 DMA management functions
 466:.\StdPeriphLib\src/stm32f0xx_dac.c ****  *  @brief   DMA management functions
 467:.\StdPeriphLib\src/stm32f0xx_dac.c ****  *
 468:.\StdPeriphLib\src/stm32f0xx_dac.c **** @verbatim   
 469:.\StdPeriphLib\src/stm32f0xx_dac.c ****  ===============================================================================
 470:.\StdPeriphLib\src/stm32f0xx_dac.c ****                     ##### DMA management functions #####
 471:.\StdPeriphLib\src/stm32f0xx_dac.c ****  ===============================================================================  
 472:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 473:.\StdPeriphLib\src/stm32f0xx_dac.c **** @endverbatim
 474:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @{
 475:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 476:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 477:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 478:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Enables or disables the specified DAC channel DMA request.
 479:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *         When enabled DMA1 is generated when an external trigger (EXTI Line9,
 480:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *         TIM2, TIM3, TIM6 or TIM15  but not a software trigger) occurs
 481:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Channel: the selected DAC channel.
 482:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be one of the following values:
 483:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_1: DAC Channel1 selected
 484:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_2: DAC Channel2 selected, applicable only for STM32F072 devices
 485:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  NewState: new state of the selected DAC channel DMA request.
 486:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be: ENABLE or DISABLE.
 487:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @note   The DAC channel1 is mapped on DMA1 channel3 which must be already configured. 
 488:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @note   The DAC channel2 is mapped on DMA1 channel4 which must be already configured.  
 489:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval None
 490:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 491:.\StdPeriphLib\src/stm32f0xx_dac.c **** void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
 492:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
 486              		.loc 1 492 0
 487              		.cfi_startproc
 488              	.LVL42:
 493:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the parameters */
 494:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_CHANNEL(DAC_Channel));
 495:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 496:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 497:.\StdPeriphLib\src/stm32f0xx_dac.c ****   if (NewState != DISABLE)
 489              		.loc 1 497 0
 490 0000 0029     		cmp	r1, #0
 491 0002 08D0     		beq	.L41
 498:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 499:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* Enable the selected DAC channel DMA request */
 500:.\StdPeriphLib\src/stm32f0xx_dac.c ****     DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
 492              		.loc 1 500 0
 493 0004 0849     		ldr	r1, .L43
 494              	.LVL43:
 495 0006 0B68     		ldr	r3, [r1]
 496 0008 8022     		mov	r2, #128
 497 000a 5201     		lsl	r2, r2, #5
 498 000c 8240     		lsl	r2, r2, r0
 499 000e 101C     		mov	r0, r2
 500              	.LVL44:
 501 0010 1843     		orr	r0, r3
 502 0012 0860     		str	r0, [r1]
 503 0014 06E0     		b	.L40
 504              	.LVL45:
 505              	.L41:
 501:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 502:.\StdPeriphLib\src/stm32f0xx_dac.c ****   else
 503:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 504:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* Disable the selected DAC channel DMA request */
 505:.\StdPeriphLib\src/stm32f0xx_dac.c ****     DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
 506              		.loc 1 505 0
 507 0016 0449     		ldr	r1, .L43
 508              	.LVL46:
 509 0018 0B68     		ldr	r3, [r1]
 510 001a 8022     		mov	r2, #128
 511 001c 5201     		lsl	r2, r2, #5
 512 001e 8240     		lsl	r2, r2, r0
 513 0020 9343     		bic	r3, r2
 514 0022 0B60     		str	r3, [r1]
 515              	.LVL47:
 516              	.L40:
 506:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 507:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 517              		.loc 1 507 0
 518              		@ sp needed
 519 0024 7047     		bx	lr
 520              	.L44:
 521 0026 C046     		.align	2
 522              	.L43:
 523 0028 00740040 		.word	1073771520
 524              		.cfi_endproc
 525              	.LFE44:
 527              		.section	.text.DAC_ITConfig,"ax",%progbits
 528              		.align	2
 529              		.global	DAC_ITConfig
 530              		.code	16
 531              		.thumb_func
 533              	DAC_ITConfig:
 534              	.LFB45:
 508:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 509:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 510:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @}
 511:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 512:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 513:.\StdPeriphLib\src/stm32f0xx_dac.c **** /** @defgroup DAC_Group3 Interrupts and flags management functions
 514:.\StdPeriphLib\src/stm32f0xx_dac.c ****  *  @brief   Interrupts and flags management functions
 515:.\StdPeriphLib\src/stm32f0xx_dac.c ****  *
 516:.\StdPeriphLib\src/stm32f0xx_dac.c **** @verbatim   
 517:.\StdPeriphLib\src/stm32f0xx_dac.c ****  ===============================================================================
 518:.\StdPeriphLib\src/stm32f0xx_dac.c ****             ##### Interrupts and flags management functions #####
 519:.\StdPeriphLib\src/stm32f0xx_dac.c ****  ===============================================================================  
 520:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 521:.\StdPeriphLib\src/stm32f0xx_dac.c **** @endverbatim
 522:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @{
 523:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 524:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 525:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 526:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Enables or disables the specified DAC interrupts.
 527:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Channel: The selected DAC channel. 
 528:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be:
 529:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_1: DAC Channel1 selected
 530:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_2: DAC Channel2 selected, applicable only for STM32F072 devices
 531:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_IT: specifies the DAC interrupt sources to be enabled or disabled. 
 532:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be the following values:
 533:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
 534:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @note   The DMA underrun occurs when a second external trigger arrives before the 
 535:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *         acknowledgement for the first external trigger is received (first request).
 536:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  NewState: new state of the specified DAC interrupts.
 537:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be: ENABLE or DISABLE.
 538:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval None
 539:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */ 
 540:.\StdPeriphLib\src/stm32f0xx_dac.c **** void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
 541:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
 535              		.loc 1 541 0
 536              		.cfi_startproc
 537              	.LVL48:
 542:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the parameters */
 543:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_CHANNEL(DAC_Channel));
 544:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 545:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_IT(DAC_IT)); 
 546:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 547:.\StdPeriphLib\src/stm32f0xx_dac.c ****   if (NewState != DISABLE)
 538              		.loc 1 547 0
 539 0000 002A     		cmp	r2, #0
 540 0002 05D0     		beq	.L46
 548:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 549:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* Enable the selected DAC interrupts */
 550:.\StdPeriphLib\src/stm32f0xx_dac.c ****     DAC->CR |=  (DAC_IT << DAC_Channel);
 541              		.loc 1 550 0
 542 0004 054A     		ldr	r2, .L48
 543              	.LVL49:
 544 0006 1368     		ldr	r3, [r2]
 545 0008 8140     		lsl	r1, r1, r0
 546              	.LVL50:
 547 000a 1943     		orr	r1, r3
 548 000c 1160     		str	r1, [r2]
 549 000e 04E0     		b	.L45
 550              	.LVL51:
 551              	.L46:
 551:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 552:.\StdPeriphLib\src/stm32f0xx_dac.c ****   else
 553:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 554:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* Disable the selected DAC interrupts */
 555:.\StdPeriphLib\src/stm32f0xx_dac.c ****     DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
 552              		.loc 1 555 0
 553 0010 024A     		ldr	r2, .L48
 554              	.LVL52:
 555 0012 1368     		ldr	r3, [r2]
 556 0014 8140     		lsl	r1, r1, r0
 557              	.LVL53:
 558 0016 8B43     		bic	r3, r1
 559 0018 1360     		str	r3, [r2]
 560              	.L45:
 556:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 557:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 561              		.loc 1 557 0
 562              		@ sp needed
 563 001a 7047     		bx	lr
 564              	.L49:
 565              		.align	2
 566              	.L48:
 567 001c 00740040 		.word	1073771520
 568              		.cfi_endproc
 569              	.LFE45:
 571              		.section	.text.DAC_GetFlagStatus,"ax",%progbits
 572              		.align	2
 573              		.global	DAC_GetFlagStatus
 574              		.code	16
 575              		.thumb_func
 577              	DAC_GetFlagStatus:
 578              	.LFB46:
 558:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 559:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 560:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Checks whether the specified DAC flag is set or not.
 561:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Channel: The selected DAC channel. 
 562:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be one of the following values:
 563:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_1: DAC Channel1 selected
 564:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_2: DAC Channel2 selected, applicable only for STM32F072 devices
 565:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_FLAG: specifies the flag to check. 
 566:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be only of the following value:
 567:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_FLAG_DMAUDR: DMA underrun flag
 568:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @note   The DMA underrun occurs when a second external trigger arrives before the 
 569:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *         acknowledgement for the first external trigger is received (first request).
 570:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval The new state of DAC_FLAG (SET or RESET).
 571:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 572:.\StdPeriphLib\src/stm32f0xx_dac.c **** FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
 573:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
 579              		.loc 1 573 0
 580              		.cfi_startproc
 581              	.LVL54:
 574:.\StdPeriphLib\src/stm32f0xx_dac.c ****   FlagStatus bitstatus = RESET;
 575:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the parameters */
 576:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_CHANNEL(DAC_Channel));
 577:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_FLAG(DAC_FLAG));
 578:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 579:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the status of the specified DAC flag */
 580:.\StdPeriphLib\src/stm32f0xx_dac.c ****   if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
 582              		.loc 1 580 0
 583 0000 044B     		ldr	r3, .L51
 584 0002 5B6B     		ldr	r3, [r3, #52]
 585              	.LVL55:
 586 0004 8140     		lsl	r1, r1, r0
 587              	.LVL56:
 588 0006 081C     		mov	r0, r1
 589              	.LVL57:
 590 0008 1840     		and	r0, r3
 591 000a 411E     		sub	r1, r0, #1
 592 000c 8841     		sbc	r0, r0, r1
 581:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 582:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* DAC_FLAG is set */
 583:.\StdPeriphLib\src/stm32f0xx_dac.c ****     bitstatus = SET;
 584:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 585:.\StdPeriphLib\src/stm32f0xx_dac.c ****   else
 586:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 587:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* DAC_FLAG is reset */
 588:.\StdPeriphLib\src/stm32f0xx_dac.c ****     bitstatus = RESET;
 589:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 590:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Return the DAC_FLAG status */
 591:.\StdPeriphLib\src/stm32f0xx_dac.c ****   return  bitstatus;
 593              		.loc 1 591 0
 594 000e C0B2     		uxtb	r0, r0
 592:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 595              		.loc 1 592 0
 596              		@ sp needed
 597 0010 7047     		bx	lr
 598              	.L52:
 599 0012 C046     		.align	2
 600              	.L51:
 601 0014 00740040 		.word	1073771520
 602              		.cfi_endproc
 603              	.LFE46:
 605              		.section	.text.DAC_ClearFlag,"ax",%progbits
 606              		.align	2
 607              		.global	DAC_ClearFlag
 608              		.code	16
 609              		.thumb_func
 611              	DAC_ClearFlag:
 612              	.LFB47:
 593:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 594:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 595:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Clears the DAC channel's pending flags.
 596:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Channel: The selected DAC channel. 
 597:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be one of the following values:
 598:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_1: DAC Channel1 selected
 599:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_2: DAC Channel2 selected, applicable only for STM32F072 devices
 600:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_FLAG: specifies the flag to clear. 
 601:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be of the following value:
 602:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_FLAG_DMAUDR: DMA underrun flag                           
 603:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval None
 604:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 605:.\StdPeriphLib\src/stm32f0xx_dac.c **** void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
 606:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
 613              		.loc 1 606 0
 614              		.cfi_startproc
 615              	.LVL58:
 607:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the parameters */
 608:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_CHANNEL(DAC_Channel));
 609:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_FLAG(DAC_FLAG));
 610:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 611:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Clear the selected DAC flags */
 612:.\StdPeriphLib\src/stm32f0xx_dac.c ****   DAC->SR = (DAC_FLAG << DAC_Channel);
 616              		.loc 1 612 0
 617 0000 8140     		lsl	r1, r1, r0
 618              	.LVL59:
 619 0002 014B     		ldr	r3, .L54
 620 0004 5963     		str	r1, [r3, #52]
 613:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 621              		.loc 1 613 0
 622              		@ sp needed
 623 0006 7047     		bx	lr
 624              	.L55:
 625              		.align	2
 626              	.L54:
 627 0008 00740040 		.word	1073771520
 628              		.cfi_endproc
 629              	.LFE47:
 631              		.section	.text.DAC_GetITStatus,"ax",%progbits
 632              		.align	2
 633              		.global	DAC_GetITStatus
 634              		.code	16
 635              		.thumb_func
 637              	DAC_GetITStatus:
 638              	.LFB48:
 614:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 615:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 616:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Checks whether the specified DAC interrupt has occurred or not.
 617:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Channel: The selected DAC channel. 
 618:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be one of the following values:
 619:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_1: DAC Channel1 selected
 620:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_2: DAC Channel2 selected, applicable only for STM32F072 devices
 621:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_IT: specifies the DAC interrupt source to check. 
 622:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be the following values:
 623:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
 624:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @note   The DMA underrun occurs when a second external trigger arrives before the 
 625:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *         acknowledgement for the first external trigger is received (first request).
 626:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval The new state of DAC_IT (SET or RESET).
 627:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 628:.\StdPeriphLib\src/stm32f0xx_dac.c **** ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
 629:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
 639              		.loc 1 629 0
 640              		.cfi_startproc
 641              	.LVL60:
 630:.\StdPeriphLib\src/stm32f0xx_dac.c ****   ITStatus bitstatus = RESET;
 631:.\StdPeriphLib\src/stm32f0xx_dac.c ****   uint32_t enablestatus = 0;
 632:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 633:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the parameters */
 634:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_CHANNEL(DAC_Channel));
 635:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_IT(DAC_IT));
 636:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 637:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Get the DAC_IT enable bit status */
 638:.\StdPeriphLib\src/stm32f0xx_dac.c ****   enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
 642              		.loc 1 638 0
 643 0000 054B     		ldr	r3, .L59
 644 0002 1A68     		ldr	r2, [r3]
 645 0004 8140     		lsl	r1, r1, r0
 646              	.LVL61:
 639:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 640:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the status of the specified DAC interrupt */
 641:.\StdPeriphLib\src/stm32f0xx_dac.c ****   if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
 647              		.loc 1 641 0
 648 0006 5B6B     		ldr	r3, [r3, #52]
 642:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 643:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* DAC_IT is set */
 644:.\StdPeriphLib\src/stm32f0xx_dac.c ****     bitstatus = SET;
 645:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 646:.\StdPeriphLib\src/stm32f0xx_dac.c ****   else
 647:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 648:.\StdPeriphLib\src/stm32f0xx_dac.c ****     /* DAC_IT is reset */
 649:.\StdPeriphLib\src/stm32f0xx_dac.c ****     bitstatus = RESET;
 649              		.loc 1 649 0
 650 0008 0020     		mov	r0, #0
 651              	.LVL62:
 641:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 652              		.loc 1 641 0
 653 000a 0B42     		tst	r3, r1
 654 000c 03D0     		beq	.L57
 638:.\StdPeriphLib\src/stm32f0xx_dac.c ****   
 655              		.loc 1 638 0 discriminator 1
 656 000e 1140     		and	r1, r2
 657              	.LVL63:
 641:.\StdPeriphLib\src/stm32f0xx_dac.c ****   {
 658              		.loc 1 641 0 discriminator 1
 659 0010 481E     		sub	r0, r1, #1
 660 0012 8141     		sbc	r1, r1, r0
 661              	.LVL64:
 644:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 662              		.loc 1 644 0 discriminator 1
 663 0014 C8B2     		uxtb	r0, r1
 664              	.L57:
 665              	.LVL65:
 650:.\StdPeriphLib\src/stm32f0xx_dac.c ****   }
 651:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Return the DAC_IT status */
 652:.\StdPeriphLib\src/stm32f0xx_dac.c ****   return  bitstatus;
 653:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 666              		.loc 1 653 0
 667              		@ sp needed
 668 0016 7047     		bx	lr
 669              	.L60:
 670              		.align	2
 671              	.L59:
 672 0018 00740040 		.word	1073771520
 673              		.cfi_endproc
 674              	.LFE48:
 676              		.section	.text.DAC_ClearITPendingBit,"ax",%progbits
 677              		.align	2
 678              		.global	DAC_ClearITPendingBit
 679              		.code	16
 680              		.thumb_func
 682              	DAC_ClearITPendingBit:
 683              	.LFB49:
 654:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 655:.\StdPeriphLib\src/stm32f0xx_dac.c **** /**
 656:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @brief  Clears the DAC channel's interrupt pending bits.
 657:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_Channel: The selected DAC channel. 
 658:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be one of the following values:
 659:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_1: DAC Channel1 selected
 660:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_Channel_2: DAC Channel2 selected, applicable only for STM32F072 devices
 661:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @param  DAC_IT: specifies the DAC interrupt pending bit to clear.
 662:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *          This parameter can be the following values:
 663:.\StdPeriphLib\src/stm32f0xx_dac.c ****   *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                                     
 664:.\StdPeriphLib\src/stm32f0xx_dac.c ****   * @retval None
 665:.\StdPeriphLib\src/stm32f0xx_dac.c ****   */
 666:.\StdPeriphLib\src/stm32f0xx_dac.c **** void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
 667:.\StdPeriphLib\src/stm32f0xx_dac.c **** {
 684              		.loc 1 667 0
 685              		.cfi_startproc
 686              	.LVL66:
 668:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Check the parameters */
 669:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_CHANNEL(DAC_Channel));
 670:.\StdPeriphLib\src/stm32f0xx_dac.c ****   assert_param(IS_DAC_IT(DAC_IT)); 
 671:.\StdPeriphLib\src/stm32f0xx_dac.c **** 
 672:.\StdPeriphLib\src/stm32f0xx_dac.c ****   /* Clear the selected DAC interrupt pending bits */
 673:.\StdPeriphLib\src/stm32f0xx_dac.c ****   DAC->SR = (DAC_IT << DAC_Channel);
 687              		.loc 1 673 0
 688 0000 8140     		lsl	r1, r1, r0
 689              	.LVL67:
 690 0002 014B     		ldr	r3, .L62
 691 0004 5963     		str	r1, [r3, #52]
 674:.\StdPeriphLib\src/stm32f0xx_dac.c **** }
 692              		.loc 1 674 0
 693              		@ sp needed
 694 0006 7047     		bx	lr
 695              	.L63:
 696              		.align	2
 697              	.L62:
 698 0008 00740040 		.word	1073771520
 699              		.cfi_endproc
 700              	.LFE49:
 702              		.text
 703              	.Letext0:
 704              		.file 2 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 705              		.file 3 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 706              		.file 4 ".\\CMSIS/stm32f0xx.h"
 707              		.file 5 ".\\StdPeriphLib\\inc/stm32f0xx_dac.h"
 708              		.file 6 ".\\StdPeriphLib\\inc/stm32f0xx_rcc.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f0xx_dac.c
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:18     .text.DAC_DeInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:23     .text.DAC_DeInit:00000000 DAC_DeInit
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:52     .text.DAC_Init:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:57     .text.DAC_Init:00000000 DAC_Init
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:101    .text.DAC_Init:00000024 $d
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:107    .text.DAC_StructInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:112    .text.DAC_StructInit:00000000 DAC_StructInit
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:133    .text.DAC_Cmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:138    .text.DAC_Cmd:00000000 DAC_Cmd
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:175    .text.DAC_Cmd:00000024 $d
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:180    .text.DAC_SoftwareTriggerCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:185    .text.DAC_SoftwareTriggerCmd:00000000 DAC_SoftwareTriggerCmd
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:224    .text.DAC_SoftwareTriggerCmd:00000028 $d
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:229    .text.DAC_DualSoftwareTriggerCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:234    .text.DAC_DualSoftwareTriggerCmd:00000000 DAC_DualSoftwareTriggerCmd
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:263    .text.DAC_DualSoftwareTriggerCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:268    .text.DAC_WaveGenerationCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:273    .text.DAC_WaveGenerationCmd:00000000 DAC_WaveGenerationCmd
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:307    .text.DAC_WaveGenerationCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:312    .text.DAC_SetChannel1Data:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:317    .text.DAC_SetChannel1Data:00000000 DAC_SetChannel1Data
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:347    .text.DAC_SetChannel1Data:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:352    .text.DAC_SetChannel2Data:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:357    .text.DAC_SetChannel2Data:00000000 DAC_SetChannel2Data
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:387    .text.DAC_SetChannel2Data:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:392    .text.DAC_SetDualChannelData:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:397    .text.DAC_SetDualChannelData:00000000 DAC_SetDualChannelData
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:432    .text.DAC_SetDualChannelData:00000018 $d
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:437    .text.DAC_GetDataOutputValue:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:442    .text.DAC_GetDataOutputValue:00000000 DAC_GetDataOutputValue
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:474    .text.DAC_GetDataOutputValue:00000020 $d
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:479    .text.DAC_DMACmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:484    .text.DAC_DMACmd:00000000 DAC_DMACmd
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:523    .text.DAC_DMACmd:00000028 $d
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:528    .text.DAC_ITConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:533    .text.DAC_ITConfig:00000000 DAC_ITConfig
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:567    .text.DAC_ITConfig:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:572    .text.DAC_GetFlagStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:577    .text.DAC_GetFlagStatus:00000000 DAC_GetFlagStatus
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:601    .text.DAC_GetFlagStatus:00000014 $d
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:606    .text.DAC_ClearFlag:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:611    .text.DAC_ClearFlag:00000000 DAC_ClearFlag
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:627    .text.DAC_ClearFlag:00000008 $d
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:632    .text.DAC_GetITStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:637    .text.DAC_GetITStatus:00000000 DAC_GetITStatus
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:672    .text.DAC_GetITStatus:00000018 $d
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:677    .text.DAC_ClearITPendingBit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:682    .text.DAC_ClearITPendingBit:00000000 DAC_ClearITPendingBit
C:\Users\Dima\AppData\Local\Temp\cc1pWFkK.s:698    .text.DAC_ClearITPendingBit:00000008 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
RCC_APB1PeriphResetCmd
