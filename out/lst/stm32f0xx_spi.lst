   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"stm32f0xx_spi.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.SPI_I2S_DeInit,"ax",%progbits
  18              		.align	2
  19              		.global	SPI_I2S_DeInit
  20              		.code	16
  21              		.thumb_func
  23              	SPI_I2S_DeInit:
  24              	.LFB33:
  25              		.file 1 ".\\StdPeriphLib\\src/stm32f0xx_spi.c"
   1:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
   2:.\StdPeriphLib\src/stm32f0xx_spi.c ****   ******************************************************************************
   3:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @file    stm32f0xx_spi.c
   4:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @author  MCD Application Team
   5:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @version V1.5.0
   6:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @date    05-December-2014
   7:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief   This file provides firmware functions to manage the following 
   8:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          functionalities of the Serial peripheral interface (SPI):
   9:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *           + Initialization and Configuration
  10:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *           + Data transfers functions
  11:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *           + Hardware CRC Calculation
  12:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *           + DMA transfers management
  13:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *           + Interrupts and flags management
  14:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *
  15:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *  @verbatim
  16:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
  17:.\StdPeriphLib\src/stm32f0xx_spi.c ****  ===============================================================================
  18:.\StdPeriphLib\src/stm32f0xx_spi.c ****                        ##### How to use this driver #####
  19:.\StdPeriphLib\src/stm32f0xx_spi.c ****  ===============================================================================
  20:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..]
  21:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) Enable peripheral clock using RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE)
  22:.\StdPeriphLib\src/stm32f0xx_spi.c ****             function for SPI1 or using RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE)
  23:.\StdPeriphLib\src/stm32f0xx_spi.c ****             function for SPI2.
  24:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
  25:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) Enable SCK, MOSI, MISO and NSS GPIO clocks using 
  26:.\StdPeriphLib\src/stm32f0xx_spi.c ****             RCC_AHBPeriphClockCmd() function. 
  27:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
  28:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) Peripherals alternate function: 
  29:.\StdPeriphLib\src/stm32f0xx_spi.c ****             (++) Connect the pin to the desired peripherals' Alternate 
  30:.\StdPeriphLib\src/stm32f0xx_spi.c ****                  Function (AF) using GPIO_PinAFConfig() function.
  31:.\StdPeriphLib\src/stm32f0xx_spi.c ****             (++) Configure the desired pin in alternate function by:
  32:.\StdPeriphLib\src/stm32f0xx_spi.c ****                  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF.
  33:.\StdPeriphLib\src/stm32f0xx_spi.c ****             (++) Select the type, pull-up/pull-down and output speed via 
  34:.\StdPeriphLib\src/stm32f0xx_spi.c ****                  GPIO_PuPd, GPIO_OType and GPIO_Speed members.
  35:.\StdPeriphLib\src/stm32f0xx_spi.c ****             (++) Call GPIO_Init() function.
  36:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
  37:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) Program the Polarity, Phase, First Data, Baud Rate Prescaler, Slave 
  38:.\StdPeriphLib\src/stm32f0xx_spi.c ****             Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
  39:.\StdPeriphLib\src/stm32f0xx_spi.c ****             function.In I2S mode, program the Mode, Standard, Data Format, MCLK 
  40:.\StdPeriphLib\src/stm32f0xx_spi.c ****             Output, Audio frequency and Polarity using I2S_Init() function.
  41:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
  42:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) Configure the FIFO threshold using SPI_RxFIFOThresholdConfig() to select 
  43:.\StdPeriphLib\src/stm32f0xx_spi.c ****             at which threshold the RXNE event is generated.
  44:.\StdPeriphLib\src/stm32f0xx_spi.c ****             
  45:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) Enable the NVIC and the corresponding interrupt using the function 
  46:.\StdPeriphLib\src/stm32f0xx_spi.c ****             SPI_ITConfig() if you need to use interrupt mode. 
  47:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
  48:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) When using the DMA mode 
  49:.\StdPeriphLib\src/stm32f0xx_spi.c ****             (++) Configure the DMA using DMA_Init() function.
  50:.\StdPeriphLib\src/stm32f0xx_spi.c ****             (++) Active the needed channel Request using SPI_I2S_DMACmd() function.
  51:.\StdPeriphLib\src/stm32f0xx_spi.c ****    
  52:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) Enable the SPI using the SPI_Cmd() function or enable the I2S using
  53:.\StdPeriphLib\src/stm32f0xx_spi.c ****             I2S_Cmd().
  54:.\StdPeriphLib\src/stm32f0xx_spi.c ****    
  55:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) Enable the DMA using the DMA_Cmd() function when using DMA mode. 
  56:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
  57:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) Optionally, you can enable/configure the following parameters without
  58:.\StdPeriphLib\src/stm32f0xx_spi.c ****             re-initialization (i.e there is no need to call again SPI_Init() function):
  59:.\StdPeriphLib\src/stm32f0xx_spi.c ****             (++) When bidirectional mode (SPI_Direction_1Line_Rx or SPI_Direction_1Line_Tx)
  60:.\StdPeriphLib\src/stm32f0xx_spi.c ****                  is programmed as Data direction parameter using the SPI_Init() 
  61:.\StdPeriphLib\src/stm32f0xx_spi.c ****                  function it can be possible to switch between SPI_Direction_Tx 
  62:.\StdPeriphLib\src/stm32f0xx_spi.c ****                  or SPI_Direction_Rx using the SPI_BiDirectionalLineConfig() function.
  63:.\StdPeriphLib\src/stm32f0xx_spi.c ****             (++) When SPI_NSS_Soft is selected as Slave Select Management parameter 
  64:.\StdPeriphLib\src/stm32f0xx_spi.c ****                  using the SPI_Init() function it can be possible to manage the 
  65:.\StdPeriphLib\src/stm32f0xx_spi.c ****                  NSS internal signal using the SPI_NSSInternalSoftwareConfig() function.
  66:.\StdPeriphLib\src/stm32f0xx_spi.c ****             (++) Reconfigure the data size using the SPI_DataSizeConfig() function.
  67:.\StdPeriphLib\src/stm32f0xx_spi.c ****             (++) Enable or disable the SS output using the SPI_SSOutputCmd() function.  
  68:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
  69:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) To use the CRC Hardware calculation feature refer to the Peripheral 
  70:.\StdPeriphLib\src/stm32f0xx_spi.c ****             CRC hardware Calculation subsection.
  71:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
  72:.\StdPeriphLib\src/stm32f0xx_spi.c ****     @endverbatim 
  73:.\StdPeriphLib\src/stm32f0xx_spi.c ****   ******************************************************************************
  74:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @attention
  75:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *
  76:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  77:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *
  78:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  79:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * You may not use this file except in compliance with the License.
  80:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * You may obtain a copy of the License at:
  81:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *
  82:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  83:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *
  84:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * Unless required by applicable law or agreed to in writing, software 
  85:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  86:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  87:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * See the License for the specific language governing permissions and
  88:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * limitations under the License.
  89:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *
  90:.\StdPeriphLib\src/stm32f0xx_spi.c ****   ******************************************************************************
  91:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
  92:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
  93:.\StdPeriphLib\src/stm32f0xx_spi.c **** /* Includes ------------------------------------------------------------------*/
  94:.\StdPeriphLib\src/stm32f0xx_spi.c **** #include "stm32f0xx_spi.h"
  95:.\StdPeriphLib\src/stm32f0xx_spi.c **** #include "stm32f0xx_rcc.h"
  96:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
  97:.\StdPeriphLib\src/stm32f0xx_spi.c **** /** @addtogroup STM32F0xx_StdPeriph_Driver
  98:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @{
  99:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 100:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 101:.\StdPeriphLib\src/stm32f0xx_spi.c **** /** @defgroup SPI
 102:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief SPI driver modules
 103:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @{
 104:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 105:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 106:.\StdPeriphLib\src/stm32f0xx_spi.c **** /* Private typedef -----------------------------------------------------------*/
 107:.\StdPeriphLib\src/stm32f0xx_spi.c **** /* Private define ------------------------------------------------------------*/
 108:.\StdPeriphLib\src/stm32f0xx_spi.c **** /* SPI registers Masks */
 109:.\StdPeriphLib\src/stm32f0xx_spi.c **** #define CR1_CLEAR_MASK       ((uint16_t)0x3040)
 110:.\StdPeriphLib\src/stm32f0xx_spi.c **** #define CR1_CLEAR_MASK2      ((uint16_t)0xFFFB)
 111:.\StdPeriphLib\src/stm32f0xx_spi.c **** #define CR2_LDMA_MASK        ((uint16_t)0x9FFF)
 112:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 113:.\StdPeriphLib\src/stm32f0xx_spi.c **** #define I2SCFGR_CLEAR_Mask   ((uint16_t)0xF040)
 114:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 115:.\StdPeriphLib\src/stm32f0xx_spi.c **** /* Private macro -------------------------------------------------------------*/
 116:.\StdPeriphLib\src/stm32f0xx_spi.c **** /* Private variables ---------------------------------------------------------*/
 117:.\StdPeriphLib\src/stm32f0xx_spi.c **** /* Private function prototypes -----------------------------------------------*/
 118:.\StdPeriphLib\src/stm32f0xx_spi.c **** /* Private functions ---------------------------------------------------------*/
 119:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 120:.\StdPeriphLib\src/stm32f0xx_spi.c **** /** @defgroup SPI_Private_Functions
 121:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @{
 122:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 123:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 124:.\StdPeriphLib\src/stm32f0xx_spi.c **** /** @defgroup SPI_Group1 Initialization and Configuration functions
 125:.\StdPeriphLib\src/stm32f0xx_spi.c ****  *  @brief   Initialization and Configuration functions 
 126:.\StdPeriphLib\src/stm32f0xx_spi.c ****  *
 127:.\StdPeriphLib\src/stm32f0xx_spi.c **** @verbatim   
 128:.\StdPeriphLib\src/stm32f0xx_spi.c ****  ===============================================================================
 129:.\StdPeriphLib\src/stm32f0xx_spi.c ****            ##### Initialization and Configuration functions #####
 130:.\StdPeriphLib\src/stm32f0xx_spi.c ****  ===============================================================================
 131:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] This section provides a set of functions allowing to initialize the SPI Direction,
 132:.\StdPeriphLib\src/stm32f0xx_spi.c ****          SPI Mode, SPI Data Size, SPI Polarity, SPI Phase, SPI NSS Management, SPI Baud
 133:.\StdPeriphLib\src/stm32f0xx_spi.c ****          Rate Prescaler, SPI First Bit and SPI CRC Polynomial.
 134:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 135:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] The SPI_Init() function follows the SPI configuration procedures for Master mode
 136:.\StdPeriphLib\src/stm32f0xx_spi.c ****          and Slave mode (details for these procedures are available in reference manual).
 137:.\StdPeriphLib\src/stm32f0xx_spi.c ****          
 138:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] When the Software NSS management (SPI_InitStruct->SPI_NSS = SPI_NSS_Soft) is selected,
 139:.\StdPeriphLib\src/stm32f0xx_spi.c ****          use the following function to manage the NSS bit:
 140:.\StdPeriphLib\src/stm32f0xx_spi.c ****          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft);
 141:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 142:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] In Master mode, when the Hardware NSS management (SPI_InitStruct->SPI_NSS = SPI_NSS_Hard)
 143:.\StdPeriphLib\src/stm32f0xx_spi.c ****          is selected, use the follwoing function to enable the NSS output feature.
 144:.\StdPeriphLib\src/stm32f0xx_spi.c ****          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
 145:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 146:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] The NSS pulse mode can be managed by the SPI TI mode when enabling it using the following 
 147:.\StdPeriphLib\src/stm32f0xx_spi.c ****          void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
 148:.\StdPeriphLib\src/stm32f0xx_spi.c ****          And it can be managed by software in the SPI Motorola mode using this function: 
 149:.\StdPeriphLib\src/stm32f0xx_spi.c ****          void SPI_NSSPulseModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
 150:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 151:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] This section provides also functions to initialize the I2S Mode, Standard, 
 152:.\StdPeriphLib\src/stm32f0xx_spi.c ****          Data Format, MCLK Output, Audio frequency and Polarity.
 153:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
 154:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] The I2S_Init() function follows the I2S configuration procedures for Master mode
 155:.\StdPeriphLib\src/stm32f0xx_spi.c ****          and Slave mode.
 156:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
 157:.\StdPeriphLib\src/stm32f0xx_spi.c **** @endverbatim
 158:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @{
 159:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 160:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 161:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 162:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Deinitializes the SPIx peripheral registers to their default
 163:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         reset values.
 164:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
 165:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
 166:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         I2S mode is not supported for STM32F030 devices.      
 167:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 168:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 169:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
 170:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
  26              		.loc 1 170 0
  27              		.cfi_startproc
  28              	.LVL0:
  29 0000 10B5     		push	{r4, lr}
  30              	.LCFI0:
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 4, -8
  33              		.cfi_offset 14, -4
 171:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 172:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 173:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 174:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if (SPIx == SPI1)
  34              		.loc 1 174 0
  35 0002 0E4B     		ldr	r3, .L4
  36 0004 9842     		cmp	r0, r3
  37 0006 0AD1     		bne	.L2
 175:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 176:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Enable SPI1 reset state */
 177:.\StdPeriphLib\src/stm32f0xx_spi.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
  38              		.loc 1 177 0
  39 0008 8024     		mov	r4, #128
  40 000a 6401     		lsl	r4, r4, #5
  41 000c 201C     		mov	r0, r4
  42              	.LVL1:
  43 000e 0121     		mov	r1, #1
  44 0010 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  45              	.LVL2:
 178:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Release SPI1 from reset state */
 179:.\StdPeriphLib\src/stm32f0xx_spi.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
  46              		.loc 1 179 0
  47 0014 201C     		mov	r0, r4
  48 0016 0021     		mov	r1, #0
  49 0018 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  50              	.LVL3:
  51 001c 0CE0     		b	.L1
  52              	.LVL4:
  53              	.L2:
 180:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 181:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
 182:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 183:.\StdPeriphLib\src/stm32f0xx_spi.c ****     if (SPIx == SPI2)
  54              		.loc 1 183 0
  55 001e 084B     		ldr	r3, .L4+4
  56 0020 9842     		cmp	r0, r3
  57 0022 09D1     		bne	.L1
 184:.\StdPeriphLib\src/stm32f0xx_spi.c ****     {
 185:.\StdPeriphLib\src/stm32f0xx_spi.c ****       /* Enable SPI2 reset state */
 186:.\StdPeriphLib\src/stm32f0xx_spi.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
  58              		.loc 1 186 0
  59 0024 8024     		mov	r4, #128
  60 0026 E401     		lsl	r4, r4, #7
  61 0028 201C     		mov	r0, r4
  62              	.LVL5:
  63 002a 0121     		mov	r1, #1
  64 002c FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  65              	.LVL6:
 187:.\StdPeriphLib\src/stm32f0xx_spi.c ****       /* Release SPI2 from reset state */
 188:.\StdPeriphLib\src/stm32f0xx_spi.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
  66              		.loc 1 188 0
  67 0030 201C     		mov	r0, r4
  68 0032 0021     		mov	r1, #0
  69 0034 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  70              	.LVL7:
  71              	.L1:
 189:.\StdPeriphLib\src/stm32f0xx_spi.c ****     }
 190:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 191:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
  72              		.loc 1 191 0
  73              		@ sp needed
  74 0038 10BD     		pop	{r4, pc}
  75              	.L5:
  76 003a C046     		.align	2
  77              	.L4:
  78 003c 00300140 		.word	1073819648
  79 0040 00380040 		.word	1073756160
  80              		.cfi_endproc
  81              	.LFE33:
  83              		.section	.text.SPI_StructInit,"ax",%progbits
  84              		.align	2
  85              		.global	SPI_StructInit
  86              		.code	16
  87              		.thumb_func
  89              	SPI_StructInit:
  90              	.LFB34:
 192:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 193:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 194:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Fills each SPI_InitStruct member with its default value.
 195:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure which will be initialized.
 196:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 197:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 198:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
 199:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
  91              		.loc 1 199 0
  92              		.cfi_startproc
  93              	.LVL8:
 200:.\StdPeriphLib\src/stm32f0xx_spi.c **** /*--------------- Reset SPI init structure parameters values -----------------*/
 201:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the SPI_Direction member */
 202:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
  94              		.loc 1 202 0
  95 0000 0023     		mov	r3, #0
  96 0002 0380     		strh	r3, [r0]
 203:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the SPI_Mode member */
 204:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
  97              		.loc 1 204 0
  98 0004 4380     		strh	r3, [r0, #2]
 205:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the SPI_DataSize member */
 206:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
  99              		.loc 1 206 0
 100 0006 E022     		mov	r2, #224
 101 0008 D200     		lsl	r2, r2, #3
 102 000a 8280     		strh	r2, [r0, #4]
 207:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the SPI_CPOL member */
 208:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
 103              		.loc 1 208 0
 104 000c C380     		strh	r3, [r0, #6]
 209:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the SPI_CPHA member */
 210:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
 105              		.loc 1 210 0
 106 000e 0381     		strh	r3, [r0, #8]
 211:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the SPI_NSS member */
 212:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
 107              		.loc 1 212 0
 108 0010 4381     		strh	r3, [r0, #10]
 213:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the SPI_BaudRatePrescaler member */
 214:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
 109              		.loc 1 214 0
 110 0012 8381     		strh	r3, [r0, #12]
 215:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the SPI_FirstBit member */
 216:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
 111              		.loc 1 216 0
 112 0014 C381     		strh	r3, [r0, #14]
 217:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the SPI_CRCPolynomial member */
 218:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPI_InitStruct->SPI_CRCPolynomial = 7;
 113              		.loc 1 218 0
 114 0016 0733     		add	r3, r3, #7
 115 0018 0382     		strh	r3, [r0, #16]
 219:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 116              		.loc 1 219 0
 117              		@ sp needed
 118 001a 7047     		bx	lr
 119              		.cfi_endproc
 120              	.LFE34:
 122              		.section	.text.SPI_Init,"ax",%progbits
 123              		.align	2
 124              		.global	SPI_Init
 125              		.code	16
 126              		.thumb_func
 128              	SPI_Init:
 129              	.LFB35:
 220:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 221:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 222:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Initializes the SPIx peripheral according to the specified 
 223:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         parameters in the SPI_InitStruct.
 224:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
 225:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices. 
 226:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
 227:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         contains the configuration information for the specified SPI peripheral.
 228:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 229:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 230:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
 231:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 130              		.loc 1 231 0
 131              		.cfi_startproc
 132              	.LVL9:
 133 0000 10B5     		push	{r4, lr}
 134              	.LCFI1:
 135              		.cfi_def_cfa_offset 8
 136              		.cfi_offset 4, -8
 137              		.cfi_offset 14, -4
 138              	.LVL10:
 232:.\StdPeriphLib\src/stm32f0xx_spi.c ****   uint16_t tmpreg = 0;
 233:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 234:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* check the parameters */
 235:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 236:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 237:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the SPI parameters */
 238:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
 239:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
 240:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_DATA_SIZE(SPI_InitStruct->SPI_DataSize));
 241:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
 242:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
 243:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
 244:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
 245:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
 246:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
 247:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 248:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /*---------------------------- SPIx CR1 Configuration ------------------------*/
 249:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Get the SPIx CR1 value */
 250:.\StdPeriphLib\src/stm32f0xx_spi.c ****   tmpreg = SPIx->CR1;
 139              		.loc 1 250 0
 140 0002 0488     		ldrh	r4, [r0]
 141              	.LVL11:
 251:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, CPOL and CPHA bits */
 252:.\StdPeriphLib\src/stm32f0xx_spi.c ****   tmpreg &= CR1_CLEAR_MASK;
 142              		.loc 1 252 0
 143 0004 C123     		mov	r3, #193
 144 0006 9B01     		lsl	r3, r3, #6
 145 0008 1C40     		and	r4, r3
 146              	.LVL12:
 253:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
 254:.\StdPeriphLib\src/stm32f0xx_spi.c ****   master/slave mode, CPOL and CPHA */
 255:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
 256:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Set SSM, SSI bit according to SPI_NSS values */
 257:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Set LSBFirst bit according to SPI_FirstBit value */
 258:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Set BR bits according to SPI_BaudRatePrescaler value */
 259:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Set CPOL bit according to SPI_CPOL value */
 260:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Set CPHA bit according to SPI_CPHA value */
 261:.\StdPeriphLib\src/stm32f0xx_spi.c ****   tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_FirstBit |
 147              		.loc 1 261 0
 148 000a CA89     		ldrh	r2, [r1, #14]
 149 000c 0B88     		ldrh	r3, [r1]
 150 000e 1343     		orr	r3, r2
 151 0010 CA88     		ldrh	r2, [r1, #6]
 152 0012 1343     		orr	r3, r2
 153 0014 0A89     		ldrh	r2, [r1, #8]
 154 0016 1343     		orr	r3, r2
 155 0018 4A89     		ldrh	r2, [r1, #10]
 156 001a 1343     		orr	r3, r2
 157 001c 8A89     		ldrh	r2, [r1, #12]
 158 001e 1343     		orr	r3, r2
 159 0020 2343     		orr	r3, r4
 160              	.LVL13:
 262:.\StdPeriphLib\src/stm32f0xx_spi.c ****                       SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA |
 263:.\StdPeriphLib\src/stm32f0xx_spi.c ****                       SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler);  
 264:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Write to SPIx CR1 */
 265:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->CR1 = tmpreg;
 161              		.loc 1 265 0
 162 0022 0380     		strh	r3, [r0]
 266:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /*-------------------------Data Size Configuration -----------------------*/
 267:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Get the SPIx CR2 value */
 268:.\StdPeriphLib\src/stm32f0xx_spi.c ****   tmpreg = SPIx->CR2;
 163              		.loc 1 268 0
 164 0024 8288     		ldrh	r2, [r0, #4]
 165              	.LVL14:
 269:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Clear DS[3:0] bits */
 270:.\StdPeriphLib\src/stm32f0xx_spi.c ****   tmpreg &=(uint16_t)~SPI_CR2_DS;
 166              		.loc 1 270 0
 167 0026 094B     		ldr	r3, .L8
 168 0028 1340     		and	r3, r2
 169              	.LVL15:
 271:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Configure SPIx: Data Size */
 272:.\StdPeriphLib\src/stm32f0xx_spi.c ****   tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
 170              		.loc 1 272 0
 171 002a 8A88     		ldrh	r2, [r1, #4]
 172 002c 1343     		orr	r3, r2
 173              	.LVL16:
 273:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Write to SPIx CR2 */
 274:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->CR2 = tmpreg;
 174              		.loc 1 274 0
 175 002e 8380     		strh	r3, [r0, #4]
 275:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
 276:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
 277:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Write to SPIx CRCPOLY */
 278:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 176              		.loc 1 278 0
 177 0030 0B8A     		ldrh	r3, [r1, #16]
 178              	.LVL17:
 179 0032 0382     		strh	r3, [r0, #16]
 180              	.LVL18:
 279:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
 280:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /*---------------------------- SPIx CR1 Configuration ------------------------*/
 281:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Get the SPIx CR1 value */
 282:.\StdPeriphLib\src/stm32f0xx_spi.c ****   tmpreg = SPIx->CR1;
 181              		.loc 1 282 0
 182 0034 0388     		ldrh	r3, [r0]
 183              	.LVL19:
 283:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Clear MSTR bit */
 284:.\StdPeriphLib\src/stm32f0xx_spi.c ****   tmpreg &= CR1_CLEAR_MASK2;
 184              		.loc 1 284 0
 185 0036 0422     		mov	r2, #4
 186 0038 9343     		bic	r3, r2
 187              	.LVL20:
 285:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Configure SPIx: master/slave mode */  
 286:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Set MSTR bit according to SPI_Mode */
 287:.\StdPeriphLib\src/stm32f0xx_spi.c ****   tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Mode);  
 188              		.loc 1 287 0
 189 003a 4A88     		ldrh	r2, [r1, #2]
 190 003c 1343     		orr	r3, r2
 191              	.LVL21:
 288:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Write to SPIx CR1 */
 289:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->CR1 = tmpreg;  
 192              		.loc 1 289 0
 193 003e 0380     		strh	r3, [r0]
 290:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
 291:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
 292:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
 194              		.loc 1 292 0
 195 0040 828B     		ldrh	r2, [r0, #28]
 196 0042 034B     		ldr	r3, .L8+4
 197              	.LVL22:
 198 0044 1340     		and	r3, r2
 199 0046 8383     		strh	r3, [r0, #28]
 200              	.LVL23:
 293:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 201              		.loc 1 293 0
 202              		@ sp needed
 203 0048 10BD     		pop	{r4, pc}
 204              	.L9:
 205 004a C046     		.align	2
 206              	.L8:
 207 004c FFF0FFFF 		.word	-3841
 208 0050 FFF7FFFF 		.word	-2049
 209              		.cfi_endproc
 210              	.LFE35:
 212              		.section	.text.I2S_StructInit,"ax",%progbits
 213              		.align	2
 214              		.global	I2S_StructInit
 215              		.code	16
 216              		.thumb_func
 218              	I2S_StructInit:
 219              	.LFB36:
 294:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 295:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 296:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Fills each I2S_InitStruct member with its default value.
 297:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   This mode is not supported for STM32F030 devices.  
 298:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  I2S_InitStruct: pointer to a I2S_InitTypeDef structure which will be initialized.
 299:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 300:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 301:.\StdPeriphLib\src/stm32f0xx_spi.c **** void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
 302:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 220              		.loc 1 302 0
 221              		.cfi_startproc
 222              	.LVL24:
 303:.\StdPeriphLib\src/stm32f0xx_spi.c **** /*--------------- Reset I2S init structure parameters values -----------------*/
 304:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the I2S_Mode member */
 305:.\StdPeriphLib\src/stm32f0xx_spi.c ****   I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 223              		.loc 1 305 0
 224 0000 0023     		mov	r3, #0
 225 0002 0380     		strh	r3, [r0]
 306:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 307:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the I2S_Standard member */
 308:.\StdPeriphLib\src/stm32f0xx_spi.c ****   I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
 226              		.loc 1 308 0
 227 0004 4380     		strh	r3, [r0, #2]
 309:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 310:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the I2S_DataFormat member */
 311:.\StdPeriphLib\src/stm32f0xx_spi.c ****   I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
 228              		.loc 1 311 0
 229 0006 8380     		strh	r3, [r0, #4]
 312:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 313:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the I2S_MCLKOutput member */
 314:.\StdPeriphLib\src/stm32f0xx_spi.c ****   I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
 230              		.loc 1 314 0
 231 0008 C380     		strh	r3, [r0, #6]
 315:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 316:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the I2S_AudioFreq member */
 317:.\StdPeriphLib\src/stm32f0xx_spi.c ****   I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 232              		.loc 1 317 0
 233 000a 0222     		mov	r2, #2
 234 000c 8260     		str	r2, [r0, #8]
 318:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 319:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Initialize the I2S_CPOL member */
 320:.\StdPeriphLib\src/stm32f0xx_spi.c ****   I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
 235              		.loc 1 320 0
 236 000e 8381     		strh	r3, [r0, #12]
 321:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 237              		.loc 1 321 0
 238              		@ sp needed
 239 0010 7047     		bx	lr
 240              		.cfi_endproc
 241              	.LFE36:
 243              		.global	__aeabi_uidiv
 244 0012 C046     		.section	.text.I2S_Init,"ax",%progbits
 245              		.align	2
 246              		.global	I2S_Init
 247              		.code	16
 248              		.thumb_func
 250              	I2S_Init:
 251              	.LFB37:
 322:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 323:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 324:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Initializes the SPIx peripheral according to the specified 
 325:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         parameters in the I2S_InitStruct.
 326:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   This mode is not supported for STM32F030 devices.  
 327:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 to select the SPI peripheral (configured in I2S mode).  
 328:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
 329:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         contains the configuration information for the specified SPI peripheral
 330:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         configured in I2S mode.
 331:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   This function calculates the optimal prescaler needed to obtain the most 
 332:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         accurate audio frequency (depending on the I2S clock source, the PLL values 
 333:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         and the product configuration). But in case the prescaler value is greater 
 334:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         than 511, the default value (0x02) will be configured instead.
 335:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 336:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 337:.\StdPeriphLib\src/stm32f0xx_spi.c **** void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
 338:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 252              		.loc 1 338 0
 253              		.cfi_startproc
 254              	.LVL25:
 255 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 256              	.LCFI2:
 257              		.cfi_def_cfa_offset 20
 258              		.cfi_offset 4, -20
 259              		.cfi_offset 5, -16
 260              		.cfi_offset 6, -12
 261              		.cfi_offset 7, -8
 262              		.cfi_offset 14, -4
 263 0002 8BB0     		sub	sp, sp, #44
 264              	.LCFI3:
 265              		.cfi_def_cfa_offset 64
 266 0004 051C     		mov	r5, r0
 267 0006 0C1C     		mov	r4, r1
 268              	.LVL26:
 339:.\StdPeriphLib\src/stm32f0xx_spi.c ****   uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
 340:.\StdPeriphLib\src/stm32f0xx_spi.c ****   uint32_t tmp = 0;
 341:.\StdPeriphLib\src/stm32f0xx_spi.c ****   RCC_ClocksTypeDef RCC_Clocks;
 342:.\StdPeriphLib\src/stm32f0xx_spi.c ****   uint32_t sourceclock = 0;
 343:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 344:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the I2S parameters */
 345:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_1_PERIPH(SPIx));
 346:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
 347:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
 348:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
 349:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
 350:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
 351:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
 352:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 353:.\StdPeriphLib\src/stm32f0xx_spi.c **** /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
 354:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
 355:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
 269              		.loc 1 355 0
 270 0008 828B     		ldrh	r2, [r0, #28]
 271 000a 294B     		ldr	r3, .L19
 272 000c 1340     		and	r3, r2
 273 000e 8383     		strh	r3, [r0, #28]
 356:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->I2SPR = 0x0002;
 274              		.loc 1 356 0
 275 0010 0223     		mov	r3, #2
 276 0012 0384     		strh	r3, [r0, #32]
 357:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 358:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Get the I2SCFGR register value */
 359:.\StdPeriphLib\src/stm32f0xx_spi.c ****   tmpreg = SPIx->I2SCFGR;
 277              		.loc 1 359 0
 278 0014 868B     		ldrh	r6, [r0, #28]
 279 0016 B6B2     		uxth	r6, r6
 280              	.LVL27:
 360:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 361:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
 362:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 281              		.loc 1 362 0
 282 0018 8B68     		ldr	r3, [r1, #8]
 283 001a 022B     		cmp	r3, #2
 284 001c 31D0     		beq	.L16
 363:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 364:.\StdPeriphLib\src/stm32f0xx_spi.c ****     i2sodd = (uint16_t)0;
 365:.\StdPeriphLib\src/stm32f0xx_spi.c ****     i2sdiv = (uint16_t)2;   
 366:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 367:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* If the requested audio frequency is not the default, compute the prescaler */
 368:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
 369:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 370:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Check the frame length (For the Prescaler computing) */
 371:.\StdPeriphLib\src/stm32f0xx_spi.c ****     if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
 285              		.loc 1 371 0
 286 001e 8B88     		ldrh	r3, [r1, #4]
 372:.\StdPeriphLib\src/stm32f0xx_spi.c ****     {
 373:.\StdPeriphLib\src/stm32f0xx_spi.c ****       /* Packet length is 16 bits */
 374:.\StdPeriphLib\src/stm32f0xx_spi.c ****       packetlength = 1;
 375:.\StdPeriphLib\src/stm32f0xx_spi.c ****     }
 376:.\StdPeriphLib\src/stm32f0xx_spi.c ****     else
 377:.\StdPeriphLib\src/stm32f0xx_spi.c ****     {
 378:.\StdPeriphLib\src/stm32f0xx_spi.c ****       /* Packet length is 32 bits */
 379:.\StdPeriphLib\src/stm32f0xx_spi.c ****       packetlength = 2;
 287              		.loc 1 379 0
 288 0020 5F42     		neg	r7, r3
 289 0022 5F41     		adc	r7, r7, r3
 290 0024 0223     		mov	r3, #2
 291 0026 DF1B     		sub	r7, r3, r7
 292              	.LVL28:
 380:.\StdPeriphLib\src/stm32f0xx_spi.c ****     }
 381:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 382:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* I2S Clock source is System clock: Get System Clock frequency */
 383:.\StdPeriphLib\src/stm32f0xx_spi.c ****     RCC_GetClocksFreq(&RCC_Clocks);      
 293              		.loc 1 383 0
 294 0028 6846     		mov	r0, sp
 295              	.LVL29:
 296 002a FFF7FEFF 		bl	RCC_GetClocksFreq
 297              	.LVL30:
 384:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 385:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Get the source clock value: based on System Clock value */
 386:.\StdPeriphLib\src/stm32f0xx_spi.c ****     sourceclock = RCC_Clocks.SYSCLK_Frequency;    
 298              		.loc 1 386 0
 299 002e 0098     		ldr	r0, [sp]
 300              	.LVL31:
 387:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 388:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Compute the Real divider depending on the MCLK output state with a floating point */
 389:.\StdPeriphLib\src/stm32f0xx_spi.c ****     if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 301              		.loc 1 389 0
 302 0030 E288     		ldrh	r2, [r4, #6]
 303 0032 8023     		mov	r3, #128
 304 0034 9B00     		lsl	r3, r3, #2
 305 0036 9A42     		cmp	r2, r3
 306 0038 09D1     		bne	.L14
 390:.\StdPeriphLib\src/stm32f0xx_spi.c ****     {
 391:.\StdPeriphLib\src/stm32f0xx_spi.c ****       /* MCLK output is enabled */
 392:.\StdPeriphLib\src/stm32f0xx_spi.c ****       tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 307              		.loc 1 392 0
 308 003a 000A     		lsr	r0, r0, #8
 309              	.LVL32:
 310 003c 8300     		lsl	r3, r0, #2
 311 003e 1818     		add	r0, r3, r0
 312 0040 4000     		lsl	r0, r0, #1
 313 0042 A168     		ldr	r1, [r4, #8]
 314 0044 FFF7FEFF 		bl	__aeabi_uidiv
 315              	.LVL33:
 316 0048 0530     		add	r0, r0, #5
 317 004a 80B2     		uxth	r0, r0
 318              	.LVL34:
 319 004c 0AE0     		b	.L15
 320              	.LVL35:
 321              	.L14:
 393:.\StdPeriphLib\src/stm32f0xx_spi.c ****     }
 394:.\StdPeriphLib\src/stm32f0xx_spi.c ****     else
 395:.\StdPeriphLib\src/stm32f0xx_spi.c ****     {
 396:.\StdPeriphLib\src/stm32f0xx_spi.c ****       /* MCLK output is disabled */
 397:.\StdPeriphLib\src/stm32f0xx_spi.c ****       tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq
 322              		.loc 1 397 0
 323 004e 7901     		lsl	r1, r7, #5
 324 0050 FFF7FEFF 		bl	__aeabi_uidiv
 325              	.LVL36:
 326 0054 8300     		lsl	r3, r0, #2
 327 0056 1818     		add	r0, r3, r0
 328 0058 4000     		lsl	r0, r0, #1
 329 005a A168     		ldr	r1, [r4, #8]
 330 005c FFF7FEFF 		bl	__aeabi_uidiv
 331              	.LVL37:
 332 0060 0530     		add	r0, r0, #5
 333 0062 80B2     		uxth	r0, r0
 334              	.LVL38:
 335              	.L15:
 398:.\StdPeriphLib\src/stm32f0xx_spi.c ****     }
 399:.\StdPeriphLib\src/stm32f0xx_spi.c ****     
 400:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Remove the floating point */
 401:.\StdPeriphLib\src/stm32f0xx_spi.c ****     tmp = tmp / 10;
 336              		.loc 1 401 0
 337 0064 0A21     		mov	r1, #10
 338 0066 FFF7FEFF 		bl	__aeabi_uidiv
 339              	.LVL39:
 402:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 403:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Check the parity of the divider */
 404:.\StdPeriphLib\src/stm32f0xx_spi.c ****     i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
 340              		.loc 1 404 0
 341 006a 0123     		mov	r3, #1
 342 006c 0340     		and	r3, r0
 343              	.LVL40:
 405:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 406:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Compute the i2sdiv prescaler */
 407:.\StdPeriphLib\src/stm32f0xx_spi.c ****     i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 344              		.loc 1 407 0
 345 006e C01A     		sub	r0, r0, r3
 346              	.LVL41:
 347 0070 4008     		lsr	r0, r0, #1
 348 0072 80B2     		uxth	r0, r0
 349              	.LVL42:
 408:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 409:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
 410:.\StdPeriphLib\src/stm32f0xx_spi.c ****     i2sodd = (uint16_t) (i2sodd << 8);
 411:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 412:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 413:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Test if the divider is 1 or 0 or greater than 0xFF */
 414:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if ((i2sdiv < 2) || (i2sdiv > 0xFF))
 350              		.loc 1 414 0
 351 0074 821E     		sub	r2, r0, #2
 352 0076 92B2     		uxth	r2, r2
 353 0078 FD2A     		cmp	r2, #253
 354 007a 05D8     		bhi	.L18
 410:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 355              		.loc 1 410 0
 356 007c 1B02     		lsl	r3, r3, #8
 357              	.LVL43:
 358 007e 9BB2     		uxth	r3, r3
 359 0080 04E0     		b	.L12
 360              	.LVL44:
 361              	.L16:
 364:.\StdPeriphLib\src/stm32f0xx_spi.c ****     i2sdiv = (uint16_t)2;   
 362              		.loc 1 364 0
 363 0082 0023     		mov	r3, #0
 365:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 364              		.loc 1 365 0
 365 0084 0220     		mov	r0, #2
 366              	.LVL45:
 367 0086 01E0     		b	.L12
 368              	.LVL46:
 369              	.L18:
 415:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 416:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Set the default values */
 417:.\StdPeriphLib\src/stm32f0xx_spi.c ****     i2sdiv = 2;
 418:.\StdPeriphLib\src/stm32f0xx_spi.c ****     i2sodd = 0;
 370              		.loc 1 418 0
 371 0088 0023     		mov	r3, #0
 372              	.LVL47:
 417:.\StdPeriphLib\src/stm32f0xx_spi.c ****     i2sodd = 0;
 373              		.loc 1 417 0
 374 008a 0220     		mov	r0, #2
 375              	.LVL48:
 376              	.L12:
 377 008c 1843     		orr	r0, r3
 378              	.LVL49:
 419:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 420:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 421:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Write to SPIx I2SPR register the computed value */
 422:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 379              		.loc 1 422 0
 380 008e E388     		ldrh	r3, [r4, #6]
 381              	.LVL50:
 382 0090 1843     		orr	r0, r3
 383 0092 2884     		strh	r0, [r5, #32]
 384 0094 2388     		ldrh	r3, [r4]
 385 0096 1E43     		orr	r6, r3
 386              	.LVL51:
 387 0098 8023     		mov	r3, #128
 388 009a 1B01     		lsl	r3, r3, #4
 389 009c 1E43     		orr	r6, r3
 390 009e 6388     		ldrh	r3, [r4, #2]
 391 00a0 1E43     		orr	r6, r3
 392 00a2 A388     		ldrh	r3, [r4, #4]
 393 00a4 1E43     		orr	r6, r3
 423:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 424:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Configure the I2S with the SPI_InitStruct values */
 425:.\StdPeriphLib\src/stm32f0xx_spi.c ****   tmpreg |= (uint16_t)(SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 394              		.loc 1 425 0
 395 00a6 A389     		ldrh	r3, [r4, #12]
 396 00a8 1E43     		orr	r6, r3
 397              	.LVL52:
 426:.\StdPeriphLib\src/stm32f0xx_spi.c ****                   (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataForm
 427:.\StdPeriphLib\src/stm32f0xx_spi.c ****                   (uint16_t)I2S_InitStruct->I2S_CPOL))));
 428:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 429:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Write to SPIx I2SCFGR */
 430:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->I2SCFGR = tmpreg;
 398              		.loc 1 430 0
 399 00aa AE83     		strh	r6, [r5, #28]
 431:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 400              		.loc 1 431 0
 401 00ac 0BB0     		add	sp, sp, #44
 402              		@ sp needed
 403              	.LVL53:
 404              	.LVL54:
 405              	.LVL55:
 406 00ae F0BD     		pop	{r4, r5, r6, r7, pc}
 407              	.L20:
 408              		.align	2
 409              	.L19:
 410 00b0 40F0FFFF 		.word	-4032
 411              		.cfi_endproc
 412              	.LFE37:
 414              		.section	.text.SPI_Cmd,"ax",%progbits
 415              		.align	2
 416              		.global	SPI_Cmd
 417              		.code	16
 418              		.thumb_func
 420              	SPI_Cmd:
 421              	.LFB38:
 432:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 433:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 434:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Enables or disables the specified SPI peripheral.
 435:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
 436:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
 437:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  NewState: new state of the SPIx peripheral. 
 438:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be: ENABLE or DISABLE.
 439:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 440:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 441:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
 442:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 422              		.loc 1 442 0
 423              		.cfi_startproc
 424              	.LVL56:
 443:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 444:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 445:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 446:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 447:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if (NewState != DISABLE)
 425              		.loc 1 447 0
 426 0000 0029     		cmp	r1, #0
 427 0002 04D0     		beq	.L22
 448:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 449:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Enable the selected SPI peripheral */
 450:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR1 |= SPI_CR1_SPE;
 428              		.loc 1 450 0
 429 0004 0288     		ldrh	r2, [r0]
 430 0006 4023     		mov	r3, #64
 431 0008 1343     		orr	r3, r2
 432 000a 0380     		strh	r3, [r0]
 433 000c 03E0     		b	.L21
 434              	.L22:
 451:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 452:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
 453:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 454:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Disable the selected SPI peripheral */
 455:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 435              		.loc 1 455 0
 436 000e 0388     		ldrh	r3, [r0]
 437 0010 4022     		mov	r2, #64
 438 0012 9343     		bic	r3, r2
 439 0014 0380     		strh	r3, [r0]
 440              	.L21:
 456:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 457:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 441              		.loc 1 457 0
 442              		@ sp needed
 443 0016 7047     		bx	lr
 444              		.cfi_endproc
 445              	.LFE38:
 447              		.section	.text.SPI_TIModeCmd,"ax",%progbits
 448              		.align	2
 449              		.global	SPI_TIModeCmd
 450              		.code	16
 451              		.thumb_func
 453              	SPI_TIModeCmd:
 454              	.LFB39:
 458:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 459:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 460:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Enables or disables the TI Mode.
 461:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *   
 462:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   This function can be called only after the SPI_Init() function has 
 463:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         been called. 
 464:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   When TI mode is selected, the control bits SSM, SSI, CPOL and CPHA 
 465:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         are not taken into consideration and are configured by hardware 
 466:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         respectively to the TI mode requirements.
 467:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *    
 468:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
 469:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
 470:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  NewState: new state of the selected SPI TI communication mode.
 471:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be: ENABLE or DISABLE.
 472:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 473:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 474:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
 475:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 455              		.loc 1 475 0
 456              		.cfi_startproc
 457              	.LVL57:
 476:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 477:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 478:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 479:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 480:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if (NewState != DISABLE)
 458              		.loc 1 480 0
 459 0000 0029     		cmp	r1, #0
 460 0002 04D0     		beq	.L25
 481:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 482:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Enable the TI mode for the selected SPI peripheral */
 483:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR2 |= SPI_CR2_FRF;
 461              		.loc 1 483 0
 462 0004 8288     		ldrh	r2, [r0, #4]
 463 0006 1023     		mov	r3, #16
 464 0008 1343     		orr	r3, r2
 465 000a 8380     		strh	r3, [r0, #4]
 466 000c 03E0     		b	.L24
 467              	.L25:
 484:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 485:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
 486:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 487:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Disable the TI mode for the selected SPI peripheral */
 488:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRF);
 468              		.loc 1 488 0
 469 000e 8388     		ldrh	r3, [r0, #4]
 470 0010 1022     		mov	r2, #16
 471 0012 9343     		bic	r3, r2
 472 0014 8380     		strh	r3, [r0, #4]
 473              	.L24:
 489:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 490:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 474              		.loc 1 490 0
 475              		@ sp needed
 476 0016 7047     		bx	lr
 477              		.cfi_endproc
 478              	.LFE39:
 480              		.section	.text.I2S_Cmd,"ax",%progbits
 481              		.align	2
 482              		.global	I2S_Cmd
 483              		.code	16
 484              		.thumb_func
 486              	I2S_Cmd:
 487              	.LFB40:
 491:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 492:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 493:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
 494:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   This mode is not supported for STM32F030 devices.    
 495:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 to select the SPI peripheral.
 496:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  NewState: new state of the SPIx peripheral. 
 497:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be: ENABLE or DISABLE.
 498:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 499:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 500:.\StdPeriphLib\src/stm32f0xx_spi.c **** void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
 501:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 488              		.loc 1 501 0
 489              		.cfi_startproc
 490              	.LVL58:
 502:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 503:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_1_PERIPH(SPIx));
 504:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 505:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if (NewState != DISABLE)
 491              		.loc 1 505 0
 492 0000 0029     		cmp	r1, #0
 493 0002 05D0     		beq	.L28
 506:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 507:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Enable the selected SPI peripheral in I2S mode */
 508:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 494              		.loc 1 508 0
 495 0004 828B     		ldrh	r2, [r0, #28]
 496 0006 8023     		mov	r3, #128
 497 0008 DB00     		lsl	r3, r3, #3
 498 000a 1343     		orr	r3, r2
 499 000c 8383     		strh	r3, [r0, #28]
 500 000e 03E0     		b	.L27
 501              	.L28:
 509:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 510:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
 511:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 512:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Disable the selected SPI peripheral in I2S mode */
 513:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
 502              		.loc 1 513 0
 503 0010 828B     		ldrh	r2, [r0, #28]
 504 0012 024B     		ldr	r3, .L30
 505 0014 1340     		and	r3, r2
 506 0016 8383     		strh	r3, [r0, #28]
 507              	.L27:
 514:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 515:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 508              		.loc 1 515 0
 509              		@ sp needed
 510 0018 7047     		bx	lr
 511              	.L31:
 512 001a C046     		.align	2
 513              	.L30:
 514 001c FFFBFFFF 		.word	-1025
 515              		.cfi_endproc
 516              	.LFE40:
 518              		.section	.text.SPI_DataSizeConfig,"ax",%progbits
 519              		.align	2
 520              		.global	SPI_DataSizeConfig
 521              		.code	16
 522              		.thumb_func
 524              	SPI_DataSizeConfig:
 525              	.LFB41:
 516:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 517:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 518:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Configures the data size for the selected SPI.
 519:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2  to select the SPI peripheral.
 520:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices. 
 521:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPI_DataSize: specifies the SPI data size.
 522:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         For the SPIx peripheral this parameter can be one of the following values:
 523:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_DataSize_4b: Set data size to 4 bits
 524:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_DataSize_5b: Set data size to 5 bits
 525:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_DataSize_6b: Set data size to 6 bits
 526:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_DataSize_7b: Set data size to 7 bits
 527:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_DataSize_8b: Set data size to 8 bits
 528:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_DataSize_9b: Set data size to 9 bits
 529:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_DataSize_10b: Set data size to 10 bits
 530:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_DataSize_11b: Set data size to 11 bits
 531:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_DataSize_12b: Set data size to 12 bits
 532:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_DataSize_13b: Set data size to 13 bits
 533:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_DataSize_14b: Set data size to 14 bits
 534:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_DataSize_15b: Set data size to 15 bits
 535:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_DataSize_16b: Set data size to 16 bits
 536:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 537:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 538:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
 539:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 526              		.loc 1 539 0
 527              		.cfi_startproc
 528              	.LVL59:
 540:.\StdPeriphLib\src/stm32f0xx_spi.c ****   uint16_t tmpreg = 0;
 541:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
 542:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 543:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 544:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_DATA_SIZE(SPI_DataSize));
 545:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Read the CR2 register */
 546:.\StdPeriphLib\src/stm32f0xx_spi.c ****   tmpreg = SPIx->CR2;
 529              		.loc 1 546 0
 530 0000 8288     		ldrh	r2, [r0, #4]
 531              	.LVL60:
 547:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Clear DS[3:0] bits */
 548:.\StdPeriphLib\src/stm32f0xx_spi.c ****   tmpreg &= (uint16_t)~SPI_CR2_DS;
 532              		.loc 1 548 0
 533 0002 024B     		ldr	r3, .L33
 534 0004 1340     		and	r3, r2
 535              	.LVL61:
 549:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Set new DS[3:0] bits value */
 550:.\StdPeriphLib\src/stm32f0xx_spi.c ****   tmpreg |= SPI_DataSize;
 536              		.loc 1 550 0
 537 0006 1943     		orr	r1, r3
 538              	.LVL62:
 551:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->CR2 = tmpreg;
 539              		.loc 1 551 0
 540 0008 8180     		strh	r1, [r0, #4]
 552:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 541              		.loc 1 552 0
 542              		@ sp needed
 543 000a 7047     		bx	lr
 544              	.L34:
 545              		.align	2
 546              	.L33:
 547 000c FFF0FFFF 		.word	-3841
 548              		.cfi_endproc
 549              	.LFE41:
 551              		.section	.text.SPI_RxFIFOThresholdConfig,"ax",%progbits
 552              		.align	2
 553              		.global	SPI_RxFIFOThresholdConfig
 554              		.code	16
 555              		.thumb_func
 557              	SPI_RxFIFOThresholdConfig:
 558              	.LFB42:
 553:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 554:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 555:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Configures the FIFO reception threshold for the selected SPI.
 556:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
 557:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices. 
 558:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPI_RxFIFOThreshold: specifies the FIFO reception threshold.
 559:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be one of the following values:
 560:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_RxFIFOThreshold_HF: RXNE event is generated if the FIFO 
 561:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *                                         level is greater or equal to 1/2. 
 562:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_RxFIFOThreshold_QF: RXNE event is generated if the FIFO 
 563:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *                                         level is greater or equal to 1/4. 
 564:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 565:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 566:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_RxFIFOThresholdConfig(SPI_TypeDef* SPIx, uint16_t SPI_RxFIFOThreshold)
 567:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 559              		.loc 1 567 0
 560              		.cfi_startproc
 561              	.LVL63:
 568:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 569:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 570:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_RX_FIFO_THRESHOLD(SPI_RxFIFOThreshold));
 571:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 572:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Clear FRXTH bit */
 573:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRXTH);
 562              		.loc 1 573 0
 563 0000 8288     		ldrh	r2, [r0, #4]
 564 0002 034B     		ldr	r3, .L36
 565 0004 1340     		and	r3, r2
 566 0006 8380     		strh	r3, [r0, #4]
 574:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 575:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Set new FRXTH bit value */
 576:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->CR2 |= SPI_RxFIFOThreshold;
 567              		.loc 1 576 0
 568 0008 8388     		ldrh	r3, [r0, #4]
 569 000a 1943     		orr	r1, r3
 570              	.LVL64:
 571 000c 8180     		strh	r1, [r0, #4]
 577:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 572              		.loc 1 577 0
 573              		@ sp needed
 574 000e 7047     		bx	lr
 575              	.L37:
 576              		.align	2
 577              	.L36:
 578 0010 FFEFFFFF 		.word	-4097
 579              		.cfi_endproc
 580              	.LFE42:
 582              		.section	.text.SPI_BiDirectionalLineConfig,"ax",%progbits
 583              		.align	2
 584              		.global	SPI_BiDirectionalLineConfig
 585              		.code	16
 586              		.thumb_func
 588              	SPI_BiDirectionalLineConfig:
 589              	.LFB43:
 578:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 579:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 580:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Selects the data transfer direction in bidirectional mode for the specified SPI.
 581:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2  to select the SPI peripheral.
 582:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices. 
 583:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPI_Direction: specifies the data transfer direction in bidirectional mode. 
 584:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be one of the following values:
 585:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_Direction_Tx: Selects Tx transmission direction
 586:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_Direction_Rx: Selects Rx receive direction
 587:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 588:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 589:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
 590:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 590              		.loc 1 590 0
 591              		.cfi_startproc
 592              	.LVL65:
 591:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 592:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 593:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_DIRECTION(SPI_Direction));
 594:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if (SPI_Direction == SPI_Direction_Tx)
 593              		.loc 1 594 0
 594 0000 8023     		mov	r3, #128
 595 0002 DB01     		lsl	r3, r3, #7
 596 0004 9942     		cmp	r1, r3
 597 0006 03D1     		bne	.L39
 595:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 596:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Set the Tx only mode */
 597:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR1 |= SPI_Direction_Tx;
 598              		.loc 1 597 0
 599 0008 0288     		ldrh	r2, [r0]
 600 000a 1343     		orr	r3, r2
 601 000c 0380     		strh	r3, [r0]
 602 000e 03E0     		b	.L38
 603              	.L39:
 598:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 599:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
 600:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 601:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Set the Rx only mode */
 602:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR1 &= SPI_Direction_Rx;
 604              		.loc 1 602 0
 605 0010 0288     		ldrh	r2, [r0]
 606 0012 024B     		ldr	r3, .L41
 607 0014 1340     		and	r3, r2
 608 0016 0380     		strh	r3, [r0]
 609              	.L38:
 603:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 604:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 610              		.loc 1 604 0
 611              		@ sp needed
 612 0018 7047     		bx	lr
 613              	.L42:
 614 001a C046     		.align	2
 615              	.L41:
 616 001c FFBFFFFF 		.word	-16385
 617              		.cfi_endproc
 618              	.LFE43:
 620              		.section	.text.SPI_NSSInternalSoftwareConfig,"ax",%progbits
 621              		.align	2
 622              		.global	SPI_NSSInternalSoftwareConfig
 623              		.code	16
 624              		.thumb_func
 626              	SPI_NSSInternalSoftwareConfig:
 627              	.LFB44:
 605:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 606:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 607:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Configures internally by software the NSS pin for the selected SPI.
 608:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   This function can be called only after the SPI_Init() function has 
 609:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         been called.  
 610:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
 611:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.  
 612:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
 613:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be one of the following values:
 614:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
 615:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
 616:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 617:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 618:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
 619:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 628              		.loc 1 619 0
 629              		.cfi_startproc
 630              	.LVL66:
 620:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 621:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 622:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
 623:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 624:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 631              		.loc 1 624 0
 632 0000 064B     		ldr	r3, .L46
 633 0002 9942     		cmp	r1, r3
 634 0004 05D0     		beq	.L44
 625:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 626:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Set NSS pin internally by software */
 627:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 635              		.loc 1 627 0
 636 0006 0288     		ldrh	r2, [r0]
 637 0008 8023     		mov	r3, #128
 638 000a 5B00     		lsl	r3, r3, #1
 639 000c 1343     		orr	r3, r2
 640 000e 0380     		strh	r3, [r0]
 641 0010 03E0     		b	.L43
 642              	.L44:
 628:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 629:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
 630:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 631:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Reset NSS pin internally by software */
 632:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
 643              		.loc 1 632 0
 644 0012 0288     		ldrh	r2, [r0]
 645 0014 024B     		ldr	r3, .L46+4
 646 0016 1340     		and	r3, r2
 647 0018 0380     		strh	r3, [r0]
 648              	.L43:
 633:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 634:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 649              		.loc 1 634 0
 650              		@ sp needed
 651 001a 7047     		bx	lr
 652              	.L47:
 653              		.align	2
 654              	.L46:
 655 001c FFFE0000 		.word	65279
 656 0020 FFFEFFFF 		.word	-257
 657              		.cfi_endproc
 658              	.LFE44:
 660              		.section	.text.SPI_SSOutputCmd,"ax",%progbits
 661              		.align	2
 662              		.global	SPI_SSOutputCmd
 663              		.code	16
 664              		.thumb_func
 666              	SPI_SSOutputCmd:
 667              	.LFB45:
 635:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 636:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 637:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Enables or disables the SS output for the selected SPI.
 638:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   This function can be called only after the SPI_Init() function has 
 639:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         been called and the NSS hardware management mode is selected. 
 640:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
 641:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.  
 642:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  NewState: new state of the SPIx SS output. 
 643:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be: ENABLE or DISABLE.
 644:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 645:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 646:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
 647:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 668              		.loc 1 647 0
 669              		.cfi_startproc
 670              	.LVL67:
 648:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 649:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 650:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 651:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if (NewState != DISABLE)
 671              		.loc 1 651 0
 672 0000 0029     		cmp	r1, #0
 673 0002 04D0     		beq	.L49
 652:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 653:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Enable the selected SPI SS output */
 654:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR2 |= SPI_CR2_SSOE;
 674              		.loc 1 654 0
 675 0004 8288     		ldrh	r2, [r0, #4]
 676 0006 0423     		mov	r3, #4
 677 0008 1343     		orr	r3, r2
 678 000a 8380     		strh	r3, [r0, #4]
 679 000c 03E0     		b	.L48
 680              	.L49:
 655:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 656:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
 657:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 658:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Disable the selected SPI SS output */
 659:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
 681              		.loc 1 659 0
 682 000e 8388     		ldrh	r3, [r0, #4]
 683 0010 0422     		mov	r2, #4
 684 0012 9343     		bic	r3, r2
 685 0014 8380     		strh	r3, [r0, #4]
 686              	.L48:
 660:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 661:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 687              		.loc 1 661 0
 688              		@ sp needed
 689 0016 7047     		bx	lr
 690              		.cfi_endproc
 691              	.LFE45:
 693              		.section	.text.SPI_NSSPulseModeCmd,"ax",%progbits
 694              		.align	2
 695              		.global	SPI_NSSPulseModeCmd
 696              		.code	16
 697              		.thumb_func
 699              	SPI_NSSPulseModeCmd:
 700              	.LFB46:
 662:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 663:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 664:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Enables or disables the NSS pulse management mode.
 665:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   This function can be called only after the SPI_Init() function has 
 666:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         been called. 
 667:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   When TI mode is selected, the control bits NSSP is not taken into 
 668:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         consideration and are configured by hardware respectively to the 
 669:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         TI mode requirements. 
 670:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
 671:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
 672:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  NewState: new state of the NSS pulse management mode.
 673:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be: ENABLE or DISABLE.
 674:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 675:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 676:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_NSSPulseModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
 677:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 701              		.loc 1 677 0
 702              		.cfi_startproc
 703              	.LVL68:
 678:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 679:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 680:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 681:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 682:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if (NewState != DISABLE)
 704              		.loc 1 682 0
 705 0000 0029     		cmp	r1, #0
 706 0002 04D0     		beq	.L52
 683:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 684:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Enable the NSS pulse management mode */
 685:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR2 |= SPI_CR2_NSSP;
 707              		.loc 1 685 0
 708 0004 8288     		ldrh	r2, [r0, #4]
 709 0006 0823     		mov	r3, #8
 710 0008 1343     		orr	r3, r2
 711 000a 8380     		strh	r3, [r0, #4]
 712 000c 03E0     		b	.L51
 713              	.L52:
 686:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 687:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
 688:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 689:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Disable the NSS pulse management mode */
 690:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_NSSP);    
 714              		.loc 1 690 0
 715 000e 8388     		ldrh	r3, [r0, #4]
 716 0010 0822     		mov	r2, #8
 717 0012 9343     		bic	r3, r2
 718 0014 8380     		strh	r3, [r0, #4]
 719              	.L51:
 691:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 692:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 720              		.loc 1 692 0
 721              		@ sp needed
 722 0016 7047     		bx	lr
 723              		.cfi_endproc
 724              	.LFE46:
 726              		.section	.text.SPI_SendData8,"ax",%progbits
 727              		.align	2
 728              		.global	SPI_SendData8
 729              		.code	16
 730              		.thumb_func
 732              	SPI_SendData8:
 733              	.LFB47:
 693:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 694:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 695:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @}
 696:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 697:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 698:.\StdPeriphLib\src/stm32f0xx_spi.c **** /** @defgroup SPI_Group2 Data transfers functions
 699:.\StdPeriphLib\src/stm32f0xx_spi.c ****  *  @brief   Data transfers functions
 700:.\StdPeriphLib\src/stm32f0xx_spi.c ****  *
 701:.\StdPeriphLib\src/stm32f0xx_spi.c **** @verbatim
 702:.\StdPeriphLib\src/stm32f0xx_spi.c ****  ===============================================================================
 703:.\StdPeriphLib\src/stm32f0xx_spi.c ****                     ##### Data transfers functions #####
 704:.\StdPeriphLib\src/stm32f0xx_spi.c ****  ===============================================================================
 705:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] This section provides a set of functions allowing to manage the SPI or I2S
 706:.\StdPeriphLib\src/stm32f0xx_spi.c ****          data transfers.
 707:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 708:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] In reception, data are received and then stored into an internal Rx buffer while 
 709:.\StdPeriphLib\src/stm32f0xx_spi.c ****          In transmission, data are first stored into an internal Tx buffer before being 
 710:.\StdPeriphLib\src/stm32f0xx_spi.c ****          transmitted.
 711:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 712:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] The read access of the SPI_DR register can be done using 
 713:.\StdPeriphLib\src/stm32f0xx_spi.c ****          SPI_ReceiveData8() (when data size is equal or inferior than 8bits) and.
 714:.\StdPeriphLib\src/stm32f0xx_spi.c ****          SPI_I2S_ReceiveData16() (when data size is superior than 8bits)function
 715:.\StdPeriphLib\src/stm32f0xx_spi.c ****          and returns the Rx buffered value. Whereas a write access to the SPI_DR 
 716:.\StdPeriphLib\src/stm32f0xx_spi.c ****          can be done using SPI_SendData8() (when data size is equal or inferior than 8bits)
 717:.\StdPeriphLib\src/stm32f0xx_spi.c ****          and SPI_I2S_SendData16() (when data size is superior than 8bits) function 
 718:.\StdPeriphLib\src/stm32f0xx_spi.c ****          and stores the written data into Tx buffer.
 719:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 720:.\StdPeriphLib\src/stm32f0xx_spi.c **** @endverbatim
 721:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @{
 722:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 723:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 724:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 725:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
 726:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 in SPI mode to select the SPI peripheral.
 727:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
 728:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  Data: Data to be transmitted.
 729:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 730:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 731:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_SendData8(SPI_TypeDef* SPIx, uint8_t Data)
 732:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 734              		.loc 1 732 0
 735              		.cfi_startproc
 736              	.LVL69:
 733:.\StdPeriphLib\src/stm32f0xx_spi.c ****   uint32_t spixbase = 0x00;
 734:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 735:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 736:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 737:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 738:.\StdPeriphLib\src/stm32f0xx_spi.c ****   spixbase = (uint32_t)SPIx; 
 739:.\StdPeriphLib\src/stm32f0xx_spi.c ****   spixbase += 0x0C;
 740:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
 741:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *(__IO uint8_t *) spixbase = Data;
 737              		.loc 1 741 0
 738 0000 0173     		strb	r1, [r0, #12]
 742:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 739              		.loc 1 742 0
 740              		@ sp needed
 741 0002 7047     		bx	lr
 742              		.cfi_endproc
 743              	.LFE47:
 745              		.section	.text.SPI_I2S_SendData16,"ax",%progbits
 746              		.align	2
 747              		.global	SPI_I2S_SendData16
 748              		.code	16
 749              		.thumb_func
 751              	SPI_I2S_SendData16:
 752              	.LFB48:
 743:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 744:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 745:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
 746:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
 747:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         the SPI peripheral. 
 748:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices. 
 749:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  Data: Data to be transmitted.
 750:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 751:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 752:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_I2S_SendData16(SPI_TypeDef* SPIx, uint16_t Data)
 753:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 753              		.loc 1 753 0
 754              		.cfi_startproc
 755              	.LVL70:
 754:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 755:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 756:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
 757:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->DR = (uint16_t)Data;
 756              		.loc 1 757 0
 757 0000 8181     		strh	r1, [r0, #12]
 758:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 758              		.loc 1 758 0
 759              		@ sp needed
 760 0002 7047     		bx	lr
 761              		.cfi_endproc
 762              	.LFE48:
 764              		.section	.text.SPI_ReceiveData8,"ax",%progbits
 765              		.align	2
 766              		.global	SPI_ReceiveData8
 767              		.code	16
 768              		.thumb_func
 770              	SPI_ReceiveData8:
 771              	.LFB49:
 759:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 760:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 761:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral. 
 762:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 in SPI mode to select the SPI peripheral. 
 763:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
 764:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval The value of the received data.
 765:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 766:.\StdPeriphLib\src/stm32f0xx_spi.c **** uint8_t SPI_ReceiveData8(SPI_TypeDef* SPIx)
 767:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 772              		.loc 1 767 0
 773              		.cfi_startproc
 774              	.LVL71:
 768:.\StdPeriphLib\src/stm32f0xx_spi.c ****   uint32_t spixbase = 0x00;
 769:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
 770:.\StdPeriphLib\src/stm32f0xx_spi.c ****   spixbase = (uint32_t)SPIx; 
 771:.\StdPeriphLib\src/stm32f0xx_spi.c ****   spixbase += 0x0C;
 772:.\StdPeriphLib\src/stm32f0xx_spi.c ****   
 773:.\StdPeriphLib\src/stm32f0xx_spi.c ****   return *(__IO uint8_t *) spixbase;
 775              		.loc 1 773 0
 776 0000 007B     		ldrb	r0, [r0, #12]
 777              	.LVL72:
 778 0002 C0B2     		uxtb	r0, r0
 774:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 779              		.loc 1 774 0
 780              		@ sp needed
 781 0004 7047     		bx	lr
 782              		.cfi_endproc
 783              	.LFE49:
 785 0006 C046     		.section	.text.SPI_I2S_ReceiveData16,"ax",%progbits
 786              		.align	2
 787              		.global	SPI_I2S_ReceiveData16
 788              		.code	16
 789              		.thumb_func
 791              	SPI_I2S_ReceiveData16:
 792              	.LFB50:
 775:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 776:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 777:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Returns the most recent received data by the SPIx peripheral. 
 778:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select
 779:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
 780:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         the SPI peripheral.  
 781:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval The value of the received data.
 782:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 783:.\StdPeriphLib\src/stm32f0xx_spi.c **** uint16_t SPI_I2S_ReceiveData16(SPI_TypeDef* SPIx)
 784:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 793              		.loc 1 784 0
 794              		.cfi_startproc
 795              	.LVL73:
 785:.\StdPeriphLib\src/stm32f0xx_spi.c ****   return SPIx->DR;
 796              		.loc 1 785 0
 797 0000 8089     		ldrh	r0, [r0, #12]
 798              	.LVL74:
 799 0002 80B2     		uxth	r0, r0
 786:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 800              		.loc 1 786 0
 801              		@ sp needed
 802 0004 7047     		bx	lr
 803              		.cfi_endproc
 804              	.LFE50:
 806 0006 C046     		.section	.text.SPI_CRCLengthConfig,"ax",%progbits
 807              		.align	2
 808              		.global	SPI_CRCLengthConfig
 809              		.code	16
 810              		.thumb_func
 812              	SPI_CRCLengthConfig:
 813              	.LFB51:
 787:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 788:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @}
 789:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 790:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 791:.\StdPeriphLib\src/stm32f0xx_spi.c **** /** @defgroup SPI_Group3 Hardware CRC Calculation functions
 792:.\StdPeriphLib\src/stm32f0xx_spi.c ****  *  @brief   Hardware CRC Calculation functions
 793:.\StdPeriphLib\src/stm32f0xx_spi.c ****  *
 794:.\StdPeriphLib\src/stm32f0xx_spi.c **** @verbatim   
 795:.\StdPeriphLib\src/stm32f0xx_spi.c ****  ===============================================================================
 796:.\StdPeriphLib\src/stm32f0xx_spi.c ****                 ##### Hardware CRC Calculation functions #####
 797:.\StdPeriphLib\src/stm32f0xx_spi.c ****  ===============================================================================
 798:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] This section provides a set of functions allowing to manage the SPI CRC hardware 
 799:.\StdPeriphLib\src/stm32f0xx_spi.c ****          calculation.SPI communication using CRC is possible through the following procedure:
 800:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 801:.\StdPeriphLib\src/stm32f0xx_spi.c ****          (#) Program the Data direction, Polarity, Phase, First Data, Baud Rate Prescaler,
 802:.\StdPeriphLib\src/stm32f0xx_spi.c ****              Slave Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
 803:.\StdPeriphLib\src/stm32f0xx_spi.c ****              function.
 804:.\StdPeriphLib\src/stm32f0xx_spi.c ****          (#) Enable the CRC calculation using the SPI_CalculateCRC() function.
 805:.\StdPeriphLib\src/stm32f0xx_spi.c ****          (#) Enable the SPI using the SPI_Cmd() function
 806:.\StdPeriphLib\src/stm32f0xx_spi.c ****          (#) Before writing the last data to the TX buffer, set the CRCNext bit using the 
 807:.\StdPeriphLib\src/stm32f0xx_spi.c ****              SPI_TransmitCRC() function to indicate that after transmission of the last 
 808:.\StdPeriphLib\src/stm32f0xx_spi.c ****              data, the CRC should be transmitted.
 809:.\StdPeriphLib\src/stm32f0xx_spi.c ****          (#) After transmitting the last data, the SPI transmits the CRC. The SPI_CR1_CRCNEXT
 810:.\StdPeriphLib\src/stm32f0xx_spi.c ****              bit is reset. The CRC is also received and compared against the SPI_RXCRCR 
 811:.\StdPeriphLib\src/stm32f0xx_spi.c ****              value. 
 812:.\StdPeriphLib\src/stm32f0xx_spi.c ****              If the value does not match, the SPI_FLAG_CRCERR flag is set and an interrupt
 813:.\StdPeriphLib\src/stm32f0xx_spi.c ****              can be generated when the SPI_I2S_IT_ERR interrupt is enabled.
 814:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 815:.\StdPeriphLib\src/stm32f0xx_spi.c ****     -@-
 816:.\StdPeriphLib\src/stm32f0xx_spi.c ****        (+@) It is advised to don't read the calculate CRC values during the communication.
 817:.\StdPeriphLib\src/stm32f0xx_spi.c ****        (+@) When the SPI is in slave mode, be careful to enable CRC calculation only
 818:.\StdPeriphLib\src/stm32f0xx_spi.c ****        when the clock is stable, that is, when the clock is in the steady state. 
 819:.\StdPeriphLib\src/stm32f0xx_spi.c ****        If not, a wrong CRC calculation may be done. In fact, the CRC is sensitive 
 820:.\StdPeriphLib\src/stm32f0xx_spi.c ****        to the SCK slave input clock as soon as CRCEN is set, and this, whatever 
 821:.\StdPeriphLib\src/stm32f0xx_spi.c ****        the value of the SPE bit.
 822:.\StdPeriphLib\src/stm32f0xx_spi.c ****        (+@) With high bitrate frequencies, be careful when transmitting the CRC.
 823:.\StdPeriphLib\src/stm32f0xx_spi.c ****        As the number of used CPU cycles has to be as low as possible in the CRC 
 824:.\StdPeriphLib\src/stm32f0xx_spi.c ****        transfer phase, it is forbidden to call software functions in the CRC 
 825:.\StdPeriphLib\src/stm32f0xx_spi.c ****        transmission sequence to avoid errors in the last data and CRC reception. 
 826:.\StdPeriphLib\src/stm32f0xx_spi.c ****        In fact, CRCNEXT bit has to be written before the end of the transmission/reception 
 827:.\StdPeriphLib\src/stm32f0xx_spi.c ****        of the last data.
 828:.\StdPeriphLib\src/stm32f0xx_spi.c ****        (+@) For high bit rate frequencies, it is advised to use the DMA mode to avoid the
 829:.\StdPeriphLib\src/stm32f0xx_spi.c ****        degradation of the SPI speed performance due to CPU accesses impacting the 
 830:.\StdPeriphLib\src/stm32f0xx_spi.c ****        SPI bandwidth.
 831:.\StdPeriphLib\src/stm32f0xx_spi.c ****        (+@) When the STM32F0xx are configured as slaves and the NSS hardware mode is 
 832:.\StdPeriphLib\src/stm32f0xx_spi.c ****        used, the NSS pin needs to be kept low between the data phase and the CRC 
 833:.\StdPeriphLib\src/stm32f0xx_spi.c ****        phase.
 834:.\StdPeriphLib\src/stm32f0xx_spi.c ****        (+@) When the SPI is configured in slave mode with the CRC feature enabled, CRC
 835:.\StdPeriphLib\src/stm32f0xx_spi.c ****        calculation takes place even if a high level is applied on the NSS pin. 
 836:.\StdPeriphLib\src/stm32f0xx_spi.c ****        This may happen for example in case of a multislave environment where the 
 837:.\StdPeriphLib\src/stm32f0xx_spi.c ****        communication master addresses slaves alternately.
 838:.\StdPeriphLib\src/stm32f0xx_spi.c ****        (+@) Between a slave deselection (high level on NSS) and a new slave selection
 839:.\StdPeriphLib\src/stm32f0xx_spi.c ****        (low level on NSS), the CRC value should be cleared on both master and slave
 840:.\StdPeriphLib\src/stm32f0xx_spi.c ****        sides in order to resynchronize the master and slave for their respective 
 841:.\StdPeriphLib\src/stm32f0xx_spi.c ****        CRC calculation.
 842:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 843:.\StdPeriphLib\src/stm32f0xx_spi.c ****     -@- To clear the CRC, follow the procedure below:
 844:.\StdPeriphLib\src/stm32f0xx_spi.c ****        (#@) Disable SPI using the SPI_Cmd() function
 845:.\StdPeriphLib\src/stm32f0xx_spi.c ****        (#@) Disable the CRC calculation using the SPI_CalculateCRC() function.
 846:.\StdPeriphLib\src/stm32f0xx_spi.c ****        (#@) Enable the CRC calculation using the SPI_CalculateCRC() function.
 847:.\StdPeriphLib\src/stm32f0xx_spi.c ****        (#@) Enable SPI using the SPI_Cmd() function.
 848:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 849:.\StdPeriphLib\src/stm32f0xx_spi.c **** @endverbatim
 850:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @{
 851:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 852:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 853:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 854:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Configures the CRC calculation length for the selected SPI.
 855:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   This function can be called only after the SPI_Init() function has 
 856:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         been called.  
 857:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
 858:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.  
 859:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPI_CRCLength: specifies the SPI CRC calculation length.
 860:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be one of the following values:
 861:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_CRCLength_8b: Set CRC Calculation to 8 bits
 862:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_CRCLength_16b: Set CRC Calculation to 16 bits
 863:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 864:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 865:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_CRCLengthConfig(SPI_TypeDef* SPIx, uint16_t SPI_CRCLength)
 866:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 814              		.loc 1 866 0
 815              		.cfi_startproc
 816              	.LVL75:
 867:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 868:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 869:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_CRC_LENGTH(SPI_CRCLength));
 870:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 871:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Clear CRCL bit */
 872:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCL);
 817              		.loc 1 872 0
 818 0000 0288     		ldrh	r2, [r0]
 819 0002 034B     		ldr	r3, .L59
 820 0004 1340     		and	r3, r2
 821 0006 0380     		strh	r3, [r0]
 873:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 874:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Set new CRCL bit value */
 875:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->CR1 |= SPI_CRCLength;
 822              		.loc 1 875 0
 823 0008 0388     		ldrh	r3, [r0]
 824 000a 1943     		orr	r1, r3
 825              	.LVL76:
 826 000c 0180     		strh	r1, [r0]
 876:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 827              		.loc 1 876 0
 828              		@ sp needed
 829 000e 7047     		bx	lr
 830              	.L60:
 831              		.align	2
 832              	.L59:
 833 0010 FFF7FFFF 		.word	-2049
 834              		.cfi_endproc
 835              	.LFE51:
 837              		.section	.text.SPI_CalculateCRC,"ax",%progbits
 838              		.align	2
 839              		.global	SPI_CalculateCRC
 840              		.code	16
 841              		.thumb_func
 843              	SPI_CalculateCRC:
 844              	.LFB52:
 877:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 878:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 879:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Enables or disables the CRC value calculation of the transferred bytes.
 880:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   This function can be called only after the SPI_Init() function has 
 881:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         been called.   
 882:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
 883:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
 884:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  NewState: new state of the SPIx CRC value calculation.
 885:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be: ENABLE or DISABLE.
 886:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 887:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 888:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
 889:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 845              		.loc 1 889 0
 846              		.cfi_startproc
 847              	.LVL77:
 890:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 891:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 892:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 893:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 894:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if (NewState != DISABLE)
 848              		.loc 1 894 0
 849 0000 0029     		cmp	r1, #0
 850 0002 05D0     		beq	.L62
 895:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 896:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Enable the selected SPI CRC calculation */
 897:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR1 |= SPI_CR1_CRCEN;
 851              		.loc 1 897 0
 852 0004 0288     		ldrh	r2, [r0]
 853 0006 8023     		mov	r3, #128
 854 0008 9B01     		lsl	r3, r3, #6
 855 000a 1343     		orr	r3, r2
 856 000c 0380     		strh	r3, [r0]
 857 000e 03E0     		b	.L61
 858              	.L62:
 898:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 899:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
 900:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 901:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Disable the selected SPI CRC calculation */
 902:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
 859              		.loc 1 902 0
 860 0010 0288     		ldrh	r2, [r0]
 861 0012 024B     		ldr	r3, .L64
 862 0014 1340     		and	r3, r2
 863 0016 0380     		strh	r3, [r0]
 864              	.L61:
 903:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 904:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 865              		.loc 1 904 0
 866              		@ sp needed
 867 0018 7047     		bx	lr
 868              	.L65:
 869 001a C046     		.align	2
 870              	.L64:
 871 001c FFDFFFFF 		.word	-8193
 872              		.cfi_endproc
 873              	.LFE52:
 875              		.section	.text.SPI_TransmitCRC,"ax",%progbits
 876              		.align	2
 877              		.global	SPI_TransmitCRC
 878              		.code	16
 879              		.thumb_func
 881              	SPI_TransmitCRC:
 882              	.LFB53:
 905:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 906:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 907:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Transmit the SPIx CRC value.
 908:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
 909:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices. 
 910:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 911:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 912:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_TransmitCRC(SPI_TypeDef* SPIx)
 913:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 883              		.loc 1 913 0
 884              		.cfi_startproc
 885              	.LVL78:
 914:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 915:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 916:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 917:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Enable the selected SPI CRC transmission */
 918:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->CR1 |= SPI_CR1_CRCNEXT;
 886              		.loc 1 918 0
 887 0000 0288     		ldrh	r2, [r0]
 888 0002 8023     		mov	r3, #128
 889 0004 5B01     		lsl	r3, r3, #5
 890 0006 1343     		orr	r3, r2
 891 0008 0380     		strh	r3, [r0]
 919:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 892              		.loc 1 919 0
 893              		@ sp needed
 894 000a 7047     		bx	lr
 895              		.cfi_endproc
 896              	.LFE53:
 898              		.section	.text.SPI_GetCRC,"ax",%progbits
 899              		.align	2
 900              		.global	SPI_GetCRC
 901              		.code	16
 902              		.thumb_func
 904              	SPI_GetCRC:
 905              	.LFB54:
 920:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 921:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 922:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
 923:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
 924:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices. 
 925:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPI_CRC: specifies the CRC register to be read.
 926:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be one of the following values:
 927:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_CRC_Tx: Selects Tx CRC register
 928:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_CRC_Rx: Selects Rx CRC register
 929:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval The selected CRC register value..
 930:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 931:.\StdPeriphLib\src/stm32f0xx_spi.c **** uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
 932:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 906              		.loc 1 932 0
 907              		.cfi_startproc
 908              	.LVL79:
 933:.\StdPeriphLib\src/stm32f0xx_spi.c ****   uint16_t crcreg = 0;
 934:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 935:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 936:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_CRC(SPI_CRC));
 937:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 938:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if (SPI_CRC != SPI_CRC_Rx)
 909              		.loc 1 938 0
 910 0000 0129     		cmp	r1, #1
 911 0002 02D0     		beq	.L68
 939:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 940:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Get the Tx CRC register */
 941:.\StdPeriphLib\src/stm32f0xx_spi.c ****     crcreg = SPIx->TXCRCR;
 912              		.loc 1 941 0
 913 0004 008B     		ldrh	r0, [r0, #24]
 914              	.LVL80:
 915 0006 80B2     		uxth	r0, r0
 916              	.LVL81:
 917 0008 01E0     		b	.L69
 918              	.LVL82:
 919              	.L68:
 942:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 943:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
 944:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 945:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Get the Rx CRC register */
 946:.\StdPeriphLib\src/stm32f0xx_spi.c ****     crcreg = SPIx->RXCRCR;
 920              		.loc 1 946 0
 921 000a 808A     		ldrh	r0, [r0, #20]
 922              	.LVL83:
 923 000c 80B2     		uxth	r0, r0
 924              	.LVL84:
 925              	.L69:
 947:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 948:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Return the selected CRC register */
 949:.\StdPeriphLib\src/stm32f0xx_spi.c ****   return crcreg;
 950:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 926              		.loc 1 950 0
 927              		@ sp needed
 928 000e 7047     		bx	lr
 929              		.cfi_endproc
 930              	.LFE54:
 932              		.section	.text.SPI_GetCRCPolynomial,"ax",%progbits
 933              		.align	2
 934              		.global	SPI_GetCRCPolynomial
 935              		.code	16
 936              		.thumb_func
 938              	SPI_GetCRCPolynomial:
 939              	.LFB55:
 951:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 952:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 953:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Returns the CRC Polynomial register value for the specified SPI.
 954:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
 955:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices. 
 956:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval The CRC Polynomial register value.
 957:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 958:.\StdPeriphLib\src/stm32f0xx_spi.c **** uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
 959:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 940              		.loc 1 959 0
 941              		.cfi_startproc
 942              	.LVL85:
 960:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
 961:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
 962:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 963:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Return the CRC polynomial register */
 964:.\StdPeriphLib\src/stm32f0xx_spi.c ****   return SPIx->CRCPR;
 943              		.loc 1 964 0
 944 0000 008A     		ldrh	r0, [r0, #16]
 945              	.LVL86:
 946 0002 80B2     		uxth	r0, r0
 965:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 947              		.loc 1 965 0
 948              		@ sp needed
 949 0004 7047     		bx	lr
 950              		.cfi_endproc
 951              	.LFE55:
 953 0006 C046     		.section	.text.SPI_I2S_DMACmd,"ax",%progbits
 954              		.align	2
 955              		.global	SPI_I2S_DMACmd
 956              		.code	16
 957              		.thumb_func
 959              	SPI_I2S_DMACmd:
 960              	.LFB56:
 966:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 967:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 968:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @}
 969:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 970:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 971:.\StdPeriphLib\src/stm32f0xx_spi.c **** /** @defgroup SPI_Group4 DMA transfers management functions
 972:.\StdPeriphLib\src/stm32f0xx_spi.c ****  *  @brief   DMA transfers management functions
 973:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *
 974:.\StdPeriphLib\src/stm32f0xx_spi.c **** @verbatim   
 975:.\StdPeriphLib\src/stm32f0xx_spi.c ****  ===============================================================================
 976:.\StdPeriphLib\src/stm32f0xx_spi.c ****                 ##### DMA transfers management functions #####
 977:.\StdPeriphLib\src/stm32f0xx_spi.c ****  ===============================================================================
 978:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] This section provides two functions that can be used only in DMA mode.
 979:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 980:.\StdPeriphLib\src/stm32f0xx_spi.c **** @endverbatim
 981:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @{
 982:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 983:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 984:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
 985:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Enables or disables the SPIx/I2Sx DMA interface.
 986:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
 987:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         the SPI peripheral.
 988:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
 989:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         I2S mode is not supported for STM32F030 devices.  
 990:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
 991:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be any combination of the following values:
 992:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
 993:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
 994:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  NewState: new state of the selected SPI DMA transfer request.
 995:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be: ENABLE or DISABLE.
 996:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
 997:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
 998:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
 999:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 961              		.loc 1 999 0
 962              		.cfi_startproc
 963              	.LVL87:
1000:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
1001:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
1002:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1003:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_I2S_DMA_REQ(SPI_I2S_DMAReq));
1004:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1005:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if (NewState != DISABLE)
 964              		.loc 1 1005 0
 965 0000 002A     		cmp	r2, #0
 966 0002 03D0     		beq	.L72
1006:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
1007:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Enable the selected SPI DMA requests */
1008:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR2 |= SPI_I2S_DMAReq;
 967              		.loc 1 1008 0
 968 0004 8388     		ldrh	r3, [r0, #4]
 969 0006 1943     		orr	r1, r3
 970              	.LVL88:
 971 0008 8180     		strh	r1, [r0, #4]
 972 000a 02E0     		b	.L71
 973              	.LVL89:
 974              	.L72:
1009:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
1010:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
1011:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
1012:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Disable the selected SPI DMA requests */
1013:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 975              		.loc 1 1013 0
 976 000c 8388     		ldrh	r3, [r0, #4]
 977 000e 8B43     		bic	r3, r1
 978 0010 8380     		strh	r3, [r0, #4]
 979              	.LVL90:
 980              	.L71:
1014:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
1015:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 981              		.loc 1 1015 0
 982              		@ sp needed
 983 0012 7047     		bx	lr
 984              		.cfi_endproc
 985              	.LFE56:
 987              		.section	.text.SPI_LastDMATransferCmd,"ax",%progbits
 988              		.align	2
 989              		.global	SPI_LastDMATransferCmd
 990              		.code	16
 991              		.thumb_func
 993              	SPI_LastDMATransferCmd:
 994              	.LFB57:
1016:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1017:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
1018:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Configures the number of data to transfer type(Even/Odd) for the DMA
1019:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         last transfers and for the selected SPI.
1020:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   This function have a meaning only if DMA mode is selected and if 
1021:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         the packing mode is used (data length <= 8 and DMA transfer size halfword)  
1022:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
1023:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
1024:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPI_LastDMATransfer: specifies the SPI last DMA transfers state.
1025:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be one of the following values:
1026:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_LastDMATransfer_TxEvenRxEven: Number of data for transmission Even
1027:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *                                                   and number of data for reception Even.
1028:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_LastDMATransfer_TxOddRxEven: Number of data for transmission Odd
1029:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *                                                  and number of data for reception Even.
1030:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_LastDMATransfer_TxEvenRxOdd: Number of data for transmission Even
1031:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *                                                  and number of data for reception Odd.
1032:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_LastDMATransfer_TxOddRxOdd: Number of data for transmission Odd
1033:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *                                                 and number of data for reception Odd.
1034:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
1035:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
1036:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_LastDMATransferCmd(SPI_TypeDef* SPIx, uint16_t SPI_LastDMATransfer)
1037:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 995              		.loc 1 1037 0
 996              		.cfi_startproc
 997              	.LVL91:
1038:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
1039:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
1040:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_LAST_DMA_TRANSFER(SPI_LastDMATransfer));
1041:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1042:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Clear LDMA_TX and LDMA_RX bits */
1043:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->CR2 &= CR2_LDMA_MASK;
 998              		.loc 1 1043 0
 999 0000 8288     		ldrh	r2, [r0, #4]
 1000 0002 034B     		ldr	r3, .L75
 1001 0004 1340     		and	r3, r2
 1002 0006 8380     		strh	r3, [r0, #4]
1044:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1045:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Set new LDMA_TX and LDMA_RX bits value */
1046:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->CR2 |= SPI_LastDMATransfer; 
 1003              		.loc 1 1046 0
 1004 0008 8388     		ldrh	r3, [r0, #4]
 1005 000a 1943     		orr	r1, r3
 1006              	.LVL92:
 1007 000c 8180     		strh	r1, [r0, #4]
1047:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 1008              		.loc 1 1047 0
 1009              		@ sp needed
 1010 000e 7047     		bx	lr
 1011              	.L76:
 1012              		.align	2
 1013              	.L75:
 1014 0010 FF9FFFFF 		.word	-24577
 1015              		.cfi_endproc
 1016              	.LFE57:
 1018              		.section	.text.SPI_I2S_ITConfig,"ax",%progbits
 1019              		.align	2
 1020              		.global	SPI_I2S_ITConfig
 1021              		.code	16
 1022              		.thumb_func
 1024              	SPI_I2S_ITConfig:
 1025              	.LFB58:
1048:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1049:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
1050:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @}
1051:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
1052:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1053:.\StdPeriphLib\src/stm32f0xx_spi.c **** /** @defgroup SPI_Group5 Interrupts and flags management functions
1054:.\StdPeriphLib\src/stm32f0xx_spi.c ****  *  @brief   Interrupts and flags management functions
1055:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *
1056:.\StdPeriphLib\src/stm32f0xx_spi.c **** @verbatim   
1057:.\StdPeriphLib\src/stm32f0xx_spi.c ****  ===============================================================================
1058:.\StdPeriphLib\src/stm32f0xx_spi.c ****              ##### Interrupts and flags management functions #####
1059:.\StdPeriphLib\src/stm32f0xx_spi.c ****  ===============================================================================
1060:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] This section provides a set of functions allowing to configure the SPI/I2S Interrupts 
1061:.\StdPeriphLib\src/stm32f0xx_spi.c ****          sources and check or clear the flags or pending bits status.
1062:.\StdPeriphLib\src/stm32f0xx_spi.c ****          The user should identify which mode will be used in his application to manage 
1063:.\StdPeriphLib\src/stm32f0xx_spi.c ****          the communication: Polling mode, Interrupt mode or DMA mode. 
1064:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1065:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *** Polling Mode ***
1066:.\StdPeriphLib\src/stm32f0xx_spi.c ****   ====================
1067:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] In Polling Mode, the SPI/I2S communication can be managed by 9 flags:
1068:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_I2S_FLAG_TXE : to indicate the status of the transmit buffer register
1069:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_I2S_FLAG_RXNE : to indicate the status of the receive buffer register
1070:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_I2S_FLAG_BSY : to indicate the state of the communication layer of the SPI.
1071:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_FLAG_CRCERR : to indicate if a CRC Calculation error occur              
1072:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_FLAG_MODF : to indicate if a Mode Fault error occur
1073:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_I2S_FLAG_OVR : to indicate if an Overrun error occur
1074:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_I2S_FLAG_FRE: to indicate a Frame Format error occurs.
1075:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) I2S_FLAG_UDR: to indicate an Underrun error occurs.
1076:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) I2S_FLAG_CHSIDE: to indicate Channel Side.
1077:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1078:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..]
1079:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (@)Do not use the BSY flag to handle each data transmission or reception. It is better 
1080:.\StdPeriphLib\src/stm32f0xx_spi.c ****            to use the TXE and RXNE flags instead.
1081:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1082:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] In this Mode it is advised to use the following functions:
1083:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (+) FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
1084:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (+) void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
1085:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1086:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *** Interrupt Mode ***
1087:.\StdPeriphLib\src/stm32f0xx_spi.c ****   ======================
1088:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] In Interrupt Mode, the SPI/I2S communication can be managed by 3 interrupt sources
1089:.\StdPeriphLib\src/stm32f0xx_spi.c ****          and 5 pending bits: 
1090:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] Pending Bits:
1091:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_I2S_IT_TXE : to indicate the status of the transmit buffer register
1092:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_I2S_IT_RXNE : to indicate the status of the receive buffer register
1093:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_I2S_IT_OVR : to indicate if an Overrun error occur
1094:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) I2S_IT_UDR : to indicate an Underrun Error occurs.
1095:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_I2S_FLAG_FRE : to indicate a Frame Format error occurs.
1096:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1097:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] Interrupt Source:
1098:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_I2S_IT_TXE: specifies the interrupt source for the Tx buffer empty 
1099:.\StdPeriphLib\src/stm32f0xx_spi.c ****             interrupt.  
1100:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_I2S_IT_RXNE : specifies the interrupt source for the Rx buffer not 
1101:.\StdPeriphLib\src/stm32f0xx_spi.c ****             empty interrupt.
1102:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_I2S_IT_ERR : specifies the interrupt source for the errors interrupt.
1103:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1104:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] In this Mode it is advised to use the following functions:
1105:.\StdPeriphLib\src/stm32f0xx_spi.c ****          (+) void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
1106:.\StdPeriphLib\src/stm32f0xx_spi.c ****          (+) ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
1107:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1108:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *** FIFO Status ***
1109:.\StdPeriphLib\src/stm32f0xx_spi.c ****   ===================
1110:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] It is possible to monitor the FIFO status when a transfer is ongoing using the
1111:.\StdPeriphLib\src/stm32f0xx_spi.c ****          following function:
1112:.\StdPeriphLib\src/stm32f0xx_spi.c ****          (+) uint32_t SPI_GetFIFOStatus(uint8_t SPI_FIFO_Direction); 
1113:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1114:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *** DMA Mode ***
1115:.\StdPeriphLib\src/stm32f0xx_spi.c ****   ================
1116:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] In DMA Mode, the SPI communication can be managed by 2 DMA Channel 
1117:.\StdPeriphLib\src/stm32f0xx_spi.c ****          requests:
1118:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_I2S_DMAReq_Tx: specifies the Tx buffer DMA transfer request.
1119:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (#) SPI_I2S_DMAReq_Rx: specifies the Rx buffer DMA transfer request.
1120:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1121:.\StdPeriphLib\src/stm32f0xx_spi.c ****     [..] In this Mode it is advised to use the following function:
1122:.\StdPeriphLib\src/stm32f0xx_spi.c ****         (+) void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewStat
1123:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1124:.\StdPeriphLib\src/stm32f0xx_spi.c **** @endverbatim
1125:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @{
1126:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
1127:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1128:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
1129:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Enables or disables the specified SPI/I2S interrupts.
1130:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
1131:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         the SPI peripheral.  
1132:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
1133:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         I2S mode is not supported for STM32F030 devices.  
1134:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPI_I2S_IT: specifies the SPI interrupt source to be enabled or disabled. 
1135:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be one of the following values:
1136:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
1137:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
1138:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_I2S_IT_ERR: Error interrupt mask
1139:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  NewState: new state of the specified SPI interrupt.
1140:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be: ENABLE or DISABLE.
1141:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
1142:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
1143:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
1144:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 1026              		.loc 1 1144 0
 1027              		.cfi_startproc
 1028              	.LVL93:
1145:.\StdPeriphLib\src/stm32f0xx_spi.c ****   uint16_t itpos = 0, itmask = 0 ;
1146:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1147:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
1148:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
1149:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1150:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
1151:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1152:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Get the SPI IT index */
1153:.\StdPeriphLib\src/stm32f0xx_spi.c ****   itpos = SPI_I2S_IT >> 4;
1154:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1155:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Set the IT mask */
1156:.\StdPeriphLib\src/stm32f0xx_spi.c ****   itmask = (uint16_t)1 << (uint16_t)itpos;
 1029              		.loc 1 1156 0
 1030 0000 0909     		lsr	r1, r1, #4
 1031              	.LVL94:
 1032 0002 0123     		mov	r3, #1
 1033 0004 8B40     		lsl	r3, r3, r1
 1034 0006 99B2     		uxth	r1, r3
 1035              	.LVL95:
1157:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1158:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if (NewState != DISABLE)
 1036              		.loc 1 1158 0
 1037 0008 002A     		cmp	r2, #0
 1038 000a 03D0     		beq	.L78
1159:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
1160:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Enable the selected SPI interrupt */
1161:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR2 |= itmask;
 1039              		.loc 1 1161 0
 1040 000c 8388     		ldrh	r3, [r0, #4]
 1041 000e 1943     		orr	r1, r3
 1042              	.LVL96:
 1043 0010 8180     		strh	r1, [r0, #4]
 1044 0012 02E0     		b	.L77
 1045              	.LVL97:
 1046              	.L78:
1162:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
1163:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
1164:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
1165:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* Disable the selected SPI interrupt */
1166:.\StdPeriphLib\src/stm32f0xx_spi.c ****     SPIx->CR2 &= (uint16_t)~itmask;
 1047              		.loc 1 1166 0
 1048 0014 8388     		ldrh	r3, [r0, #4]
 1049 0016 8B43     		bic	r3, r1
 1050 0018 8380     		strh	r3, [r0, #4]
 1051              	.LVL98:
 1052              	.L77:
1167:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
1168:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 1053              		.loc 1 1168 0
 1054              		@ sp needed
 1055 001a 7047     		bx	lr
 1056              		.cfi_endproc
 1057              	.LFE58:
 1059              		.section	.text.SPI_GetTransmissionFIFOStatus,"ax",%progbits
 1060              		.align	2
 1061              		.global	SPI_GetTransmissionFIFOStatus
 1062              		.code	16
 1063              		.thumb_func
 1065              	SPI_GetTransmissionFIFOStatus:
 1066              	.LFB59:
1169:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1170:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
1171:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Returns the current SPIx Transmission FIFO filled level.
1172:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
1173:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
1174:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval The Transmission FIFO filling state.
1175:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          - SPI_TransmissionFIFOStatus_Empty: when FIFO is empty
1176:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          - SPI_TransmissionFIFOStatus_1QuarterFull: if more than 1 quarter-full.
1177:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          - SPI_TransmissionFIFOStatus_HalfFull: if more than 1 half-full.
1178:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          - SPI_TransmissionFIFOStatus_Full: when FIFO is full.
1179:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
1180:.\StdPeriphLib\src/stm32f0xx_spi.c **** uint16_t SPI_GetTransmissionFIFOStatus(SPI_TypeDef* SPIx)
1181:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 1067              		.loc 1 1181 0
 1068              		.cfi_startproc
 1069              	.LVL99:
1182:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Get the SPIx Transmission FIFO level bits */
1183:.\StdPeriphLib\src/stm32f0xx_spi.c ****   return (uint16_t)((SPIx->SR & SPI_SR_FTLVL));
 1070              		.loc 1 1183 0
 1071 0000 0089     		ldrh	r0, [r0, #8]
 1072              	.LVL100:
 1073 0002 C023     		mov	r3, #192
 1074 0004 5B01     		lsl	r3, r3, #5
 1075 0006 1840     		and	r0, r3
1184:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 1076              		.loc 1 1184 0
 1077              		@ sp needed
 1078 0008 7047     		bx	lr
 1079              		.cfi_endproc
 1080              	.LFE59:
 1082 000a C046     		.section	.text.SPI_GetReceptionFIFOStatus,"ax",%progbits
 1083              		.align	2
 1084              		.global	SPI_GetReceptionFIFOStatus
 1085              		.code	16
 1086              		.thumb_func
 1088              	SPI_GetReceptionFIFOStatus:
 1089              	.LFB60:
1185:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1186:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
1187:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Returns the current SPIx Reception FIFO filled level.
1188:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
1189:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
1190:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval The Reception FIFO filling state.
1191:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          - SPI_ReceptionFIFOStatus_Empty: when FIFO is empty
1192:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          - SPI_ReceptionFIFOStatus_1QuarterFull: if more than 1 quarter-full.
1193:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          - SPI_ReceptionFIFOStatus_HalfFull: if more than 1 half-full.
1194:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          - SPI_ReceptionFIFOStatus_Full: when FIFO is full.
1195:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
1196:.\StdPeriphLib\src/stm32f0xx_spi.c **** uint16_t SPI_GetReceptionFIFOStatus(SPI_TypeDef* SPIx)
1197:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 1090              		.loc 1 1197 0
 1091              		.cfi_startproc
 1092              	.LVL101:
1198:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Get the SPIx Reception FIFO level bits */
1199:.\StdPeriphLib\src/stm32f0xx_spi.c ****   return (uint16_t)((SPIx->SR & SPI_SR_FRLVL));
 1093              		.loc 1 1199 0
 1094 0000 0089     		ldrh	r0, [r0, #8]
 1095              	.LVL102:
 1096 0002 C023     		mov	r3, #192
 1097 0004 DB00     		lsl	r3, r3, #3
 1098 0006 1840     		and	r0, r3
1200:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 1099              		.loc 1 1200 0
 1100              		@ sp needed
 1101 0008 7047     		bx	lr
 1102              		.cfi_endproc
 1103              	.LFE60:
 1105 000a C046     		.section	.text.SPI_I2S_GetFlagStatus,"ax",%progbits
 1106              		.align	2
 1107              		.global	SPI_I2S_GetFlagStatus
 1108              		.code	16
 1109              		.thumb_func
 1111              	SPI_I2S_GetFlagStatus:
 1112              	.LFB61:
1201:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1202:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
1203:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Checks whether the specified SPI flag is set or not.
1204:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
1205:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         the SPI peripheral.    
1206:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
1207:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         I2S mode is not supported for STM32F030 devices.  
1208:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPI_I2S_FLAG: specifies the SPI flag to check. 
1209:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be one of the following values:
1210:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
1211:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
1212:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_I2S_FLAG_BSY: Busy flag.
1213:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_I2S_FLAG_OVR: Overrun flag.
1214:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_FLAG_MODF: Mode Fault flag.
1215:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_FLAG_CRCERR: CRC Error flag.
1216:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_I2S_FLAG_FRE: TI frame format error flag.
1217:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg I2S_FLAG_UDR: Underrun Error flag.
1218:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg I2S_FLAG_CHSIDE: Channel Side flag.   
1219:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval The new state of SPI_I2S_FLAG (SET or RESET).
1220:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
1221:.\StdPeriphLib\src/stm32f0xx_spi.c **** FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
1222:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 1113              		.loc 1 1222 0
 1114              		.cfi_startproc
 1115              	.LVL103:
1223:.\StdPeriphLib\src/stm32f0xx_spi.c ****   FlagStatus bitstatus = RESET;
1224:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
1225:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
1226:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
1227:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1228:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the status of the specified SPI flag */
1229:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 1116              		.loc 1 1229 0
 1117 0000 0089     		ldrh	r0, [r0, #8]
 1118              	.LVL104:
 1119 0002 0840     		and	r0, r1
 1120              	.LVL105:
 1121 0004 411E     		sub	r1, r0, #1
 1122 0006 8841     		sbc	r0, r0, r1
 1123              	.LVL106:
1230:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
1231:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* SPI_I2S_FLAG is set */
1232:.\StdPeriphLib\src/stm32f0xx_spi.c ****     bitstatus = SET;
1233:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
1234:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
1235:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
1236:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* SPI_I2S_FLAG is reset */
1237:.\StdPeriphLib\src/stm32f0xx_spi.c ****     bitstatus = RESET;
1238:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
1239:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Return the SPI_I2S_FLAG status */
1240:.\StdPeriphLib\src/stm32f0xx_spi.c ****   return  bitstatus;
 1124              		.loc 1 1240 0
 1125 0008 C0B2     		uxtb	r0, r0
1241:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 1126              		.loc 1 1241 0
 1127              		@ sp needed
 1128 000a 7047     		bx	lr
 1129              		.cfi_endproc
 1130              	.LFE61:
 1132              		.section	.text.SPI_I2S_ClearFlag,"ax",%progbits
 1133              		.align	2
 1134              		.global	SPI_I2S_ClearFlag
 1135              		.code	16
 1136              		.thumb_func
 1138              	SPI_I2S_ClearFlag:
 1139              	.LFB62:
1242:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1243:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
1244:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Clears the SPIx CRC Error (CRCERR) flag.
1245:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
1246:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   SPI2 is not available for STM32F031 devices.
1247:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         I2S mode is not supported for STM32F030 devices.  
1248:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. 
1249:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         This function clears only CRCERR flag.
1250:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   OVR (OverRun error) flag is cleared by software sequence: a read 
1251:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by  
1252:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         a read operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
1253:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @note   MODF (Mode Fault) flag is cleared by software sequence: a read/write 
1254:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by
1255:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         a write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
1256:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval None
1257:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
1258:.\StdPeriphLib\src/stm32f0xx_spi.c **** void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
1259:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 1140              		.loc 1 1259 0
 1141              		.cfi_startproc
 1142              	.LVL107:
1260:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
1261:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
1262:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_CLEAR_FLAG(SPI_I2S_FLAG));
1263:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1264:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Clear the selected SPI CRC Error (CRCERR) flag */
1265:.\StdPeriphLib\src/stm32f0xx_spi.c ****   SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
 1143              		.loc 1 1265 0
 1144 0000 C943     		mvn	r1, r1
 1145              	.LVL108:
 1146 0002 89B2     		uxth	r1, r1
 1147 0004 0181     		strh	r1, [r0, #8]
1266:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 1148              		.loc 1 1266 0
 1149              		@ sp needed
 1150 0006 7047     		bx	lr
 1151              		.cfi_endproc
 1152              	.LFE62:
 1154              		.section	.text.SPI_I2S_GetITStatus,"ax",%progbits
 1155              		.align	2
 1156              		.global	SPI_I2S_GetITStatus
 1157              		.code	16
 1158              		.thumb_func
 1160              	SPI_I2S_GetITStatus:
 1161              	.LFB63:
1267:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1268:.\StdPeriphLib\src/stm32f0xx_spi.c **** /**
1269:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @brief  Checks whether the specified SPI/I2S interrupt has occurred or not.
1270:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
1271:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *         the SPI peripheral.
1272:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @param  SPI_I2S_IT: specifies the SPI interrupt source to check. 
1273:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *          This parameter can be one of the following values:
1274:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
1275:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
1276:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_IT_MODF: Mode Fault interrupt.
1277:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_I2S_IT_OVR: Overrun interrupt.
1278:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg I2S_IT_UDR: Underrun interrupt.  
1279:.\StdPeriphLib\src/stm32f0xx_spi.c ****   *            @arg SPI_I2S_IT_FRE: Format Error interrupt.  
1280:.\StdPeriphLib\src/stm32f0xx_spi.c ****   * @retval The new state of SPI_I2S_IT (SET or RESET).
1281:.\StdPeriphLib\src/stm32f0xx_spi.c ****   */
1282:.\StdPeriphLib\src/stm32f0xx_spi.c **** ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
1283:.\StdPeriphLib\src/stm32f0xx_spi.c **** {
 1162              		.loc 1 1283 0
 1163              		.cfi_startproc
 1164              	.LVL109:
 1165 0000 10B5     		push	{r4, lr}
 1166              	.LCFI4:
 1167              		.cfi_def_cfa_offset 8
 1168              		.cfi_offset 4, -8
 1169              		.cfi_offset 14, -4
 1170              	.LVL110:
1284:.\StdPeriphLib\src/stm32f0xx_spi.c ****   ITStatus bitstatus = RESET;
1285:.\StdPeriphLib\src/stm32f0xx_spi.c ****   uint16_t itpos = 0, itmask = 0, enablestatus = 0;
1286:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1287:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the parameters */
1288:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_ALL_PERIPH(SPIx));
1289:.\StdPeriphLib\src/stm32f0xx_spi.c ****   assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
1290:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1291:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Get the SPI_I2S_IT index */
1292:.\StdPeriphLib\src/stm32f0xx_spi.c ****   itpos = 0x01 << (SPI_I2S_IT & 0x0F);
1293:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1294:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Get the SPI_I2S_IT IT mask */
1295:.\StdPeriphLib\src/stm32f0xx_spi.c ****   itmask = SPI_I2S_IT >> 4;
1296:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1297:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Set the IT mask */
1298:.\StdPeriphLib\src/stm32f0xx_spi.c ****   itmask = 0x01 << itmask;
1299:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1300:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Get the SPI_I2S_IT enable bit status */
1301:.\StdPeriphLib\src/stm32f0xx_spi.c ****   enablestatus = (SPIx->CR2 & itmask) ;
 1171              		.loc 1 1301 0
 1172 0002 8388     		ldrh	r3, [r0, #4]
 1173 0004 9BB2     		uxth	r3, r3
 1174              	.LVL111:
1302:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
1303:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Check the status of the specified SPI interrupt */
1304:.\StdPeriphLib\src/stm32f0xx_spi.c ****   if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 1175              		.loc 1 1304 0
 1176 0006 0489     		ldrh	r4, [r0, #8]
1292:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 1177              		.loc 1 1292 0
 1178 0008 0F22     		mov	r2, #15
 1179 000a 0A40     		and	r2, r1
 1180 000c 0120     		mov	r0, #1
 1181              	.LVL112:
 1182 000e 9040     		lsl	r0, r0, r2
 1183 0010 021C     		mov	r2, r0
1305:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
1306:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* SPI_I2S_IT is set */
1307:.\StdPeriphLib\src/stm32f0xx_spi.c ****     bitstatus = SET;
1308:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
1309:.\StdPeriphLib\src/stm32f0xx_spi.c ****   else
1310:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
1311:.\StdPeriphLib\src/stm32f0xx_spi.c ****     /* SPI_I2S_IT is reset */
1312:.\StdPeriphLib\src/stm32f0xx_spi.c ****     bitstatus = RESET;
 1184              		.loc 1 1312 0
 1185 0012 0020     		mov	r0, #0
1304:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 1186              		.loc 1 1304 0
 1187 0014 1442     		tst	r4, r2
 1188 0016 06D0     		beq	.L85
1298:.\StdPeriphLib\src/stm32f0xx_spi.c **** 
 1189              		.loc 1 1298 0 discriminator 1
 1190 0018 0909     		lsr	r1, r1, #4
 1191              	.LVL113:
 1192 001a 0130     		add	r0, r0, #1
 1193 001c 8840     		lsl	r0, r0, r1
1304:.\StdPeriphLib\src/stm32f0xx_spi.c ****   {
 1194              		.loc 1 1304 0 discriminator 1
 1195 001e 0340     		and	r3, r0
 1196              	.LVL114:
 1197 0020 581E     		sub	r0, r3, #1
 1198 0022 8341     		sbc	r3, r3, r0
1307:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
 1199              		.loc 1 1307 0 discriminator 1
 1200 0024 D8B2     		uxtb	r0, r3
 1201              	.L85:
 1202              	.LVL115:
1313:.\StdPeriphLib\src/stm32f0xx_spi.c ****   }
1314:.\StdPeriphLib\src/stm32f0xx_spi.c ****   /* Return the SPI_I2S_IT status */
1315:.\StdPeriphLib\src/stm32f0xx_spi.c ****   return bitstatus;
1316:.\StdPeriphLib\src/stm32f0xx_spi.c **** }
 1203              		.loc 1 1316 0
 1204              		@ sp needed
 1205 0026 10BD     		pop	{r4, pc}
 1206              		.cfi_endproc
 1207              	.LFE63:
 1209              		.text
 1210              	.Letext0:
 1211              		.file 2 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 1212              		.file 3 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 1213              		.file 4 ".\\CMSIS/stm32f0xx.h"
 1214              		.file 5 ".\\StdPeriphLib\\inc/stm32f0xx_rcc.h"
 1215              		.file 6 ".\\StdPeriphLib\\inc/stm32f0xx_spi.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f0xx_spi.c
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:18     .text.SPI_I2S_DeInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:23     .text.SPI_I2S_DeInit:00000000 SPI_I2S_DeInit
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:78     .text.SPI_I2S_DeInit:0000003c $d
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:84     .text.SPI_StructInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:89     .text.SPI_StructInit:00000000 SPI_StructInit
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:123    .text.SPI_Init:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:128    .text.SPI_Init:00000000 SPI_Init
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:207    .text.SPI_Init:0000004c $d
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:213    .text.I2S_StructInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:218    .text.I2S_StructInit:00000000 I2S_StructInit
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:245    .text.I2S_Init:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:250    .text.I2S_Init:00000000 I2S_Init
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:410    .text.I2S_Init:000000b0 $d
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:415    .text.SPI_Cmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:420    .text.SPI_Cmd:00000000 SPI_Cmd
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:448    .text.SPI_TIModeCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:453    .text.SPI_TIModeCmd:00000000 SPI_TIModeCmd
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:481    .text.I2S_Cmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:486    .text.I2S_Cmd:00000000 I2S_Cmd
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:514    .text.I2S_Cmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:519    .text.SPI_DataSizeConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:524    .text.SPI_DataSizeConfig:00000000 SPI_DataSizeConfig
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:547    .text.SPI_DataSizeConfig:0000000c $d
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:552    .text.SPI_RxFIFOThresholdConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:557    .text.SPI_RxFIFOThresholdConfig:00000000 SPI_RxFIFOThresholdConfig
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:578    .text.SPI_RxFIFOThresholdConfig:00000010 $d
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:583    .text.SPI_BiDirectionalLineConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:588    .text.SPI_BiDirectionalLineConfig:00000000 SPI_BiDirectionalLineConfig
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:616    .text.SPI_BiDirectionalLineConfig:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:621    .text.SPI_NSSInternalSoftwareConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:626    .text.SPI_NSSInternalSoftwareConfig:00000000 SPI_NSSInternalSoftwareConfig
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:655    .text.SPI_NSSInternalSoftwareConfig:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:661    .text.SPI_SSOutputCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:666    .text.SPI_SSOutputCmd:00000000 SPI_SSOutputCmd
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:694    .text.SPI_NSSPulseModeCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:699    .text.SPI_NSSPulseModeCmd:00000000 SPI_NSSPulseModeCmd
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:727    .text.SPI_SendData8:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:732    .text.SPI_SendData8:00000000 SPI_SendData8
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:746    .text.SPI_I2S_SendData16:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:751    .text.SPI_I2S_SendData16:00000000 SPI_I2S_SendData16
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:765    .text.SPI_ReceiveData8:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:770    .text.SPI_ReceiveData8:00000000 SPI_ReceiveData8
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:786    .text.SPI_I2S_ReceiveData16:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:791    .text.SPI_I2S_ReceiveData16:00000000 SPI_I2S_ReceiveData16
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:807    .text.SPI_CRCLengthConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:812    .text.SPI_CRCLengthConfig:00000000 SPI_CRCLengthConfig
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:833    .text.SPI_CRCLengthConfig:00000010 $d
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:838    .text.SPI_CalculateCRC:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:843    .text.SPI_CalculateCRC:00000000 SPI_CalculateCRC
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:871    .text.SPI_CalculateCRC:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:876    .text.SPI_TransmitCRC:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:881    .text.SPI_TransmitCRC:00000000 SPI_TransmitCRC
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:899    .text.SPI_GetCRC:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:904    .text.SPI_GetCRC:00000000 SPI_GetCRC
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:933    .text.SPI_GetCRCPolynomial:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:938    .text.SPI_GetCRCPolynomial:00000000 SPI_GetCRCPolynomial
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:954    .text.SPI_I2S_DMACmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:959    .text.SPI_I2S_DMACmd:00000000 SPI_I2S_DMACmd
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:988    .text.SPI_LastDMATransferCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:993    .text.SPI_LastDMATransferCmd:00000000 SPI_LastDMATransferCmd
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:1014   .text.SPI_LastDMATransferCmd:00000010 $d
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:1019   .text.SPI_I2S_ITConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:1024   .text.SPI_I2S_ITConfig:00000000 SPI_I2S_ITConfig
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:1060   .text.SPI_GetTransmissionFIFOStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:1065   .text.SPI_GetTransmissionFIFOStatus:00000000 SPI_GetTransmissionFIFOStatus
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:1083   .text.SPI_GetReceptionFIFOStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:1088   .text.SPI_GetReceptionFIFOStatus:00000000 SPI_GetReceptionFIFOStatus
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:1106   .text.SPI_I2S_GetFlagStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:1111   .text.SPI_I2S_GetFlagStatus:00000000 SPI_I2S_GetFlagStatus
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:1133   .text.SPI_I2S_ClearFlag:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:1138   .text.SPI_I2S_ClearFlag:00000000 SPI_I2S_ClearFlag
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:1155   .text.SPI_I2S_GetITStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cc3xTMpP.s:1160   .text.SPI_I2S_GetITStatus:00000000 SPI_I2S_GetITStatus
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
RCC_APB2PeriphResetCmd
RCC_APB1PeriphResetCmd
__aeabi_uidiv
RCC_GetClocksFreq
