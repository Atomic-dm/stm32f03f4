   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"stm32f0xx_pwr.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.PWR_DeInit,"ax",%progbits
  18              		.align	2
  19              		.global	PWR_DeInit
  20              		.code	16
  21              		.thumb_func
  23              	PWR_DeInit:
  24              	.LFB33:
  25              		.file 1 ".\\StdPeriphLib\\src/stm32f0xx_pwr.c"
   1:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
   2:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ******************************************************************************
   3:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @file    stm32f0xx_pwr.c
   4:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @author  MCD Application Team
   5:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @version V1.5.0
   6:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @date    05-December-2014
   7:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @brief   This file provides firmware functions to manage the following 
   8:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *          functionalities of the Power Controller (PWR) peripheral:
   9:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *           + Backup Domain Access
  10:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *           + PVD configuration
  11:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *           + WakeUp pins configuration
  12:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *           + Low Power modes configuration
  13:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *           + Flags management
  14:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *
  15:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ******************************************************************************
  16:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @attention
  17:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *
  18:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  19:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *
  20:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  21:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * You may not use this file except in compliance with the License.
  22:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * You may obtain a copy of the License at:
  23:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *
  24:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  25:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *
  26:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * Unless required by applicable law or agreed to in writing, software 
  27:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  28:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  29:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * See the License for the specific language governing permissions and
  30:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * limitations under the License.
  31:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *
  32:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ******************************************************************************
  33:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
  34:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
  35:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /* Includes ------------------------------------------------------------------*/
  36:.\StdPeriphLib\src/stm32f0xx_pwr.c **** #include "stm32f0xx_pwr.h"
  37:.\StdPeriphLib\src/stm32f0xx_pwr.c **** #include "stm32f0xx_rcc.h"
  38:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
  39:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /** @addtogroup STM32F0xx_StdPeriph_Driver
  40:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @{
  41:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
  42:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
  43:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /** @defgroup PWR 
  44:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @brief PWR driver modules
  45:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @{
  46:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */ 
  47:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
  48:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  49:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /* Private define ------------------------------------------------------------*/
  50:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
  51:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /* ------------------ PWR registers bit mask ------------------------ */
  52:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
  53:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /* CR register bit mask */
  54:.\StdPeriphLib\src/stm32f0xx_pwr.c **** #define CR_DS_MASK               ((uint32_t)0xFFFFFFFC)
  55:.\StdPeriphLib\src/stm32f0xx_pwr.c **** #define CR_PLS_MASK              ((uint32_t)0xFFFFFF1F)
  56:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
  57:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /* Private macro -------------------------------------------------------------*/
  58:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /* Private variables ---------------------------------------------------------*/
  59:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /* Private function prototypes -----------------------------------------------*/
  60:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /* Private functions ---------------------------------------------------------*/
  61:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
  62:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /** @defgroup PWR_Private_Functions
  63:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @{
  64:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
  65:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
  66:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /** @defgroup PWR_Group1 Backup Domain Access function 
  67:.\StdPeriphLib\src/stm32f0xx_pwr.c ****  *  @brief   Backup Domain Access function
  68:.\StdPeriphLib\src/stm32f0xx_pwr.c ****  *
  69:.\StdPeriphLib\src/stm32f0xx_pwr.c **** @verbatim
  70:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ==============================================================================
  71:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                    ##### Backup Domain Access function #####
  72:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ==============================================================================
  73:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
  74:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     [..] After reset, the Backup Domain Registers (RCC BDCR Register, RTC registers
  75:.\StdPeriphLib\src/stm32f0xx_pwr.c ****          and RTC backup registers) are protected against possible stray write accesses.
  76:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     [..] To enable access to Backup domain use the PWR_BackupAccessCmd(ENABLE) function.
  77:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
  78:.\StdPeriphLib\src/stm32f0xx_pwr.c **** @endverbatim
  79:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @{
  80:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
  81:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
  82:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
  83:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @brief  Deinitializes the PWR peripheral registers to their default reset values.
  84:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @param  None
  85:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @retval None
  86:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
  87:.\StdPeriphLib\src/stm32f0xx_pwr.c **** void PWR_DeInit(void)
  88:.\StdPeriphLib\src/stm32f0xx_pwr.c **** {
  26              		.loc 1 88 0
  27              		.cfi_startproc
  28 0000 10B5     		push	{r4, lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 4, -8
  32              		.cfi_offset 14, -4
  89:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
  33              		.loc 1 89 0
  34 0002 8024     		mov	r4, #128
  35 0004 6405     		lsl	r4, r4, #21
  36 0006 201C     		mov	r0, r4
  37 0008 0121     		mov	r1, #1
  38 000a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  39              	.LVL0:
  90:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
  40              		.loc 1 90 0
  41 000e 201C     		mov	r0, r4
  42 0010 0021     		mov	r1, #0
  43 0012 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  44              	.LVL1:
  91:.\StdPeriphLib\src/stm32f0xx_pwr.c **** }
  45              		.loc 1 91 0
  46              		@ sp needed
  47 0016 10BD     		pop	{r4, pc}
  48              		.cfi_endproc
  49              	.LFE33:
  51              		.section	.text.PWR_BackupAccessCmd,"ax",%progbits
  52              		.align	2
  53              		.global	PWR_BackupAccessCmd
  54              		.code	16
  55              		.thumb_func
  57              	PWR_BackupAccessCmd:
  58              	.LFB34:
  92:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
  93:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
  94:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @brief  Enables or disables access to the Backup domain registers.
  95:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @note   If the HSE divided by 32 is used as the RTC clock, the 
  96:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *         Backup Domain Access should be kept enabled.
  97:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @param  NewState: new state of the access to the Backup domain registers.
  98:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
  99:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @retval None
 100:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 101:.\StdPeriphLib\src/stm32f0xx_pwr.c **** void PWR_BackupAccessCmd(FunctionalState NewState)
 102:.\StdPeriphLib\src/stm32f0xx_pwr.c **** {
  59              		.loc 1 102 0
  60              		.cfi_startproc
  61              	.LVL2:
 103:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Check the parameters */
 104:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 105:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   
 106:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   if (NewState != DISABLE)
  62              		.loc 1 106 0
  63 0000 0028     		cmp	r0, #0
  64 0002 06D0     		beq	.L3
 107:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   {
 108:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     /* Enable the Backup Domain Access */
 109:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     PWR->CR |= PWR_CR_DBP;
  65              		.loc 1 109 0
  66 0004 064A     		ldr	r2, .L5
  67 0006 1368     		ldr	r3, [r2]
  68 0008 8021     		mov	r1, #128
  69 000a 4900     		lsl	r1, r1, #1
  70 000c 0B43     		orr	r3, r1
  71 000e 1360     		str	r3, [r2]
  72 0010 04E0     		b	.L2
  73              	.L3:
 110:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   }
 111:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   else
 112:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   {
 113:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     /* Disable the Backup Domain Access */
 114:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     PWR->CR &= (uint32_t)~((uint32_t)PWR_CR_DBP);
  74              		.loc 1 114 0
  75 0012 034A     		ldr	r2, .L5
  76 0014 1168     		ldr	r1, [r2]
  77 0016 034B     		ldr	r3, .L5+4
  78 0018 0B40     		and	r3, r1
  79 001a 1360     		str	r3, [r2]
  80              	.L2:
 115:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   } 
 116:.\StdPeriphLib\src/stm32f0xx_pwr.c **** }
  81              		.loc 1 116 0
  82              		@ sp needed
  83 001c 7047     		bx	lr
  84              	.L6:
  85 001e C046     		.align	2
  86              	.L5:
  87 0020 00700040 		.word	1073770496
  88 0024 FFFEFFFF 		.word	-257
  89              		.cfi_endproc
  90              	.LFE34:
  92              		.section	.text.PWR_PVDLevelConfig,"ax",%progbits
  93              		.align	2
  94              		.global	PWR_PVDLevelConfig
  95              		.code	16
  96              		.thumb_func
  98              	PWR_PVDLevelConfig:
  99              	.LFB35:
 117:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 118:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
 119:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @}
 120:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 121:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 122:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /** @defgroup PWR_Group2 PVD configuration functions
 123:.\StdPeriphLib\src/stm32f0xx_pwr.c ****  *  @brief   PVD configuration functions 
 124:.\StdPeriphLib\src/stm32f0xx_pwr.c ****  *
 125:.\StdPeriphLib\src/stm32f0xx_pwr.c **** @verbatim
 126:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ==============================================================================
 127:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                     ##### PVD configuration functions #####
 128:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ==============================================================================
 129:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   [..]
 130:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   (+) The PVD is used to monitor the VDD power supply by comparing it to a threshold
 131:.\StdPeriphLib\src/stm32f0xx_pwr.c ****       selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
 132:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower than the 
 133:.\StdPeriphLib\src/stm32f0xx_pwr.c ****       PVD threshold. This event is internally connected to the EXTI line16
 134:.\StdPeriphLib\src/stm32f0xx_pwr.c ****       and can generate an interrupt if enabled through the EXTI registers.
 135:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   (+) The PVD is stopped in Standby mode.
 136:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 137:.\StdPeriphLib\src/stm32f0xx_pwr.c **** @endverbatim
 138:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @{
 139:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 140:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 141:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
 142:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
 143:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @note   This function is not applicable for STM32F030 devices. 
 144:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @param  PWR_PVDLevel: specifies the PVD detection level
 145:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *          This parameter can be one of the following values:
 146:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_PVDLevel_0
 147:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_PVDLevel_1
 148:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_PVDLevel_2
 149:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_PVDLevel_3
 150:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_PVDLevel_4
 151:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_PVDLevel_5
 152:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_PVDLevel_6
 153:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_PVDLevel_7
 154:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @note   Refer to the electrical characteristics of your device datasheet for
 155:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *         more details about the voltage threshold corresponding to each 
 156:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *         detection level.
 157:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @retval None
 158:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 159:.\StdPeriphLib\src/stm32f0xx_pwr.c **** void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
 160:.\StdPeriphLib\src/stm32f0xx_pwr.c **** {
 100              		.loc 1 160 0
 101              		.cfi_startproc
 102              	.LVL3:
 161:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   uint32_t tmpreg = 0;
 162:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   
 163:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Check the parameters */
 164:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
 165:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   
 166:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   tmpreg = PWR->CR;
 103              		.loc 1 166 0
 104 0000 034A     		ldr	r2, .L8
 105 0002 1368     		ldr	r3, [r2]
 106              	.LVL4:
 167:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   
 168:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Clear PLS[7:5] bits */
 169:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   tmpreg &= CR_PLS_MASK;
 107              		.loc 1 169 0
 108 0004 E021     		mov	r1, #224
 109 0006 8B43     		bic	r3, r1
 110              	.LVL5:
 170:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   
 171:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Set PLS[7:5] bits according to PWR_PVDLevel value */
 172:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   tmpreg |= PWR_PVDLevel;
 111              		.loc 1 172 0
 112 0008 1843     		orr	r0, r3
 113              	.LVL6:
 173:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   
 174:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Store the new value */
 175:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   PWR->CR = tmpreg;
 114              		.loc 1 175 0
 115 000a 1060     		str	r0, [r2]
 176:.\StdPeriphLib\src/stm32f0xx_pwr.c **** }
 116              		.loc 1 176 0
 117              		@ sp needed
 118 000c 7047     		bx	lr
 119              	.L9:
 120 000e C046     		.align	2
 121              	.L8:
 122 0010 00700040 		.word	1073770496
 123              		.cfi_endproc
 124              	.LFE35:
 126              		.section	.text.PWR_PVDCmd,"ax",%progbits
 127              		.align	2
 128              		.global	PWR_PVDCmd
 129              		.code	16
 130              		.thumb_func
 132              	PWR_PVDCmd:
 133              	.LFB36:
 177:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 178:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
 179:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @brief  Enables or disables the Power Voltage Detector(PVD).
 180:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @note   This function is not applicable for STM32F030 devices.    
 181:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @param  NewState: new state of the PVD.
 182:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 183:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @retval None
 184:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 185:.\StdPeriphLib\src/stm32f0xx_pwr.c **** void PWR_PVDCmd(FunctionalState NewState)
 186:.\StdPeriphLib\src/stm32f0xx_pwr.c **** {
 134              		.loc 1 186 0
 135              		.cfi_startproc
 136              	.LVL7:
 187:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Check the parameters */
 188:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 189:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   
 190:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   if (NewState != DISABLE)
 137              		.loc 1 190 0
 138 0000 0028     		cmp	r0, #0
 139 0002 05D0     		beq	.L11
 191:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   {
 192:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     /* Enable the PVD */
 193:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     PWR->CR |= PWR_CR_PVDE;
 140              		.loc 1 193 0
 141 0004 054A     		ldr	r2, .L13
 142 0006 1168     		ldr	r1, [r2]
 143 0008 1023     		mov	r3, #16
 144 000a 0B43     		orr	r3, r1
 145 000c 1360     		str	r3, [r2]
 146 000e 04E0     		b	.L10
 147              	.L11:
 194:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   }
 195:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   else
 196:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   {
 197:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     /* Disable the PVD */
 198:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     PWR->CR &= (uint32_t)~((uint32_t)PWR_CR_PVDE);
 148              		.loc 1 198 0
 149 0010 024A     		ldr	r2, .L13
 150 0012 1368     		ldr	r3, [r2]
 151 0014 1021     		mov	r1, #16
 152 0016 8B43     		bic	r3, r1
 153 0018 1360     		str	r3, [r2]
 154              	.L10:
 199:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   } 
 200:.\StdPeriphLib\src/stm32f0xx_pwr.c **** }
 155              		.loc 1 200 0
 156              		@ sp needed
 157 001a 7047     		bx	lr
 158              	.L14:
 159              		.align	2
 160              	.L13:
 161 001c 00700040 		.word	1073770496
 162              		.cfi_endproc
 163              	.LFE36:
 165              		.section	.text.PWR_WakeUpPinCmd,"ax",%progbits
 166              		.align	2
 167              		.global	PWR_WakeUpPinCmd
 168              		.code	16
 169              		.thumb_func
 171              	PWR_WakeUpPinCmd:
 172              	.LFB37:
 201:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 202:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
 203:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @}
 204:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 205:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 206:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /** @defgroup PWR_Group3 WakeUp pins configuration functions
 207:.\StdPeriphLib\src/stm32f0xx_pwr.c ****  *  @brief   WakeUp pins configuration functions 
 208:.\StdPeriphLib\src/stm32f0xx_pwr.c ****  *
 209:.\StdPeriphLib\src/stm32f0xx_pwr.c **** @verbatim
 210:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ==============================================================================
 211:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                ##### WakeUp pin configuration functions #####
 212:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ==============================================================================
 213:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 214:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   (+) WakeUp pins are used to wakeup the system from Standby mode. These pins are 
 215:.\StdPeriphLib\src/stm32f0xx_pwr.c ****       forced in input pull down configuration and are active on rising edges.
 216:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   (+) There are eight WakeUp pins: WakeUp Pin 1 on PA.00 and WakeUp Pin 2 on PC.13. 
 217:.\StdPeriphLib\src/stm32f0xx_pwr.c ****       The following WakeUp pins are only applicable for STM32F072 dvices:
 218:.\StdPeriphLib\src/stm32f0xx_pwr.c ****       WakeUp Pin 3 on PE.06, WakeUp Pin 4 on PA.02, WakeUp Pin 5 on PC.05, 
 219:.\StdPeriphLib\src/stm32f0xx_pwr.c ****       WakeUp Pin 6 on PB.05, WakeUp Pin 7 on PB.15 and WakeUp Pin 8 on PF.02.
 220:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 221:.\StdPeriphLib\src/stm32f0xx_pwr.c **** @endverbatim
 222:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @{
 223:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 224:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 225:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
 226:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @brief  Enables or disables the WakeUp Pin functionality.
 227:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @param  PWR_WakeUpPin: specifies the WakeUpPin.
 228:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *          This parameter can be one of the following values
 229:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_WakeUpPin_1
 230:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_WakeUpPin_2
 231:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_WakeUpPin_3, only applicable for STM32F072 devices
 232:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_WakeUpPin_4, only applicable for STM32F072 devices
 233:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_WakeUpPin_5, only applicable for STM32F072 devices
 234:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_WakeUpPin_6, only applicable for STM32F072 devices
 235:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_WakeUpPin_7, only applicable for STM32F072 devices
 236:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_WakeUpPin_8, only applicable for STM32F072 devices            
 237:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @param  NewState: new state of the WakeUp Pin functionality.
 238:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 239:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @retval None
 240:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 241:.\StdPeriphLib\src/stm32f0xx_pwr.c **** void PWR_WakeUpPinCmd(uint32_t PWR_WakeUpPin, FunctionalState NewState)
 242:.\StdPeriphLib\src/stm32f0xx_pwr.c **** {
 173              		.loc 1 242 0
 174              		.cfi_startproc
 175              	.LVL8:
 243:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Check the parameters */
 244:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(PWR_WakeUpPin));
 245:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 246:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 247:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   if (NewState != DISABLE)
 176              		.loc 1 247 0
 177 0000 0029     		cmp	r1, #0
 178 0002 04D0     		beq	.L16
 248:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   {
 249:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     /* Enable the EWUPx pin */
 250:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     PWR->CSR |= PWR_WakeUpPin;
 179              		.loc 1 250 0
 180 0004 044A     		ldr	r2, .L18
 181 0006 5368     		ldr	r3, [r2, #4]
 182 0008 1843     		orr	r0, r3
 183              	.LVL9:
 184 000a 5060     		str	r0, [r2, #4]
 185 000c 03E0     		b	.L15
 186              	.LVL10:
 187              	.L16:
 251:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   }
 252:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   else
 253:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   {
 254:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     /* Disable the EWUPx pin */
 255:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     PWR->CSR &= ~PWR_WakeUpPin;
 188              		.loc 1 255 0
 189 000e 024A     		ldr	r2, .L18
 190 0010 5368     		ldr	r3, [r2, #4]
 191 0012 8343     		bic	r3, r0
 192 0014 5360     		str	r3, [r2, #4]
 193              	.LVL11:
 194              	.L15:
 256:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   }
 257:.\StdPeriphLib\src/stm32f0xx_pwr.c **** }
 195              		.loc 1 257 0
 196              		@ sp needed
 197 0016 7047     		bx	lr
 198              	.L19:
 199              		.align	2
 200              	.L18:
 201 0018 00700040 		.word	1073770496
 202              		.cfi_endproc
 203              	.LFE37:
 205              		.section	.text.PWR_EnterSleepMode,"ax",%progbits
 206              		.align	2
 207              		.global	PWR_EnterSleepMode
 208              		.code	16
 209              		.thumb_func
 211              	PWR_EnterSleepMode:
 212              	.LFB38:
 258:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 259:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
 260:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @}
 261:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 262:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 263:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 264:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /** @defgroup PWR_Group4 Low Power modes configuration functions
 265:.\StdPeriphLib\src/stm32f0xx_pwr.c ****  *  @brief   Low Power modes configuration functions 
 266:.\StdPeriphLib\src/stm32f0xx_pwr.c ****  *
 267:.\StdPeriphLib\src/stm32f0xx_pwr.c **** @verbatim
 268:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ==============================================================================
 269:.\StdPeriphLib\src/stm32f0xx_pwr.c ****               ##### Low Power modes configuration functions #####
 270:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ==============================================================================
 271:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 272:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     [..] The devices feature three low-power modes:
 273:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     (+) Sleep mode: Cortex-M0 core stopped, peripherals kept running.
 274:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     (+) Stop mode: all clocks are stopped, regulator running, regulator in low power mode
 275:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     (+) Standby mode: VCORE domain powered off
 276:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 277:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *** Sleep mode *** 
 278:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ==================
 279:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   [..] 
 280:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     (+) Entry:
 281:.\StdPeriphLib\src/stm32f0xx_pwr.c ****         (++) The Sleep mode is entered by executing the WFE() or WFI() instructions.
 282:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     (+) Exit:
 283:.\StdPeriphLib\src/stm32f0xx_pwr.c ****         (++) Any peripheral interrupt acknowledged by the nested vectored interrupt 
 284:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              controller (NVIC) can wake up the device from Sleep mode.
 285:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 286:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *** Stop mode *** 
 287:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   =================
 288:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   [..] In Stop mode, all clocks in the VCORE domain are stopped, the PLL, the HSI,
 289:.\StdPeriphLib\src/stm32f0xx_pwr.c ****        the HSI14 and the HSE RC oscillators are disabled. Internal SRAM and register 
 290:.\StdPeriphLib\src/stm32f0xx_pwr.c ****        contents are preserved.
 291:.\StdPeriphLib\src/stm32f0xx_pwr.c ****        The voltage regulator can be configured either in normal or low-power mode.
 292:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 293:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     (+) Entry:
 294:.\StdPeriphLib\src/stm32f0xx_pwr.c ****         (++) The Stop mode is entered using the PWR_EnterSTOPMode(PWR_Regulator_LowPower,) 
 295:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              function with regulator in LowPower or with Regulator ON.
 296:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     (+) Exit:
 297:.\StdPeriphLib\src/stm32f0xx_pwr.c ****         (++) Any EXTI Line (Internal or External) configured in Interrupt/Event mode
 298:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              or any internal IPs (I2C, UASRT or CEC) wakeup event.
 299:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 300:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *** Standby mode *** 
 301:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ====================
 302:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   [..] The Standby mode allows to achieve the lowest power consumption. It is based 
 303:.\StdPeriphLib\src/stm32f0xx_pwr.c ****        on the Cortex-M0 deepsleep mode, with the voltage regulator disabled. 
 304:.\StdPeriphLib\src/stm32f0xx_pwr.c ****        The VCORE domain is consequently powered off. The PLL, the HSI, the HSI14 
 305:.\StdPeriphLib\src/stm32f0xx_pwr.c ****        oscillator and the HSE oscillator are also switched off. SRAM and register 
 306:.\StdPeriphLib\src/stm32f0xx_pwr.c ****        contents are lost except for the Backup domain (RTC registers, RTC backup 
 307:.\StdPeriphLib\src/stm32f0xx_pwr.c ****        registers and Standby circuitry).
 308:.\StdPeriphLib\src/stm32f0xx_pwr.c ****    
 309:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   [..] The voltage regulator is OFF.
 310:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 311:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     (+) Entry:
 312:.\StdPeriphLib\src/stm32f0xx_pwr.c ****         (++) The Standby mode is entered using the PWR_EnterSTANDBYMode() function.
 313:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     (+) Exit:
 314:.\StdPeriphLib\src/stm32f0xx_pwr.c ****         (++) WKUP pin rising edge, RTC alarm (Alarm A and Alarm B), RTC wakeup,
 315:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              tamper event, time-stamp event, external reset in NRST pin, IWDG reset.
 316:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 317:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *** Auto-wakeup (AWU) from low-power mode *** 
 318:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   =============================================
 319:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   [..] The MCU can be woken up from low-power mode by an RTC Alarm event, a tamper 
 320:.\StdPeriphLib\src/stm32f0xx_pwr.c ****        event, a time-stamp event, or a comparator event, without depending on an 
 321:.\StdPeriphLib\src/stm32f0xx_pwr.c ****        external interrupt (Auto-wakeup mode).
 322:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 323:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     (+) RTC auto-wakeup (AWU) from the Stop mode
 324:.\StdPeriphLib\src/stm32f0xx_pwr.c ****         (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to:
 325:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              (+++) Configure the EXTI Line 17 to be sensitive to rising edges (Interrupt 
 326:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                    or Event modes) using the EXTI_Init() function.
 327:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              (+++) Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
 328:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              (+++) Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
 329:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                    and RTC_AlarmCmd() functions.
 330:.\StdPeriphLib\src/stm32f0xx_pwr.c ****         (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it 
 331:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              is necessary to:
 332:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              (+++) Configure the EXTI Line 19 to be sensitive to rising edges (Interrupt 
 333:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                    or Event modes) using the EXTI_Init() function.
 334:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              (+++) Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
 335:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                    function.
 336:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              (+++) Configure the RTC to detect the tamper or time stamp event using the
 337:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                    RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
 338:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                    functions.
 339:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 340:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     (+) RTC auto-wakeup (AWU) from the Standby mode
 341:.\StdPeriphLib\src/stm32f0xx_pwr.c ****         (++) To wake up from the Standby mode with an RTC alarm event, it is necessary to:
 342:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              (+++) Enable the RTC Alarm Interrupt using the RTC_ITConfig() function.
 343:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              (+++) Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
 344:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                    and RTC_AlarmCmd() functions.
 345:.\StdPeriphLib\src/stm32f0xx_pwr.c ****         (++) To wake up from the Standby mode with an RTC Tamper or time stamp event, it 
 346:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              is necessary to:
 347:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              (+++) Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
 348:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                    function.
 349:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              (+++) Configure the RTC to detect the tamper or time stamp event using the
 350:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                    RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
 351:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                    functions.
 352:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 353:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     (+) Comparator auto-wakeup (AWU) from the Stop mode
 354:.\StdPeriphLib\src/stm32f0xx_pwr.c ****         (++) To wake up from the Stop mode with an comparator 1 or comparator 2 wakeup
 355:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              event, it is necessary to:
 356:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              (+++) Configure the EXTI Line 21 for comparator 1 or EXTI Line 22 for comparator 2 
 357:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                    to be sensitive to to the selected edges (falling, rising or falling 
 358:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                    and rising) (Interrupt or Event modes) using the EXTI_Init() function.
 359:.\StdPeriphLib\src/stm32f0xx_pwr.c ****              (+++) Configure the comparator to generate the event.
 360:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 361:.\StdPeriphLib\src/stm32f0xx_pwr.c **** @endverbatim
 362:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @{
 363:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 364:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 365:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
 366:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @brief  Enters Sleep mode.
 367:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @note   In Sleep mode, all I/O pins keep the same state as in Run mode.
 368:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @param  PWR_SLEEPEntry: specifies if SLEEP mode in entered with WFI or WFE instruction.
 369:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *          This parameter can be one of the following values:
 370:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_SLEEPEntry_WFI: enter SLEEP mode with WFI instruction
 371:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_SLEEPEntry_WFE: enter SLEEP mode with WFE instruction
 372:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @retval None
 373:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 374:.\StdPeriphLib\src/stm32f0xx_pwr.c **** void PWR_EnterSleepMode(uint8_t PWR_SLEEPEntry)
 375:.\StdPeriphLib\src/stm32f0xx_pwr.c **** {
 213              		.loc 1 375 0
 214              		.cfi_startproc
 215              	.LVL12:
 376:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Check the parameters */
 377:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   assert_param(IS_PWR_SLEEP_ENTRY(PWR_SLEEPEntry));
 378:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 379:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Clear SLEEPDEEP bit of Cortex-M0 System Control Register */
 380:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
 216              		.loc 1 380 0
 217 0000 064A     		ldr	r2, .L23
 218 0002 1369     		ldr	r3, [r2, #16]
 219 0004 0421     		mov	r1, #4
 220 0006 8B43     		bic	r3, r1
 221 0008 1361     		str	r3, [r2, #16]
 381:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   
 382:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Select SLEEP mode entry -------------------------------------------------*/
 383:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   if(PWR_SLEEPEntry == PWR_SLEEPEntry_WFI)
 222              		.loc 1 383 0
 223 000a 0128     		cmp	r0, #1
 224 000c 01D1     		bne	.L21
 225              	.LBB16:
 226              	.LBB17:
 227              		.file 2 ".\\CMSIS/core_cmInstr.h"
   1:.\CMSIS/core_cmInstr.h **** /**************************************************************************//**
   2:.\CMSIS/core_cmInstr.h ****  * @file     core_cmInstr.h
   3:.\CMSIS/core_cmInstr.h ****  * @brief    CMSIS Cortex-M Core Instruction Access Header File
   4:.\CMSIS/core_cmInstr.h ****  * @version  V3.20
   5:.\CMSIS/core_cmInstr.h ****  * @date     05. March 2013
   6:.\CMSIS/core_cmInstr.h ****  *
   7:.\CMSIS/core_cmInstr.h ****  * @note
   8:.\CMSIS/core_cmInstr.h ****  *
   9:.\CMSIS/core_cmInstr.h ****  ******************************************************************************/
  10:.\CMSIS/core_cmInstr.h **** /* Copyright (c) 2009 - 2013 ARM LIMITED
  11:.\CMSIS/core_cmInstr.h **** 
  12:.\CMSIS/core_cmInstr.h ****    All rights reserved.
  13:.\CMSIS/core_cmInstr.h ****    Redistribution and use in source and binary forms, with or without
  14:.\CMSIS/core_cmInstr.h ****    modification, are permitted provided that the following conditions are met:
  15:.\CMSIS/core_cmInstr.h ****    - Redistributions of source code must retain the above copyright
  16:.\CMSIS/core_cmInstr.h ****      notice, this list of conditions and the following disclaimer.
  17:.\CMSIS/core_cmInstr.h ****    - Redistributions in binary form must reproduce the above copyright
  18:.\CMSIS/core_cmInstr.h ****      notice, this list of conditions and the following disclaimer in the
  19:.\CMSIS/core_cmInstr.h ****      documentation and/or other materials provided with the distribution.
  20:.\CMSIS/core_cmInstr.h ****    - Neither the name of ARM nor the names of its contributors may be used
  21:.\CMSIS/core_cmInstr.h ****      to endorse or promote products derived from this software without
  22:.\CMSIS/core_cmInstr.h ****      specific prior written permission.
  23:.\CMSIS/core_cmInstr.h ****    *
  24:.\CMSIS/core_cmInstr.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:.\CMSIS/core_cmInstr.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:.\CMSIS/core_cmInstr.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:.\CMSIS/core_cmInstr.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  28:.\CMSIS/core_cmInstr.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:.\CMSIS/core_cmInstr.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:.\CMSIS/core_cmInstr.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:.\CMSIS/core_cmInstr.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:.\CMSIS/core_cmInstr.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:.\CMSIS/core_cmInstr.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:.\CMSIS/core_cmInstr.h ****    POSSIBILITY OF SUCH DAMAGE.
  35:.\CMSIS/core_cmInstr.h ****    ---------------------------------------------------------------------------*/
  36:.\CMSIS/core_cmInstr.h **** 
  37:.\CMSIS/core_cmInstr.h **** 
  38:.\CMSIS/core_cmInstr.h **** #ifndef __CORE_CMINSTR_H
  39:.\CMSIS/core_cmInstr.h **** #define __CORE_CMINSTR_H
  40:.\CMSIS/core_cmInstr.h **** 
  41:.\CMSIS/core_cmInstr.h **** 
  42:.\CMSIS/core_cmInstr.h **** /* ##########################  Core Instruction Access  ######################### */
  43:.\CMSIS/core_cmInstr.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
  44:.\CMSIS/core_cmInstr.h ****   Access to dedicated instructions
  45:.\CMSIS/core_cmInstr.h ****   @{
  46:.\CMSIS/core_cmInstr.h **** */
  47:.\CMSIS/core_cmInstr.h **** 
  48:.\CMSIS/core_cmInstr.h **** #if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
  49:.\CMSIS/core_cmInstr.h **** /* ARM armcc specific functions */
  50:.\CMSIS/core_cmInstr.h **** 
  51:.\CMSIS/core_cmInstr.h **** #if (__ARMCC_VERSION < 400677)
  52:.\CMSIS/core_cmInstr.h ****   #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
  53:.\CMSIS/core_cmInstr.h **** #endif
  54:.\CMSIS/core_cmInstr.h **** 
  55:.\CMSIS/core_cmInstr.h **** 
  56:.\CMSIS/core_cmInstr.h **** /** \brief  No Operation
  57:.\CMSIS/core_cmInstr.h **** 
  58:.\CMSIS/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
  59:.\CMSIS/core_cmInstr.h ****  */
  60:.\CMSIS/core_cmInstr.h **** #define __NOP                             __nop
  61:.\CMSIS/core_cmInstr.h **** 
  62:.\CMSIS/core_cmInstr.h **** 
  63:.\CMSIS/core_cmInstr.h **** /** \brief  Wait For Interrupt
  64:.\CMSIS/core_cmInstr.h **** 
  65:.\CMSIS/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
  66:.\CMSIS/core_cmInstr.h ****     until one of a number of events occurs.
  67:.\CMSIS/core_cmInstr.h ****  */
  68:.\CMSIS/core_cmInstr.h **** #define __WFI                             __wfi
  69:.\CMSIS/core_cmInstr.h **** 
  70:.\CMSIS/core_cmInstr.h **** 
  71:.\CMSIS/core_cmInstr.h **** /** \brief  Wait For Event
  72:.\CMSIS/core_cmInstr.h **** 
  73:.\CMSIS/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
  74:.\CMSIS/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
  75:.\CMSIS/core_cmInstr.h ****  */
  76:.\CMSIS/core_cmInstr.h **** #define __WFE                             __wfe
  77:.\CMSIS/core_cmInstr.h **** 
  78:.\CMSIS/core_cmInstr.h **** 
  79:.\CMSIS/core_cmInstr.h **** /** \brief  Send Event
  80:.\CMSIS/core_cmInstr.h **** 
  81:.\CMSIS/core_cmInstr.h ****     Send Event is a hint instruction. It causes an event to be signaled to the CPU.
  82:.\CMSIS/core_cmInstr.h ****  */
  83:.\CMSIS/core_cmInstr.h **** #define __SEV                             __sev
  84:.\CMSIS/core_cmInstr.h **** 
  85:.\CMSIS/core_cmInstr.h **** 
  86:.\CMSIS/core_cmInstr.h **** /** \brief  Instruction Synchronization Barrier
  87:.\CMSIS/core_cmInstr.h **** 
  88:.\CMSIS/core_cmInstr.h ****     Instruction Synchronization Barrier flushes the pipeline in the processor,
  89:.\CMSIS/core_cmInstr.h ****     so that all instructions following the ISB are fetched from cache or
  90:.\CMSIS/core_cmInstr.h ****     memory, after the instruction has been completed.
  91:.\CMSIS/core_cmInstr.h ****  */
  92:.\CMSIS/core_cmInstr.h **** #define __ISB()                           __isb(0xF)
  93:.\CMSIS/core_cmInstr.h **** 
  94:.\CMSIS/core_cmInstr.h **** 
  95:.\CMSIS/core_cmInstr.h **** /** \brief  Data Synchronization Barrier
  96:.\CMSIS/core_cmInstr.h **** 
  97:.\CMSIS/core_cmInstr.h ****     This function acts as a special kind of Data Memory Barrier.
  98:.\CMSIS/core_cmInstr.h ****     It completes when all explicit memory accesses before this instruction complete.
  99:.\CMSIS/core_cmInstr.h ****  */
 100:.\CMSIS/core_cmInstr.h **** #define __DSB()                           __dsb(0xF)
 101:.\CMSIS/core_cmInstr.h **** 
 102:.\CMSIS/core_cmInstr.h **** 
 103:.\CMSIS/core_cmInstr.h **** /** \brief  Data Memory Barrier
 104:.\CMSIS/core_cmInstr.h **** 
 105:.\CMSIS/core_cmInstr.h ****     This function ensures the apparent order of the explicit memory operations before
 106:.\CMSIS/core_cmInstr.h ****     and after the instruction, without ensuring their completion.
 107:.\CMSIS/core_cmInstr.h ****  */
 108:.\CMSIS/core_cmInstr.h **** #define __DMB()                           __dmb(0xF)
 109:.\CMSIS/core_cmInstr.h **** 
 110:.\CMSIS/core_cmInstr.h **** 
 111:.\CMSIS/core_cmInstr.h **** /** \brief  Reverse byte order (32 bit)
 112:.\CMSIS/core_cmInstr.h **** 
 113:.\CMSIS/core_cmInstr.h ****     This function reverses the byte order in integer value.
 114:.\CMSIS/core_cmInstr.h **** 
 115:.\CMSIS/core_cmInstr.h ****     \param [in]    value  Value to reverse
 116:.\CMSIS/core_cmInstr.h ****     \return               Reversed value
 117:.\CMSIS/core_cmInstr.h ****  */
 118:.\CMSIS/core_cmInstr.h **** #define __REV                             __rev
 119:.\CMSIS/core_cmInstr.h **** 
 120:.\CMSIS/core_cmInstr.h **** 
 121:.\CMSIS/core_cmInstr.h **** /** \brief  Reverse byte order (16 bit)
 122:.\CMSIS/core_cmInstr.h **** 
 123:.\CMSIS/core_cmInstr.h ****     This function reverses the byte order in two unsigned short values.
 124:.\CMSIS/core_cmInstr.h **** 
 125:.\CMSIS/core_cmInstr.h ****     \param [in]    value  Value to reverse
 126:.\CMSIS/core_cmInstr.h ****     \return               Reversed value
 127:.\CMSIS/core_cmInstr.h ****  */
 128:.\CMSIS/core_cmInstr.h **** #ifndef __NO_EMBEDDED_ASM
 129:.\CMSIS/core_cmInstr.h **** __attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
 130:.\CMSIS/core_cmInstr.h **** {
 131:.\CMSIS/core_cmInstr.h ****   rev16 r0, r0
 132:.\CMSIS/core_cmInstr.h ****   bx lr
 133:.\CMSIS/core_cmInstr.h **** }
 134:.\CMSIS/core_cmInstr.h **** #endif
 135:.\CMSIS/core_cmInstr.h **** 
 136:.\CMSIS/core_cmInstr.h **** /** \brief  Reverse byte order in signed short value
 137:.\CMSIS/core_cmInstr.h **** 
 138:.\CMSIS/core_cmInstr.h ****     This function reverses the byte order in a signed short value with sign extension to integer.
 139:.\CMSIS/core_cmInstr.h **** 
 140:.\CMSIS/core_cmInstr.h ****     \param [in]    value  Value to reverse
 141:.\CMSIS/core_cmInstr.h ****     \return               Reversed value
 142:.\CMSIS/core_cmInstr.h ****  */
 143:.\CMSIS/core_cmInstr.h **** #ifndef __NO_EMBEDDED_ASM
 144:.\CMSIS/core_cmInstr.h **** __attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
 145:.\CMSIS/core_cmInstr.h **** {
 146:.\CMSIS/core_cmInstr.h ****   revsh r0, r0
 147:.\CMSIS/core_cmInstr.h ****   bx lr
 148:.\CMSIS/core_cmInstr.h **** }
 149:.\CMSIS/core_cmInstr.h **** #endif
 150:.\CMSIS/core_cmInstr.h **** 
 151:.\CMSIS/core_cmInstr.h **** 
 152:.\CMSIS/core_cmInstr.h **** /** \brief  Rotate Right in unsigned value (32 bit)
 153:.\CMSIS/core_cmInstr.h **** 
 154:.\CMSIS/core_cmInstr.h ****     This function Rotate Right (immediate) provides the value of the contents of a register rotated
 155:.\CMSIS/core_cmInstr.h **** 
 156:.\CMSIS/core_cmInstr.h ****     \param [in]    value  Value to rotate
 157:.\CMSIS/core_cmInstr.h ****     \param [in]    value  Number of Bits to rotate
 158:.\CMSIS/core_cmInstr.h ****     \return               Rotated value
 159:.\CMSIS/core_cmInstr.h ****  */
 160:.\CMSIS/core_cmInstr.h **** #define __ROR                             __ror
 161:.\CMSIS/core_cmInstr.h **** 
 162:.\CMSIS/core_cmInstr.h **** 
 163:.\CMSIS/core_cmInstr.h **** /** \brief  Breakpoint
 164:.\CMSIS/core_cmInstr.h **** 
 165:.\CMSIS/core_cmInstr.h ****     This function causes the processor to enter Debug state.
 166:.\CMSIS/core_cmInstr.h ****     Debug tools can use this to investigate system state when the instruction at a particular addre
 167:.\CMSIS/core_cmInstr.h **** 
 168:.\CMSIS/core_cmInstr.h ****     \param [in]    value  is ignored by the processor.
 169:.\CMSIS/core_cmInstr.h ****                    If required, a debugger can use it to store additional information about the bre
 170:.\CMSIS/core_cmInstr.h ****  */
 171:.\CMSIS/core_cmInstr.h **** #define __BKPT(value)                       __breakpoint(value)
 172:.\CMSIS/core_cmInstr.h **** 
 173:.\CMSIS/core_cmInstr.h **** 
 174:.\CMSIS/core_cmInstr.h **** #if       (__CORTEX_M >= 0x03)
 175:.\CMSIS/core_cmInstr.h **** 
 176:.\CMSIS/core_cmInstr.h **** /** \brief  Reverse bit order of value
 177:.\CMSIS/core_cmInstr.h **** 
 178:.\CMSIS/core_cmInstr.h ****     This function reverses the bit order of the given value.
 179:.\CMSIS/core_cmInstr.h **** 
 180:.\CMSIS/core_cmInstr.h ****     \param [in]    value  Value to reverse
 181:.\CMSIS/core_cmInstr.h ****     \return               Reversed value
 182:.\CMSIS/core_cmInstr.h ****  */
 183:.\CMSIS/core_cmInstr.h **** #define __RBIT                            __rbit
 184:.\CMSIS/core_cmInstr.h **** 
 185:.\CMSIS/core_cmInstr.h **** 
 186:.\CMSIS/core_cmInstr.h **** /** \brief  LDR Exclusive (8 bit)
 187:.\CMSIS/core_cmInstr.h **** 
 188:.\CMSIS/core_cmInstr.h ****     This function performs a exclusive LDR command for 8 bit value.
 189:.\CMSIS/core_cmInstr.h **** 
 190:.\CMSIS/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 191:.\CMSIS/core_cmInstr.h ****     \return             value of type uint8_t at (*ptr)
 192:.\CMSIS/core_cmInstr.h ****  */
 193:.\CMSIS/core_cmInstr.h **** #define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
 194:.\CMSIS/core_cmInstr.h **** 
 195:.\CMSIS/core_cmInstr.h **** 
 196:.\CMSIS/core_cmInstr.h **** /** \brief  LDR Exclusive (16 bit)
 197:.\CMSIS/core_cmInstr.h **** 
 198:.\CMSIS/core_cmInstr.h ****     This function performs a exclusive LDR command for 16 bit values.
 199:.\CMSIS/core_cmInstr.h **** 
 200:.\CMSIS/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 201:.\CMSIS/core_cmInstr.h ****     \return        value of type uint16_t at (*ptr)
 202:.\CMSIS/core_cmInstr.h ****  */
 203:.\CMSIS/core_cmInstr.h **** #define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
 204:.\CMSIS/core_cmInstr.h **** 
 205:.\CMSIS/core_cmInstr.h **** 
 206:.\CMSIS/core_cmInstr.h **** /** \brief  LDR Exclusive (32 bit)
 207:.\CMSIS/core_cmInstr.h **** 
 208:.\CMSIS/core_cmInstr.h ****     This function performs a exclusive LDR command for 32 bit values.
 209:.\CMSIS/core_cmInstr.h **** 
 210:.\CMSIS/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 211:.\CMSIS/core_cmInstr.h ****     \return        value of type uint32_t at (*ptr)
 212:.\CMSIS/core_cmInstr.h ****  */
 213:.\CMSIS/core_cmInstr.h **** #define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
 214:.\CMSIS/core_cmInstr.h **** 
 215:.\CMSIS/core_cmInstr.h **** 
 216:.\CMSIS/core_cmInstr.h **** /** \brief  STR Exclusive (8 bit)
 217:.\CMSIS/core_cmInstr.h **** 
 218:.\CMSIS/core_cmInstr.h ****     This function performs a exclusive STR command for 8 bit values.
 219:.\CMSIS/core_cmInstr.h **** 
 220:.\CMSIS/core_cmInstr.h ****     \param [in]  value  Value to store
 221:.\CMSIS/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 222:.\CMSIS/core_cmInstr.h ****     \return          0  Function succeeded
 223:.\CMSIS/core_cmInstr.h ****     \return          1  Function failed
 224:.\CMSIS/core_cmInstr.h ****  */
 225:.\CMSIS/core_cmInstr.h **** #define __STREXB(value, ptr)              __strex(value, ptr)
 226:.\CMSIS/core_cmInstr.h **** 
 227:.\CMSIS/core_cmInstr.h **** 
 228:.\CMSIS/core_cmInstr.h **** /** \brief  STR Exclusive (16 bit)
 229:.\CMSIS/core_cmInstr.h **** 
 230:.\CMSIS/core_cmInstr.h ****     This function performs a exclusive STR command for 16 bit values.
 231:.\CMSIS/core_cmInstr.h **** 
 232:.\CMSIS/core_cmInstr.h ****     \param [in]  value  Value to store
 233:.\CMSIS/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 234:.\CMSIS/core_cmInstr.h ****     \return          0  Function succeeded
 235:.\CMSIS/core_cmInstr.h ****     \return          1  Function failed
 236:.\CMSIS/core_cmInstr.h ****  */
 237:.\CMSIS/core_cmInstr.h **** #define __STREXH(value, ptr)              __strex(value, ptr)
 238:.\CMSIS/core_cmInstr.h **** 
 239:.\CMSIS/core_cmInstr.h **** 
 240:.\CMSIS/core_cmInstr.h **** /** \brief  STR Exclusive (32 bit)
 241:.\CMSIS/core_cmInstr.h **** 
 242:.\CMSIS/core_cmInstr.h ****     This function performs a exclusive STR command for 32 bit values.
 243:.\CMSIS/core_cmInstr.h **** 
 244:.\CMSIS/core_cmInstr.h ****     \param [in]  value  Value to store
 245:.\CMSIS/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 246:.\CMSIS/core_cmInstr.h ****     \return          0  Function succeeded
 247:.\CMSIS/core_cmInstr.h ****     \return          1  Function failed
 248:.\CMSIS/core_cmInstr.h ****  */
 249:.\CMSIS/core_cmInstr.h **** #define __STREXW(value, ptr)              __strex(value, ptr)
 250:.\CMSIS/core_cmInstr.h **** 
 251:.\CMSIS/core_cmInstr.h **** 
 252:.\CMSIS/core_cmInstr.h **** /** \brief  Remove the exclusive lock
 253:.\CMSIS/core_cmInstr.h **** 
 254:.\CMSIS/core_cmInstr.h ****     This function removes the exclusive lock which is created by LDREX.
 255:.\CMSIS/core_cmInstr.h **** 
 256:.\CMSIS/core_cmInstr.h ****  */
 257:.\CMSIS/core_cmInstr.h **** #define __CLREX                           __clrex
 258:.\CMSIS/core_cmInstr.h **** 
 259:.\CMSIS/core_cmInstr.h **** 
 260:.\CMSIS/core_cmInstr.h **** /** \brief  Signed Saturate
 261:.\CMSIS/core_cmInstr.h **** 
 262:.\CMSIS/core_cmInstr.h ****     This function saturates a signed value.
 263:.\CMSIS/core_cmInstr.h **** 
 264:.\CMSIS/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 265:.\CMSIS/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (1..32)
 266:.\CMSIS/core_cmInstr.h ****     \return             Saturated value
 267:.\CMSIS/core_cmInstr.h ****  */
 268:.\CMSIS/core_cmInstr.h **** #define __SSAT                            __ssat
 269:.\CMSIS/core_cmInstr.h **** 
 270:.\CMSIS/core_cmInstr.h **** 
 271:.\CMSIS/core_cmInstr.h **** /** \brief  Unsigned Saturate
 272:.\CMSIS/core_cmInstr.h **** 
 273:.\CMSIS/core_cmInstr.h ****     This function saturates an unsigned value.
 274:.\CMSIS/core_cmInstr.h **** 
 275:.\CMSIS/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 276:.\CMSIS/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (0..31)
 277:.\CMSIS/core_cmInstr.h ****     \return             Saturated value
 278:.\CMSIS/core_cmInstr.h ****  */
 279:.\CMSIS/core_cmInstr.h **** #define __USAT                            __usat
 280:.\CMSIS/core_cmInstr.h **** 
 281:.\CMSIS/core_cmInstr.h **** 
 282:.\CMSIS/core_cmInstr.h **** /** \brief  Count leading zeros
 283:.\CMSIS/core_cmInstr.h **** 
 284:.\CMSIS/core_cmInstr.h ****     This function counts the number of leading zeros of a data value.
 285:.\CMSIS/core_cmInstr.h **** 
 286:.\CMSIS/core_cmInstr.h ****     \param [in]  value  Value to count the leading zeros
 287:.\CMSIS/core_cmInstr.h ****     \return             number of leading zeros in value
 288:.\CMSIS/core_cmInstr.h ****  */
 289:.\CMSIS/core_cmInstr.h **** #define __CLZ                             __clz
 290:.\CMSIS/core_cmInstr.h **** 
 291:.\CMSIS/core_cmInstr.h **** #endif /* (__CORTEX_M >= 0x03) */
 292:.\CMSIS/core_cmInstr.h **** 
 293:.\CMSIS/core_cmInstr.h **** 
 294:.\CMSIS/core_cmInstr.h **** 
 295:.\CMSIS/core_cmInstr.h **** #elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
 296:.\CMSIS/core_cmInstr.h **** /* IAR iccarm specific functions */
 297:.\CMSIS/core_cmInstr.h **** 
 298:.\CMSIS/core_cmInstr.h **** #include <cmsis_iar.h>
 299:.\CMSIS/core_cmInstr.h **** 
 300:.\CMSIS/core_cmInstr.h **** 
 301:.\CMSIS/core_cmInstr.h **** #elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
 302:.\CMSIS/core_cmInstr.h **** /* TI CCS specific functions */
 303:.\CMSIS/core_cmInstr.h **** 
 304:.\CMSIS/core_cmInstr.h **** #include <cmsis_ccs.h>
 305:.\CMSIS/core_cmInstr.h **** 
 306:.\CMSIS/core_cmInstr.h **** 
 307:.\CMSIS/core_cmInstr.h **** #elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
 308:.\CMSIS/core_cmInstr.h **** /* GNU gcc specific functions */
 309:.\CMSIS/core_cmInstr.h **** 
 310:.\CMSIS/core_cmInstr.h **** /* Define macros for porting to both thumb1 and thumb2.
 311:.\CMSIS/core_cmInstr.h ****  * For thumb1, use low register (r0-r7), specified by constrant "l"
 312:.\CMSIS/core_cmInstr.h ****  * Otherwise, use general registers, specified by constrant "r" */
 313:.\CMSIS/core_cmInstr.h **** #if defined (__thumb__) && !defined (__thumb2__)
 314:.\CMSIS/core_cmInstr.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 315:.\CMSIS/core_cmInstr.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 316:.\CMSIS/core_cmInstr.h **** #else
 317:.\CMSIS/core_cmInstr.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 318:.\CMSIS/core_cmInstr.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 319:.\CMSIS/core_cmInstr.h **** #endif
 320:.\CMSIS/core_cmInstr.h **** 
 321:.\CMSIS/core_cmInstr.h **** /** \brief  No Operation
 322:.\CMSIS/core_cmInstr.h **** 
 323:.\CMSIS/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
 324:.\CMSIS/core_cmInstr.h ****  */
 325:.\CMSIS/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
 326:.\CMSIS/core_cmInstr.h **** {
 327:.\CMSIS/core_cmInstr.h ****   __ASM volatile ("nop");
 328:.\CMSIS/core_cmInstr.h **** }
 329:.\CMSIS/core_cmInstr.h **** 
 330:.\CMSIS/core_cmInstr.h **** 
 331:.\CMSIS/core_cmInstr.h **** /** \brief  Wait For Interrupt
 332:.\CMSIS/core_cmInstr.h **** 
 333:.\CMSIS/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
 334:.\CMSIS/core_cmInstr.h ****     until one of a number of events occurs.
 335:.\CMSIS/core_cmInstr.h ****  */
 336:.\CMSIS/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
 337:.\CMSIS/core_cmInstr.h **** {
 338:.\CMSIS/core_cmInstr.h ****   __ASM volatile ("wfi");
 228              		.loc 2 338 0
 229              	@ 338 ".\CMSIS/core_cmInstr.h" 1
 230 000e 30BF     		wfi
 231              	@ 0 "" 2
 232              		.code	16
 233 0010 02E0     		b	.L20
 234              	.L21:
 235              	.LBE17:
 236              	.LBE16:
 237              	.LBB18:
 238              	.LBB19:
 339:.\CMSIS/core_cmInstr.h **** }
 340:.\CMSIS/core_cmInstr.h **** 
 341:.\CMSIS/core_cmInstr.h **** 
 342:.\CMSIS/core_cmInstr.h **** /** \brief  Wait For Event
 343:.\CMSIS/core_cmInstr.h **** 
 344:.\CMSIS/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
 345:.\CMSIS/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
 346:.\CMSIS/core_cmInstr.h ****  */
 347:.\CMSIS/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
 348:.\CMSIS/core_cmInstr.h **** {
 349:.\CMSIS/core_cmInstr.h ****   __ASM volatile ("wfe");
 350:.\CMSIS/core_cmInstr.h **** }
 351:.\CMSIS/core_cmInstr.h **** 
 352:.\CMSIS/core_cmInstr.h **** 
 353:.\CMSIS/core_cmInstr.h **** /** \brief  Send Event
 354:.\CMSIS/core_cmInstr.h **** 
 355:.\CMSIS/core_cmInstr.h ****     Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 356:.\CMSIS/core_cmInstr.h ****  */
 357:.\CMSIS/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
 358:.\CMSIS/core_cmInstr.h **** {
 359:.\CMSIS/core_cmInstr.h ****   __ASM volatile ("sev");
 239              		.loc 2 359 0
 240              	@ 359 ".\CMSIS/core_cmInstr.h" 1
 241 0012 40BF     		sev
 242              	@ 0 "" 2
 243              		.code	16
 244              	.LBE19:
 245              	.LBE18:
 246              	.LBB20:
 247              	.LBB21:
 349:.\CMSIS/core_cmInstr.h **** }
 248              		.loc 2 349 0
 249              	@ 349 ".\CMSIS/core_cmInstr.h" 1
 250 0014 20BF     		wfe
 251              	@ 0 "" 2
 252              		.code	16
 253              	.LBE21:
 254              	.LBE20:
 255              	.LBB22:
 256              	.LBB23:
 257              	@ 349 ".\CMSIS/core_cmInstr.h" 1
 258 0016 20BF     		wfe
 259              	@ 0 "" 2
 260              		.code	16
 261              	.L20:
 262              	.LBE23:
 263              	.LBE22:
 384:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   {
 385:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     /* Request Wait For Interrupt */
 386:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     __WFI();
 387:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   }
 388:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   else
 389:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   {
 390:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     /* Request Wait For Event */
 391:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     __SEV();
 392:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     __WFE(); 
 393:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     __WFE();
 394:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   }
 395:.\StdPeriphLib\src/stm32f0xx_pwr.c **** }
 264              		.loc 1 395 0
 265              		@ sp needed
 266 0018 7047     		bx	lr
 267              	.L24:
 268 001a C046     		.align	2
 269              	.L23:
 270 001c 00ED00E0 		.word	-536810240
 271              		.cfi_endproc
 272              	.LFE38:
 274              		.section	.text.PWR_EnterSTOPMode,"ax",%progbits
 275              		.align	2
 276              		.global	PWR_EnterSTOPMode
 277              		.code	16
 278              		.thumb_func
 280              	PWR_EnterSTOPMode:
 281              	.LFB39:
 396:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 397:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
 398:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @brief  Enters STOP mode.
 399:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
 400:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
 401:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *         the HSI RC oscillator is selected as system clock.
 402:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @note   When the voltage regulator operates in low power mode, an additional 
 403:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *         startup delay is incurred when waking up from Stop mode. 
 404:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption 
 405:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *         is higher although the startup time is reduced.
 406:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @param  PWR_Regulator: specifies the regulator state in STOP mode.
 407:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *         This parameter can be one of the following values:
 408:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_Regulator_ON: STOP mode with regulator ON
 409:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_Regulator_LowPower: STOP mode with regulator in low power mode
 410:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
 411:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *         This parameter can be one of the following values:
 412:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
 413:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
 414:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                 @arg PWR_STOPEntry_SLEEPONEXIT: enter STOP mode with SLEEPONEXIT instruction
 415:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @retval None
 416:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 417:.\StdPeriphLib\src/stm32f0xx_pwr.c **** void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
 418:.\StdPeriphLib\src/stm32f0xx_pwr.c **** {
 282              		.loc 1 418 0
 283              		.cfi_startproc
 284              	.LVL13:
 285 0000 10B5     		push	{r4, lr}
 286              	.LCFI1:
 287              		.cfi_def_cfa_offset 8
 288              		.cfi_offset 4, -8
 289              		.cfi_offset 14, -4
 290              	.LVL14:
 419:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   uint32_t tmpreg = 0;
 420:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   
 421:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Check the parameters */
 422:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   assert_param(IS_PWR_REGULATOR(PWR_Regulator));
 423:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
 424:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   
 425:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Select the regulator state in STOP mode ---------------------------------*/
 426:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   tmpreg = PWR->CR;
 291              		.loc 1 426 0
 292 0002 114A     		ldr	r2, .L29
 293 0004 1368     		ldr	r3, [r2]
 294              	.LVL15:
 427:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Clear PDDS and LPDSR bits */
 428:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   tmpreg &= CR_DS_MASK;
 295              		.loc 1 428 0
 296 0006 0324     		mov	r4, #3
 297 0008 A343     		bic	r3, r4
 298              	.LVL16:
 429:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   
 430:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Set LPDSR bit according to PWR_Regulator value */
 431:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   tmpreg |= PWR_Regulator;
 299              		.loc 1 431 0
 300 000a 1843     		orr	r0, r3
 301              	.LVL17:
 432:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   
 433:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Store the new value */
 434:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   PWR->CR = tmpreg;
 302              		.loc 1 434 0
 303 000c 1060     		str	r0, [r2]
 435:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   
 436:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex-M0 System Control Register */
 437:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 304              		.loc 1 437 0
 305 000e 0F4A     		ldr	r2, .L29+4
 306 0010 1069     		ldr	r0, [r2, #16]
 307              	.LVL18:
 308 0012 0423     		mov	r3, #4
 309 0014 0343     		orr	r3, r0
 310 0016 1361     		str	r3, [r2, #16]
 311              	.LVL19:
 438:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   
 439:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Select STOP mode entry --------------------------------------------------*/
 440:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 312              		.loc 1 440 0
 313 0018 0129     		cmp	r1, #1
 314 001a 05D1     		bne	.L26
 315              	.LBB24:
 316              	.LBB25:
 338:.\CMSIS/core_cmInstr.h **** }
 317              		.loc 2 338 0
 318              	@ 338 ".\CMSIS/core_cmInstr.h" 1
 319 001c 30BF     		wfi
 320              	@ 0 "" 2
 321              		.code	16
 322              	.LBE25:
 323              	.LBE24:
 441:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   {
 442:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     /* Request Wait For Interrupt */
 443:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     __WFI();
 444:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     /* Reset SLEEPDEEP bit of Cortex System Control Register */
 445:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk); 
 324              		.loc 1 445 0
 325 001e 1369     		ldr	r3, [r2, #16]
 326 0020 0331     		add	r1, r1, #3
 327              	.LVL20:
 328 0022 8B43     		bic	r3, r1
 329 0024 1361     		str	r3, [r2, #16]
 330 0026 0DE0     		b	.L25
 331              	.LVL21:
 332              	.L26:
 446:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   }
 447:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   else if (PWR_STOPEntry == PWR_STOPEntry_WFE)
 333              		.loc 1 447 0
 334 0028 0229     		cmp	r1, #2
 335 002a 06D1     		bne	.L28
 336              	.LBB26:
 337              	.LBB27:
 349:.\CMSIS/core_cmInstr.h **** }
 338              		.loc 2 349 0
 339              	@ 349 ".\CMSIS/core_cmInstr.h" 1
 340 002c 20BF     		wfe
 341              	@ 0 "" 2
 342              		.code	16
 343              	.LBE27:
 344              	.LBE26:
 448:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   {
 449:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     /* Request Wait For Event */
 450:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     __WFE();
 451:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     /* Reset SLEEPDEEP bit of Cortex System Control Register */
 452:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);   
 345              		.loc 1 452 0
 346 002e 074A     		ldr	r2, .L29+4
 347 0030 1369     		ldr	r3, [r2, #16]
 348 0032 0231     		add	r1, r1, #2
 349              	.LVL22:
 350 0034 8B43     		bic	r3, r1
 351 0036 1361     		str	r3, [r2, #16]
 352 0038 04E0     		b	.L25
 353              	.LVL23:
 354              	.L28:
 453:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   }
 454:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   else
 455:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   {
 456:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     /* Set SLEEP on exit bit of Cortex-M0 System Control Register */
 457:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     SCB->SCR |= SCB_SCR_SLEEPONEXIT_Msk;
 355              		.loc 1 457 0
 356 003a 044A     		ldr	r2, .L29+4
 357 003c 1169     		ldr	r1, [r2, #16]
 358              	.LVL24:
 359 003e 0223     		mov	r3, #2
 360 0040 0B43     		orr	r3, r1
 361 0042 1361     		str	r3, [r2, #16]
 362              	.L25:
 458:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   }
 459:.\StdPeriphLib\src/stm32f0xx_pwr.c **** }
 363              		.loc 1 459 0
 364              		@ sp needed
 365 0044 10BD     		pop	{r4, pc}
 366              	.L30:
 367 0046 C046     		.align	2
 368              	.L29:
 369 0048 00700040 		.word	1073770496
 370 004c 00ED00E0 		.word	-536810240
 371              		.cfi_endproc
 372              	.LFE39:
 374              		.section	.text.PWR_EnterSTANDBYMode,"ax",%progbits
 375              		.align	2
 376              		.global	PWR_EnterSTANDBYMode
 377              		.code	16
 378              		.thumb_func
 380              	PWR_EnterSTANDBYMode:
 381              	.LFB40:
 460:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 461:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
 462:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @brief  Enters STANDBY mode.
 463:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @note   In Standby mode, all I/O pins are high impedance except for:
 464:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *          - Reset pad (still available) 
 465:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *          - RTC_AF1 pin (PC13) if configured for Wakeup pin 2 (WKUP2), tamper, 
 466:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             time-stamp, RTC Alarm out, or RTC clock calibration out.
 467:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *          - WKUP pin 1 (PA0) if enabled.
 468:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @note The Wakeup flag (WUF) need to be cleared at application level before to call this functio
 469:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @param  None
 470:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @retval None
 471:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 472:.\StdPeriphLib\src/stm32f0xx_pwr.c **** void PWR_EnterSTANDBYMode(void)
 473:.\StdPeriphLib\src/stm32f0xx_pwr.c **** {
 382              		.loc 1 473 0
 383              		.cfi_startproc
 474:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Select STANDBY mode */
 475:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   PWR->CR |= PWR_CR_PDDS;
 384              		.loc 1 475 0
 385 0000 054A     		ldr	r2, .L32
 386 0002 1168     		ldr	r1, [r2]
 387 0004 0223     		mov	r3, #2
 388 0006 0B43     		orr	r3, r1
 389 0008 1360     		str	r3, [r2]
 476:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 477:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex-M0 System Control Register */
 478:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 390              		.loc 1 478 0
 391 000a 044A     		ldr	r2, .L32+4
 392 000c 1169     		ldr	r1, [r2, #16]
 393 000e 0423     		mov	r3, #4
 394 0010 0B43     		orr	r3, r1
 395 0012 1361     		str	r3, [r2, #16]
 396              	.LBB28:
 397              	.LBB29:
 338:.\CMSIS/core_cmInstr.h **** }
 398              		.loc 2 338 0
 399              	@ 338 ".\CMSIS/core_cmInstr.h" 1
 400 0014 30BF     		wfi
 401              	@ 0 "" 2
 402              		.code	16
 403              	.LBE29:
 404              	.LBE28:
 479:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 480:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Request Wait For Interrupt */
 481:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   __WFI();
 482:.\StdPeriphLib\src/stm32f0xx_pwr.c **** }
 405              		.loc 1 482 0
 406              		@ sp needed
 407 0016 7047     		bx	lr
 408              	.L33:
 409              		.align	2
 410              	.L32:
 411 0018 00700040 		.word	1073770496
 412 001c 00ED00E0 		.word	-536810240
 413              		.cfi_endproc
 414              	.LFE40:
 416              		.section	.text.PWR_GetFlagStatus,"ax",%progbits
 417              		.align	2
 418              		.global	PWR_GetFlagStatus
 419              		.code	16
 420              		.thumb_func
 422              	PWR_GetFlagStatus:
 423              	.LFB41:
 483:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 484:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
 485:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @}
 486:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 487:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 488:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /** @defgroup PWR_Group5 Flags management functions
 489:.\StdPeriphLib\src/stm32f0xx_pwr.c ****  *  @brief   Flags management functions 
 490:.\StdPeriphLib\src/stm32f0xx_pwr.c ****  *
 491:.\StdPeriphLib\src/stm32f0xx_pwr.c **** @verbatim
 492:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ==============================================================================
 493:.\StdPeriphLib\src/stm32f0xx_pwr.c ****                        ##### Flags management functions #####
 494:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   ==============================================================================
 495:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 496:.\StdPeriphLib\src/stm32f0xx_pwr.c **** @endverbatim
 497:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @{
 498:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 499:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 500:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
 501:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @brief  Checks whether the specified PWR flag is set or not.
 502:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @param  PWR_FLAG: specifies the flag to check.
 503:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *          This parameter can be one of the following values:
 504:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup
 505:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *                  event was received from the WKUP pin or from the RTC alarm 
 506:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *                  (Alarm A or Alarm B), RTC Tamper event or RTC TimeStamp event.
 507:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_FLAG_SB: StandBy flag. This flag indicates that the 
 508:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *                  system was resumed from StandBy mode.
 509:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD 
 510:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *                  is enabled by the PWR_PVDCmd() function.
 511:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_FLAG_VREFINTRDY: Internal Voltage Reference Ready flag. 
 512:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *                  This flag indicates the state of the internal voltage 
 513:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *                  reference, VREFINT.
 514:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @retval The new state of PWR_FLAG (SET or RESET).
 515:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 516:.\StdPeriphLib\src/stm32f0xx_pwr.c **** FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
 517:.\StdPeriphLib\src/stm32f0xx_pwr.c **** {
 424              		.loc 1 517 0
 425              		.cfi_startproc
 426              	.LVL25:
 518:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   FlagStatus bitstatus = RESET;
 519:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Check the parameters */
 520:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
 521:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 522:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 427              		.loc 1 522 0
 428 0000 034B     		ldr	r3, .L35
 429 0002 5B68     		ldr	r3, [r3, #4]
 430              	.LVL26:
 431 0004 1840     		and	r0, r3
 432              	.LVL27:
 433 0006 431E     		sub	r3, r0, #1
 434 0008 9841     		sbc	r0, r0, r3
 435              	.LVL28:
 523:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   {
 524:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     bitstatus = SET;
 525:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   }
 526:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   else
 527:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   {
 528:.\StdPeriphLib\src/stm32f0xx_pwr.c ****     bitstatus = RESET;
 529:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   }
 530:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Return the flag status */
 531:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   return bitstatus;
 436              		.loc 1 531 0
 437 000a C0B2     		uxtb	r0, r0
 532:.\StdPeriphLib\src/stm32f0xx_pwr.c **** }
 438              		.loc 1 532 0
 439              		@ sp needed
 440 000c 7047     		bx	lr
 441              	.L36:
 442 000e C046     		.align	2
 443              	.L35:
 444 0010 00700040 		.word	1073770496
 445              		.cfi_endproc
 446              	.LFE41:
 448              		.section	.text.PWR_ClearFlag,"ax",%progbits
 449              		.align	2
 450              		.global	PWR_ClearFlag
 451              		.code	16
 452              		.thumb_func
 454              	PWR_ClearFlag:
 455              	.LFB42:
 533:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 534:.\StdPeriphLib\src/stm32f0xx_pwr.c **** /**
 535:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @brief  Clears the PWR's pending flags.
 536:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @param  PWR_FLAG: specifies the flag to clear.
 537:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *          This parameter can be one of the following values:
 538:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_FLAG_WU: Wake Up flag
 539:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   *             @arg PWR_FLAG_SB: StandBy flag
 540:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   * @retval None
 541:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   */
 542:.\StdPeriphLib\src/stm32f0xx_pwr.c **** void PWR_ClearFlag(uint32_t PWR_FLAG)
 543:.\StdPeriphLib\src/stm32f0xx_pwr.c **** {
 456              		.loc 1 543 0
 457              		.cfi_startproc
 458              	.LVL29:
 544:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   /* Check the parameters */
 545:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
 546:.\StdPeriphLib\src/stm32f0xx_pwr.c **** 
 547:.\StdPeriphLib\src/stm32f0xx_pwr.c ****   PWR->CR |=  PWR_FLAG << 2;
 459              		.loc 1 547 0
 460 0000 024A     		ldr	r2, .L38
 461 0002 1368     		ldr	r3, [r2]
 462 0004 8000     		lsl	r0, r0, #2
 463              	.LVL30:
 464 0006 1843     		orr	r0, r3
 465 0008 1060     		str	r0, [r2]
 548:.\StdPeriphLib\src/stm32f0xx_pwr.c **** }
 466              		.loc 1 548 0
 467              		@ sp needed
 468 000a 7047     		bx	lr
 469              	.L39:
 470              		.align	2
 471              	.L38:
 472 000c 00700040 		.word	1073770496
 473              		.cfi_endproc
 474              	.LFE42:
 476              		.text
 477              	.Letext0:
 478              		.file 3 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 479              		.file 4 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 480              		.file 5 ".\\CMSIS/core_cm0.h"
 481              		.file 6 ".\\CMSIS/stm32f0xx.h"
 482              		.file 7 ".\\StdPeriphLib\\inc/stm32f0xx_rcc.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f0xx_pwr.c
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:18     .text.PWR_DeInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:23     .text.PWR_DeInit:00000000 PWR_DeInit
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:52     .text.PWR_BackupAccessCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:57     .text.PWR_BackupAccessCmd:00000000 PWR_BackupAccessCmd
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:87     .text.PWR_BackupAccessCmd:00000020 $d
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:93     .text.PWR_PVDLevelConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:98     .text.PWR_PVDLevelConfig:00000000 PWR_PVDLevelConfig
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:122    .text.PWR_PVDLevelConfig:00000010 $d
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:127    .text.PWR_PVDCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:132    .text.PWR_PVDCmd:00000000 PWR_PVDCmd
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:161    .text.PWR_PVDCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:166    .text.PWR_WakeUpPinCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:171    .text.PWR_WakeUpPinCmd:00000000 PWR_WakeUpPinCmd
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:201    .text.PWR_WakeUpPinCmd:00000018 $d
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:206    .text.PWR_EnterSleepMode:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:211    .text.PWR_EnterSleepMode:00000000 PWR_EnterSleepMode
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:270    .text.PWR_EnterSleepMode:0000001c $d
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:275    .text.PWR_EnterSTOPMode:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:280    .text.PWR_EnterSTOPMode:00000000 PWR_EnterSTOPMode
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:369    .text.PWR_EnterSTOPMode:00000048 $d
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:375    .text.PWR_EnterSTANDBYMode:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:380    .text.PWR_EnterSTANDBYMode:00000000 PWR_EnterSTANDBYMode
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:411    .text.PWR_EnterSTANDBYMode:00000018 $d
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:417    .text.PWR_GetFlagStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:422    .text.PWR_GetFlagStatus:00000000 PWR_GetFlagStatus
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:444    .text.PWR_GetFlagStatus:00000010 $d
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:449    .text.PWR_ClearFlag:00000000 $t
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:454    .text.PWR_ClearFlag:00000000 PWR_ClearFlag
C:\Users\Dima\AppData\Local\Temp\ccrIiSuc.s:472    .text.PWR_ClearFlag:0000000c $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
RCC_APB1PeriphResetCmd
