   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"stm32f0xx_rcc.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.RCC_DeInit,"ax",%progbits
  18              		.align	2
  19              		.global	RCC_DeInit
  20              		.code	16
  21              		.thumb_func
  23              	RCC_DeInit:
  24              	.LFB33:
  25              		.file 1 ".\\StdPeriphLib\\src/stm32f0xx_rcc.c"
   1:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
   2:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   ******************************************************************************
   3:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @file    stm32f0xx_rcc.c
   4:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @author  MCD Application Team
   5:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @version V1.5.0
   6:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @date    05-December-2014
   7:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief   This file provides firmware functions to manage the following 
   8:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          functionalities of the Reset and clock control (RCC) peripheral:
   9:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           + Internal/external clocks, PLL, CSS and MCO configuration
  10:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           + System, AHB and APB busses clocks configuration
  11:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           + Peripheral clocks configuration
  12:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           + Interrupts and flags management
  13:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *
  14:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  @verbatim
  15:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  16:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  ===============================================================================
  17:.\StdPeriphLib\src/stm32f0xx_rcc.c ****                         ##### RCC specific features #####
  18:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  ===============================================================================
  19:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     [..] After reset the device is running from HSI (8 MHz) with Flash 0 WS, 
  20:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          all peripherals are off except internal SRAM, Flash and SWD.
  21:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) There is no prescaler on High speed (AHB) and Low speed (APB) busses;
  22:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              all peripherals mapped on these busses are running at HSI speed.
  23:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) The clock for all peripherals is switched off, except the SRAM and FLASH.
  24:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) All GPIOs are in input floating state, except the SWD pins which
  25:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              are assigned to be used for debug purpose.
  26:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     [..] Once the device started from reset, the user application has to:
  27:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) Configure the clock source to be used to drive the System clock
  28:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              (if the application needs higher frequency/performance)
  29:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) Configure the System clock frequency and Flash settings
  30:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) Configure the AHB and APB busses prescalers
  31:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) Enable the clock for the peripheral(s) to be used
  32:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) Configure the clock source(s) for peripherals which clocks are not
  33:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              derived from the System clock (ADC, CEC, I2C, USART, RTC and IWDG)
  34:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  35:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  @endverbatim
  36:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
  37:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   ******************************************************************************
  38:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @attention
  39:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *
  40:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  41:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *
  42:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  43:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * You may not use this file except in compliance with the License.
  44:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * You may obtain a copy of the License at:
  45:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *
  46:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  47:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *
  48:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * Unless required by applicable law or agreed to in writing, software 
  49:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  50:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  51:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * See the License for the specific language governing permissions and
  52:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * limitations under the License.
  53:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *
  54:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   ******************************************************************************
  55:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
  56:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  57:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /* Includes ------------------------------------------------------------------*/
  58:.\StdPeriphLib\src/stm32f0xx_rcc.c **** #include "stm32f0xx_rcc.h"
  59:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  60:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /** @addtogroup STM32F0xx_StdPeriph_Driver
  61:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @{
  62:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
  63:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  64:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /** @defgroup RCC 
  65:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief RCC driver modules
  66:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @{
  67:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */ 
  68:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  69:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /* Private typedef -----------------------------------------------------------*/
  70:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /* Private define ------------------------------------------------------------*/
  71:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  72:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /* ---------------------- RCC registers mask -------------------------------- */
  73:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /* RCC Flag Mask */
  74:.\StdPeriphLib\src/stm32f0xx_rcc.c **** #define FLAG_MASK                 ((uint8_t)0x1F)
  75:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  76:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /* CR register byte 2 (Bits[23:16]) base address */
  77:.\StdPeriphLib\src/stm32f0xx_rcc.c **** #define CR_BYTE2_ADDRESS          ((uint32_t)0x40021002)
  78:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  79:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /* CFGR register byte 3 (Bits[31:23]) base address */
  80:.\StdPeriphLib\src/stm32f0xx_rcc.c **** #define CFGR_BYTE3_ADDRESS        ((uint32_t)0x40021007)
  81:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  82:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /* CIR register byte 1 (Bits[15:8]) base address */
  83:.\StdPeriphLib\src/stm32f0xx_rcc.c **** #define CIR_BYTE1_ADDRESS         ((uint32_t)0x40021009)
  84:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  85:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /* CIR register byte 2 (Bits[23:16]) base address */
  86:.\StdPeriphLib\src/stm32f0xx_rcc.c **** #define CIR_BYTE2_ADDRESS         ((uint32_t)0x4002100A)
  87:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  88:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /* Private macro -------------------------------------------------------------*/
  89:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /* Private variables ---------------------------------------------------------*/
  90:.\StdPeriphLib\src/stm32f0xx_rcc.c **** static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
  91:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  92:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /* Private function prototypes -----------------------------------------------*/
  93:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /* Private functions ---------------------------------------------------------*/
  94:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  95:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /** @defgroup RCC_Private_Functions
  96:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @{
  97:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
  98:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
  99:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /** @defgroup RCC_Group1 Internal and external clocks, PLL, CSS and MCO configuration functions
 100:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  *  @brief   Internal and external clocks, PLL, CSS and MCO configuration functions 
 101:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  *
 102:.\StdPeriphLib\src/stm32f0xx_rcc.c **** @verbatim
 103:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  ===============================================================================
 104:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  ##### Internal-external clocks, PLL, CSS and MCO configuration functions #####
 105:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  ===============================================================================
 106:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     [..] This section provides functions allowing to configure the internal/external clocks,
 107:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          PLL, CSS and MCO.
 108:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) HSI (high-speed internal), 8 MHz factory-trimmed RC used directly 
 109:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              or through the PLL as System clock source.
 110:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              The HSI clock can be used also to clock the USART, I2C and CEC peripherals.
 111:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) HSI14 (high-speed internal for ADC), 14 MHz factory-trimmed RC used to clock
 112:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              the ADC peripheral.
 113:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) LSI (low-speed internal), 40 KHz low consumption RC used as IWDG and/or RTC
 114:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              clock source.
 115:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) HSE (high-speed external), 4 to 32 MHz crystal oscillator used directly or
 116:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              through the PLL as System clock source. Can be used also as RTC clock source.
 117:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source. 
 118:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              LSE can be used also to clock the USART and CEC peripherals.   
 119:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) PLL (clocked by HSI or HSE), for System clock.
 120:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) CSS (Clock security system), once enabled and if a HSE clock failure occurs 
 121:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              (HSE used directly or through PLL as System clock source), the System clock
 122:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              is automatically switched to HSI and an interrupt is generated if enabled. 
 123:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              The interrupt is linked to the Cortex-M0 NMI (Non-Maskable Interrupt) 
 124:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              exception vector.   
 125:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) MCO (microcontroller clock output), used to output SYSCLK, HSI, HSI14, LSI,
 126:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              HSE, LSE or PLL (divided by 2) clock on PA8 pin.
 127:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 128:.\StdPeriphLib\src/stm32f0xx_rcc.c **** @endverbatim
 129:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @{
 130:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 131:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 132:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 133:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Resets the RCC clock configuration to the default reset state.
 134:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The default reset state of the clock configuration is given below:
 135:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note      HSI ON and used as system clock source 
 136:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note      HSI14, HSE and PLL OFF
 137:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note      AHB, APB prescaler set to 1.
 138:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note      CSS and MCO OFF
 139:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note      All interrupts disabled
 140:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   However, this function doesn't modify the configuration of the
 141:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note      Peripheral clocks
 142:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note      LSI, LSE and RTC clocks
 143:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  None
 144:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 145:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 146:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_DeInit(void)
 147:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
  26              		.loc 1 147 0
  27              		.cfi_startproc
 148:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set HSION bit */
 149:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CR |= (uint32_t)0x00000001;
  28              		.loc 1 149 0
  29 0000 114B     		ldr	r3, .L2
  30 0002 1A68     		ldr	r2, [r3]
  31 0004 0121     		mov	r1, #1
  32 0006 0A43     		orr	r2, r1
  33 0008 1A60     		str	r2, [r3]
 150:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 151:.\StdPeriphLib\src/stm32f0xx_rcc.c **** #if defined (STM32F051)
 152:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Reset SW[1:0], HPRE[3:0], PPRE[2:0] and MCOSEL[2:0] bits */
 153:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR &= (uint32_t)0xF8FFB80C;
 154:.\StdPeriphLib\src/stm32f0xx_rcc.c **** #else
 155:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */
 156:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR &= (uint32_t)0x08FFB80C;
  34              		.loc 1 156 0
  35 000a 5868     		ldr	r0, [r3, #4]
  36 000c 0F4A     		ldr	r2, .L2+4
  37 000e 0240     		and	r2, r0
  38 0010 5A60     		str	r2, [r3, #4]
 157:.\StdPeriphLib\src/stm32f0xx_rcc.c **** #endif /* STM32F051 */
 158:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 159:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Reset HSEON, CSSON and PLLON bits */
 160:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CR &= (uint32_t)0xFEF6FFFF;
  39              		.loc 1 160 0
  40 0012 1868     		ldr	r0, [r3]
  41 0014 0E4A     		ldr	r2, .L2+8
  42 0016 0240     		and	r2, r0
  43 0018 1A60     		str	r2, [r3]
 161:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 162:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Reset HSEBYP bit */
 163:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CR &= (uint32_t)0xFFFBFFFF;
  44              		.loc 1 163 0
  45 001a 1868     		ldr	r0, [r3]
  46 001c 0D4A     		ldr	r2, .L2+12
  47 001e 0240     		and	r2, r0
  48 0020 1A60     		str	r2, [r3]
 164:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 165:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
 166:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR &= (uint32_t)0xFFC0FFFF;
  49              		.loc 1 166 0
  50 0022 5868     		ldr	r0, [r3, #4]
  51 0024 0C4A     		ldr	r2, .L2+16
  52 0026 0240     		and	r2, r0
  53 0028 5A60     		str	r2, [r3, #4]
 167:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 168:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Reset PREDIV1[3:0] bits */
 169:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
  54              		.loc 1 169 0
  55 002a DA6A     		ldr	r2, [r3, #44]
  56 002c 0F20     		mov	r0, #15
  57 002e 8243     		bic	r2, r0
  58 0030 DA62     		str	r2, [r3, #44]
 170:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 171:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Reset USARTSW[1:0], I2CSW, CECSW and ADCSW bits */
 172:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR3 &= (uint32_t)0xFFF0FEAC;
  59              		.loc 1 172 0
  60 0032 186B     		ldr	r0, [r3, #48]
  61 0034 094A     		ldr	r2, .L2+20
  62 0036 0240     		and	r2, r0
  63 0038 1A63     		str	r2, [r3, #48]
 173:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 174:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Reset HSI14 bit */
 175:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CR2 &= (uint32_t)0xFFFFFFFE;
  64              		.loc 1 175 0
  65 003a 5A6B     		ldr	r2, [r3, #52]
  66 003c 8A43     		bic	r2, r1
  67 003e 5A63     		str	r2, [r3, #52]
 176:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 177:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Disable all interrupts */
 178:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CIR = 0x00000000;
  68              		.loc 1 178 0
  69 0040 0022     		mov	r2, #0
  70 0042 9A60     		str	r2, [r3, #8]
 179:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
  71              		.loc 1 179 0
  72              		@ sp needed
  73 0044 7047     		bx	lr
  74              	.L3:
  75 0046 C046     		.align	2
  76              	.L2:
  77 0048 00100240 		.word	1073876992
  78 004c 0CB8FF08 		.word	150976524
  79 0050 FFFFF6FE 		.word	-17367041
  80 0054 FFFFFBFF 		.word	-262145
  81 0058 FFFFC0FF 		.word	-4128769
  82 005c ACFEF0FF 		.word	-983380
  83              		.cfi_endproc
  84              	.LFE33:
  86              		.section	.text.RCC_HSEConfig,"ax",%progbits
  87              		.align	2
  88              		.global	RCC_HSEConfig
  89              		.code	16
  90              		.thumb_func
  92              	RCC_HSEConfig:
  93              	.LFB34:
 180:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 181:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 182:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Configures the External High Speed oscillator (HSE).
 183:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
 184:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         software should wait on HSERDY flag to be set indicating that HSE clock
 185:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         is stable and can be used to clock the PLL and/or system clock.
 186:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   HSE state can not be changed if it is used directly or through the
 187:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         PLL as system clock. In this case, you have to select another source
 188:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         of the system clock then change the HSE state (ex. disable it).
 189:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.
 190:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   This function resets the CSSON bit, so if the Clock security system(CSS)
 191:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         was previously enabled you have to enable it again after calling this
 192:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         function.
 193:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_HSE: specifies the new state of the HSE.
 194:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 195:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
 196:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *                              6 HSE oscillator clock cycles.
 197:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_HSE_ON: turn ON the HSE oscillator
 198:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
 199:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 200:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 201:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_HSEConfig(uint8_t RCC_HSE)
 202:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
  94              		.loc 1 202 0
  95              		.cfi_startproc
  96              	.LVL0:
 203:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 204:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_HSE(RCC_HSE));
 205:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 206:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
 207:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE_OFF;
  97              		.loc 1 207 0
  98 0000 024B     		ldr	r3, .L5
  99 0002 0022     		mov	r2, #0
 100 0004 1A70     		strb	r2, [r3]
 208:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 209:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set the new HSE configuration -------------------------------------------*/
 210:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE;
 101              		.loc 1 210 0
 102 0006 1870     		strb	r0, [r3]
 211:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 212:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 103              		.loc 1 212 0
 104              		@ sp needed
 105 0008 7047     		bx	lr
 106              	.L6:
 107 000a C046     		.align	2
 108              	.L5:
 109 000c 02100240 		.word	1073876994
 110              		.cfi_endproc
 111              	.LFE34:
 113              		.section	.text.RCC_AdjustHSICalibrationValue,"ax",%progbits
 114              		.align	2
 115              		.global	RCC_AdjustHSICalibrationValue
 116              		.code	16
 117              		.thumb_func
 119              	RCC_AdjustHSICalibrationValue:
 120              	.LFB36:
 213:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 214:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 215:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Waits for HSE start-up.
 216:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   This function waits on HSERDY flag to be set and return SUCCESS if 
 217:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         this flag is set, otherwise returns ERROR if the timeout is reached 
 218:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         and this flag is not set. The timeout value is defined by the constant
 219:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         HSE_STARTUP_TIMEOUT in stm32f0xx.h file. You can tailor it depending
 220:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         on the HSE crystal used in your application.
 221:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.
 222:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  None
 223:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval An ErrorStatus enumeration value:
 224:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          - SUCCESS: HSE oscillator is stable and ready to use
 225:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          - ERROR: HSE oscillator not yet ready
 226:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 227:.\StdPeriphLib\src/stm32f0xx_rcc.c **** ErrorStatus RCC_WaitForHSEStartUp(void)
 228:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 229:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   __IO uint32_t StartUpCounter = 0;
 230:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   ErrorStatus status = ERROR;
 231:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   FlagStatus HSEStatus = RESET;
 232:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 233:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Wait till HSE is ready and if timeout is reached exit */
 234:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   do
 235:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 236:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 237:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     StartUpCounter++;  
 238:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 239:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 240:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 241:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 242:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     status = SUCCESS;
 243:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 244:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
 245:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 246:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     status = ERROR;
 247:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }  
 248:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   return (status);
 249:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 250:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 251:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 252:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
 253:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The calibration is used to compensate for the variations in voltage
 254:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         and temperature that influence the frequency of the internal HSI RC.
 255:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         Refer to the Application Note AN4067 for more details on how to  
 256:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         calibrate the HSI.
 257:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  HSICalibrationValue: specifies the HSI calibration trimming value.
 258:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter must be a number between 0 and 0x1F.
 259:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 260:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 261:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
 262:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 121              		.loc 1 262 0
 122              		.cfi_startproc
 123              	.LVL1:
 263:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   uint32_t tmpreg = 0;
 264:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 265:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 266:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
 267:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 268:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg = RCC->CR;
 124              		.loc 1 268 0
 125 0000 034A     		ldr	r2, .L8
 126 0002 1368     		ldr	r3, [r2]
 127              	.LVL2:
 269:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 270:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear HSITRIM[4:0] bits */
 271:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg &= ~RCC_CR_HSITRIM;
 128              		.loc 1 271 0
 129 0004 F821     		mov	r1, #248
 130 0006 8B43     		bic	r3, r1
 131              	.LVL3:
 272:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 273:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
 274:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg |= (uint32_t)HSICalibrationValue << 3;
 132              		.loc 1 274 0
 133 0008 C000     		lsl	r0, r0, #3
 134              	.LVL4:
 135 000a 1843     		orr	r0, r3
 136              	.LVL5:
 275:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 276:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Store the new value */
 277:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CR = tmpreg;
 137              		.loc 1 277 0
 138 000c 1060     		str	r0, [r2]
 278:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 139              		.loc 1 278 0
 140              		@ sp needed
 141 000e 7047     		bx	lr
 142              	.L9:
 143              		.align	2
 144              	.L8:
 145 0010 00100240 		.word	1073876992
 146              		.cfi_endproc
 147              	.LFE36:
 149              		.section	.text.RCC_HSICmd,"ax",%progbits
 150              		.align	2
 151              		.global	RCC_HSICmd
 152              		.code	16
 153              		.thumb_func
 155              	RCC_HSICmd:
 156              	.LFB37:
 279:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 280:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 281:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Enables or disables the Internal High Speed oscillator (HSI).
 282:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   After enabling the HSI, the application software should wait on 
 283:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         HSIRDY flag to be set indicating that HSI clock is stable and can
 284:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         be used to clock the PLL and/or system clock.
 285:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   HSI can not be stopped if it is used directly or through the PLL
 286:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         as system clock. In this case, you have to select another source 
 287:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         of the system clock then stop the HSI.
 288:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes.
 289:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the HSI.
 290:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
 291:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
 292:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         clock cycles.
 293:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 294:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 295:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_HSICmd(FunctionalState NewState)
 296:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 157              		.loc 1 296 0
 158              		.cfi_startproc
 159              	.LVL6:
 297:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 298:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 299:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 300:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 160              		.loc 1 300 0
 161 0000 0028     		cmp	r0, #0
 162 0002 05D0     		beq	.L11
 301:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 302:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CR |= RCC_CR_HSION;
 163              		.loc 1 302 0
 164 0004 054A     		ldr	r2, .L13
 165 0006 1168     		ldr	r1, [r2]
 166 0008 0123     		mov	r3, #1
 167 000a 0B43     		orr	r3, r1
 168 000c 1360     		str	r3, [r2]
 169 000e 04E0     		b	.L10
 170              	.L11:
 303:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 304:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
 305:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 306:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CR &= ~RCC_CR_HSION;
 171              		.loc 1 306 0
 172 0010 024A     		ldr	r2, .L13
 173 0012 1368     		ldr	r3, [r2]
 174 0014 0121     		mov	r1, #1
 175 0016 8B43     		bic	r3, r1
 176 0018 1360     		str	r3, [r2]
 177              	.L10:
 307:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 308:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 178              		.loc 1 308 0
 179              		@ sp needed
 180 001a 7047     		bx	lr
 181              	.L14:
 182              		.align	2
 183              	.L13:
 184 001c 00100240 		.word	1073876992
 185              		.cfi_endproc
 186              	.LFE37:
 188              		.section	.text.RCC_AdjustHSI14CalibrationValue,"ax",%progbits
 189              		.align	2
 190              		.global	RCC_AdjustHSI14CalibrationValue
 191              		.code	16
 192              		.thumb_func
 194              	RCC_AdjustHSI14CalibrationValue:
 195              	.LFB38:
 309:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 310:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 311:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Adjusts the Internal High Speed oscillator for ADC (HSI14) 
 312:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         calibration value.
 313:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The calibration is used to compensate for the variations in voltage
 314:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         and temperature that influence the frequency of the internal HSI RC.
 315:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         Refer to the Application Note AN4067  for more details on how to  
 316:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         calibrate the HSI14.
 317:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  HSI14CalibrationValue: specifies the HSI14 calibration trimming value.
 318:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter must be a number between 0 and 0x1F.
 319:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 320:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 321:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_AdjustHSI14CalibrationValue(uint8_t HSI14CalibrationValue)
 322:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 196              		.loc 1 322 0
 197              		.cfi_startproc
 198              	.LVL7:
 323:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   uint32_t tmpreg = 0;
 324:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 325:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 326:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_HSI14_CALIBRATION_VALUE(HSI14CalibrationValue));
 327:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 328:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg = RCC->CR2;
 199              		.loc 1 328 0
 200 0000 034A     		ldr	r2, .L16
 201 0002 536B     		ldr	r3, [r2, #52]
 202              	.LVL8:
 329:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 330:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear HSI14TRIM[4:0] bits */
 331:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg &= ~RCC_CR2_HSI14TRIM;
 203              		.loc 1 331 0
 204 0004 F821     		mov	r1, #248
 205 0006 8B43     		bic	r3, r1
 206              	.LVL9:
 332:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 333:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set the HSITRIM14[4:0] bits according to HSI14CalibrationValue value */
 334:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg |= (uint32_t)HSI14CalibrationValue << 3;
 207              		.loc 1 334 0
 208 0008 C000     		lsl	r0, r0, #3
 209              	.LVL10:
 210 000a 1843     		orr	r0, r3
 211              	.LVL11:
 335:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 336:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Store the new value */
 337:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CR2 = tmpreg;
 212              		.loc 1 337 0
 213 000c 5063     		str	r0, [r2, #52]
 338:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 214              		.loc 1 338 0
 215              		@ sp needed
 216 000e 7047     		bx	lr
 217              	.L17:
 218              		.align	2
 219              	.L16:
 220 0010 00100240 		.word	1073876992
 221              		.cfi_endproc
 222              	.LFE38:
 224              		.section	.text.RCC_HSI14Cmd,"ax",%progbits
 225              		.align	2
 226              		.global	RCC_HSI14Cmd
 227              		.code	16
 228              		.thumb_func
 230              	RCC_HSI14Cmd:
 231              	.LFB39:
 339:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 340:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 341:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Enables or disables the Internal High Speed oscillator for ADC (HSI14).
 342:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   After enabling the HSI14, the application software should wait on 
 343:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         HSIRDY flag to be set indicating that HSI clock is stable and can
 344:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         be used to clock the ADC.
 345:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The HSI14 is stopped by hardware when entering STOP and STANDBY modes.
 346:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the HSI14.
 347:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
 348:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   When the HSI14 is stopped, HSI14RDY flag goes low after 6 HSI14 oscillator
 349:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         clock cycles.
 350:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 351:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 352:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_HSI14Cmd(FunctionalState NewState)
 353:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 232              		.loc 1 353 0
 233              		.cfi_startproc
 234              	.LVL12:
 354:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 355:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 356:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 357:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 235              		.loc 1 357 0
 236 0000 0028     		cmp	r0, #0
 237 0002 05D0     		beq	.L19
 358:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 359:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CR2 |= RCC_CR2_HSI14ON;
 238              		.loc 1 359 0
 239 0004 054A     		ldr	r2, .L21
 240 0006 516B     		ldr	r1, [r2, #52]
 241 0008 0123     		mov	r3, #1
 242 000a 0B43     		orr	r3, r1
 243 000c 5363     		str	r3, [r2, #52]
 244 000e 04E0     		b	.L18
 245              	.L19:
 360:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 361:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
 362:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 363:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CR2 &= ~RCC_CR2_HSI14ON;
 246              		.loc 1 363 0
 247 0010 024A     		ldr	r2, .L21
 248 0012 536B     		ldr	r3, [r2, #52]
 249 0014 0121     		mov	r1, #1
 250 0016 8B43     		bic	r3, r1
 251 0018 5363     		str	r3, [r2, #52]
 252              	.L18:
 364:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 365:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 253              		.loc 1 365 0
 254              		@ sp needed
 255 001a 7047     		bx	lr
 256              	.L22:
 257              		.align	2
 258              	.L21:
 259 001c 00100240 		.word	1073876992
 260              		.cfi_endproc
 261              	.LFE39:
 263              		.section	.text.RCC_HSI14ADCRequestCmd,"ax",%progbits
 264              		.align	2
 265              		.global	RCC_HSI14ADCRequestCmd
 266              		.code	16
 267              		.thumb_func
 269              	RCC_HSI14ADCRequestCmd:
 270              	.LFB40:
 366:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 367:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 368:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Enables or disables the Internal High Speed oscillator request from ADC.
 369:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the HSI14 ADC request.
 370:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
 371:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 372:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 373:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_HSI14ADCRequestCmd(FunctionalState NewState)
 374:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 271              		.loc 1 374 0
 272              		.cfi_startproc
 273              	.LVL13:
 375:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 376:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 377:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 378:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 274              		.loc 1 378 0
 275 0000 0028     		cmp	r0, #0
 276 0002 05D0     		beq	.L24
 379:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 380:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CR2 &= ~RCC_CR2_HSI14DIS;
 277              		.loc 1 380 0
 278 0004 054A     		ldr	r2, .L26
 279 0006 536B     		ldr	r3, [r2, #52]
 280 0008 0421     		mov	r1, #4
 281 000a 8B43     		bic	r3, r1
 282 000c 5363     		str	r3, [r2, #52]
 283 000e 04E0     		b	.L23
 284              	.L24:
 381:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 382:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
 383:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 384:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CR2 |= RCC_CR2_HSI14DIS;
 285              		.loc 1 384 0
 286 0010 024A     		ldr	r2, .L26
 287 0012 516B     		ldr	r1, [r2, #52]
 288 0014 0423     		mov	r3, #4
 289 0016 0B43     		orr	r3, r1
 290 0018 5363     		str	r3, [r2, #52]
 291              	.L23:
 385:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 386:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 292              		.loc 1 386 0
 293              		@ sp needed
 294 001a 7047     		bx	lr
 295              	.L27:
 296              		.align	2
 297              	.L26:
 298 001c 00100240 		.word	1073876992
 299              		.cfi_endproc
 300              	.LFE40:
 302              		.section	.text.RCC_LSEConfig,"ax",%progbits
 303              		.align	2
 304              		.global	RCC_LSEConfig
 305              		.code	16
 306              		.thumb_func
 308              	RCC_LSEConfig:
 309              	.LFB41:
 387:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 388:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 389:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Configures the External Low Speed oscillator (LSE).
 390:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   As the LSE is in the Backup domain and write access is denied to this
 391:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         domain after reset, you have to enable write access using 
 392:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         PWR_BackupAccessCmd(ENABLE) function before to configure the LSE
 393:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         (to be done once after reset).
 394:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   After enabling the LSE (RCC_LSE_ON or RCC_LSE_Bypass), the application
 395:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         software should wait on LSERDY flag to be set indicating that LSE clock
 396:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         is stable and can be used to clock the RTC.
 397:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_LSE: specifies the new state of the LSE.
 398:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 399:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
 400:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *                              6 LSE oscillator clock cycles.
 401:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_LSE_ON: turn ON the LSE oscillator
 402:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
 403:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 404:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 405:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_LSEConfig(uint32_t RCC_LSE)
 406:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 310              		.loc 1 406 0
 311              		.cfi_startproc
 312              	.LVL14:
 407:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 408:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_LSE(RCC_LSE));
 409:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 410:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
 411:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Reset LSEON bit */
 412:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->BDCR &= ~(RCC_BDCR_LSEON);
 313              		.loc 1 412 0
 314 0000 064B     		ldr	r3, .L29
 315 0002 1A6A     		ldr	r2, [r3, #32]
 316 0004 0121     		mov	r1, #1
 317 0006 8A43     		bic	r2, r1
 318 0008 1A62     		str	r2, [r3, #32]
 413:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 414:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Reset LSEBYP bit */
 415:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->BDCR &= ~(RCC_BDCR_LSEBYP);
 319              		.loc 1 415 0
 320 000a 1A6A     		ldr	r2, [r3, #32]
 321 000c 0331     		add	r1, r1, #3
 322 000e 8A43     		bic	r2, r1
 323 0010 1A62     		str	r2, [r3, #32]
 416:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 417:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Configure LSE */
 418:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->BDCR |= RCC_LSE;
 324              		.loc 1 418 0
 325 0012 1A6A     		ldr	r2, [r3, #32]
 326 0014 1043     		orr	r0, r2
 327              	.LVL15:
 328 0016 1862     		str	r0, [r3, #32]
 419:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 329              		.loc 1 419 0
 330              		@ sp needed
 331 0018 7047     		bx	lr
 332              	.L30:
 333 001a C046     		.align	2
 334              	.L29:
 335 001c 00100240 		.word	1073876992
 336              		.cfi_endproc
 337              	.LFE41:
 339              		.section	.text.RCC_LSEDriveConfig,"ax",%progbits
 340              		.align	2
 341              		.global	RCC_LSEDriveConfig
 342              		.code	16
 343              		.thumb_func
 345              	RCC_LSEDriveConfig:
 346              	.LFB42:
 420:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 421:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 422:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Configures the External Low Speed oscillator (LSE) drive capability.
 423:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_LSEDrive: specifies the new state of the LSE drive capability.
 424:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 425:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_LSEDrive_Low: LSE oscillator low drive capability.
 426:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_LSEDrive_MediumLow: LSE oscillator medium low drive capability.
 427:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_LSEDrive_MediumHigh: LSE oscillator medium high drive capability.
 428:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_LSEDrive_High: LSE oscillator high drive capability.
 429:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 430:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 431:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_LSEDriveConfig(uint32_t RCC_LSEDrive)
 432:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 347              		.loc 1 432 0
 348              		.cfi_startproc
 349              	.LVL16:
 433:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 434:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_LSE_DRIVE(RCC_LSEDrive));
 435:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 436:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear LSEDRV[1:0] bits */
 437:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->BDCR &= ~(RCC_BDCR_LSEDRV);
 350              		.loc 1 437 0
 351 0000 044B     		ldr	r3, .L32
 352 0002 1A6A     		ldr	r2, [r3, #32]
 353 0004 1821     		mov	r1, #24
 354 0006 8A43     		bic	r2, r1
 355 0008 1A62     		str	r2, [r3, #32]
 438:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 439:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set the LSE Drive */
 440:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->BDCR |= RCC_LSEDrive;
 356              		.loc 1 440 0
 357 000a 1A6A     		ldr	r2, [r3, #32]
 358 000c 1043     		orr	r0, r2
 359              	.LVL17:
 360 000e 1862     		str	r0, [r3, #32]
 441:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 361              		.loc 1 441 0
 362              		@ sp needed
 363 0010 7047     		bx	lr
 364              	.L33:
 365 0012 C046     		.align	2
 366              	.L32:
 367 0014 00100240 		.word	1073876992
 368              		.cfi_endproc
 369              	.LFE42:
 371              		.section	.text.RCC_LSICmd,"ax",%progbits
 372              		.align	2
 373              		.global	RCC_LSICmd
 374              		.code	16
 375              		.thumb_func
 377              	RCC_LSICmd:
 378              	.LFB43:
 442:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 443:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 444:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
 445:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   After enabling the LSI, the application software should wait on 
 446:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         LSIRDY flag to be set indicating that LSI clock is stable and can
 447:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         be used to clock the IWDG and/or the RTC.
 448:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   LSI can not be disabled if the IWDG is running.
 449:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the LSI.
 450:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
 451:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
 452:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         clock cycles.
 453:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 454:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 455:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_LSICmd(FunctionalState NewState)
 456:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 379              		.loc 1 456 0
 380              		.cfi_startproc
 381              	.LVL18:
 457:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 458:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 459:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 460:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 382              		.loc 1 460 0
 383 0000 0028     		cmp	r0, #0
 384 0002 05D0     		beq	.L35
 461:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 462:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CSR |= RCC_CSR_LSION;
 385              		.loc 1 462 0
 386 0004 054A     		ldr	r2, .L37
 387 0006 516A     		ldr	r1, [r2, #36]
 388 0008 0123     		mov	r3, #1
 389 000a 0B43     		orr	r3, r1
 390 000c 5362     		str	r3, [r2, #36]
 391 000e 04E0     		b	.L34
 392              	.L35:
 463:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 464:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
 465:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 466:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CSR &= ~RCC_CSR_LSION;
 393              		.loc 1 466 0
 394 0010 024A     		ldr	r2, .L37
 395 0012 536A     		ldr	r3, [r2, #36]
 396 0014 0121     		mov	r1, #1
 397 0016 8B43     		bic	r3, r1
 398 0018 5362     		str	r3, [r2, #36]
 399              	.L34:
 467:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 468:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 400              		.loc 1 468 0
 401              		@ sp needed
 402 001a 7047     		bx	lr
 403              	.L38:
 404              		.align	2
 405              	.L37:
 406 001c 00100240 		.word	1073876992
 407              		.cfi_endproc
 408              	.LFE43:
 410              		.section	.text.RCC_PLLConfig,"ax",%progbits
 411              		.align	2
 412              		.global	RCC_PLLConfig
 413              		.code	16
 414              		.thumb_func
 416              	RCC_PLLConfig:
 417              	.LFB44:
 469:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 470:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 471:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Configures the PLL clock source and multiplication factor.
 472:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   This function must be used only when the PLL is disabled.
 473:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *
 474:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_PLLSource: specifies the PLL entry clock source.
 475:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 476:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock selected as PLL clock source
 477:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_PLLSource_PREDIV1: PREDIV1 clock selected as PLL clock entry
 478:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_PLLSource_HSI48 HSI48 oscillator clock selected as PLL clock source, applic
 479:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_PLLSource_HSI: HSI clock selected as PLL clock entry, applicable only for S
 480:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The minimum input clock frequency for PLL is 2 MHz (when using HSE as
 481:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         PLL source).
 482:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *
 483:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_PLLMul: specifies the PLL multiplication factor, which drive the PLLVCO clock
 484:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be RCC_PLLMul_x where x:[2,16] 
 485:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *
 486:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 487:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 488:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
 489:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 418              		.loc 1 489 0
 419              		.cfi_startproc
 420              	.LVL19:
 421 0000 10B5     		push	{r4, lr}
 422              	.LCFI0:
 423              		.cfi_def_cfa_offset 8
 424              		.cfi_offset 4, -8
 425              		.cfi_offset 14, -4
 490:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 491:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
 492:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
 493:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 494:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear PLL Source [16] and Multiplier [21:18] bits */
 495:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
 426              		.loc 1 495 0
 427 0002 054B     		ldr	r3, .L40
 428 0004 5C68     		ldr	r4, [r3, #4]
 429 0006 054A     		ldr	r2, .L40+4
 430 0008 2240     		and	r2, r4
 431 000a 5A60     		str	r2, [r3, #4]
 496:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 497:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set the PLL Source and Multiplier */
 498:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
 432              		.loc 1 498 0
 433 000c 5A68     		ldr	r2, [r3, #4]
 434 000e 1143     		orr	r1, r2
 435              	.LVL20:
 436 0010 0843     		orr	r0, r1
 437              	.LVL21:
 438 0012 5860     		str	r0, [r3, #4]
 499:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 439              		.loc 1 499 0
 440              		@ sp needed
 441 0014 10BD     		pop	{r4, pc}
 442              	.L41:
 443 0016 C046     		.align	2
 444              	.L40:
 445 0018 00100240 		.word	1073876992
 446 001c FF7FC2FF 		.word	-4030465
 447              		.cfi_endproc
 448              	.LFE44:
 450              		.section	.text.RCC_PLLCmd,"ax",%progbits
 451              		.align	2
 452              		.global	RCC_PLLCmd
 453              		.code	16
 454              		.thumb_func
 456              	RCC_PLLCmd:
 457              	.LFB45:
 500:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 501:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 502:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Enables or disables the PLL.
 503:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   After enabling the PLL, the application software should wait on 
 504:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         PLLRDY flag to be set indicating that PLL clock is stable and can
 505:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         be used as system clock source.
 506:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The PLL can not be disabled if it is used as system clock source
 507:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The PLL is disabled by hardware when entering STOP and STANDBY modes.
 508:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the PLL.
 509:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
 510:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 511:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 512:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_PLLCmd(FunctionalState NewState)
 513:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 458              		.loc 1 513 0
 459              		.cfi_startproc
 460              	.LVL22:
 514:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 515:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 516:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 517:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 461              		.loc 1 517 0
 462 0000 0028     		cmp	r0, #0
 463 0002 06D0     		beq	.L43
 518:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 519:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CR |= RCC_CR_PLLON;
 464              		.loc 1 519 0
 465 0004 064A     		ldr	r2, .L45
 466 0006 1368     		ldr	r3, [r2]
 467 0008 8021     		mov	r1, #128
 468 000a 4904     		lsl	r1, r1, #17
 469 000c 0B43     		orr	r3, r1
 470 000e 1360     		str	r3, [r2]
 471 0010 04E0     		b	.L42
 472              	.L43:
 520:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 521:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
 522:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 523:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CR &= ~RCC_CR_PLLON;
 473              		.loc 1 523 0
 474 0012 034A     		ldr	r2, .L45
 475 0014 1168     		ldr	r1, [r2]
 476 0016 034B     		ldr	r3, .L45+4
 477 0018 0B40     		and	r3, r1
 478 001a 1360     		str	r3, [r2]
 479              	.L42:
 524:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 525:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 480              		.loc 1 525 0
 481              		@ sp needed
 482 001c 7047     		bx	lr
 483              	.L46:
 484 001e C046     		.align	2
 485              	.L45:
 486 0020 00100240 		.word	1073876992
 487 0024 FFFFFFFE 		.word	-16777217
 488              		.cfi_endproc
 489              	.LFE45:
 491              		.section	.text.RCC_HSI48Cmd,"ax",%progbits
 492              		.align	2
 493              		.global	RCC_HSI48Cmd
 494              		.code	16
 495              		.thumb_func
 497              	RCC_HSI48Cmd:
 498              	.LFB46:
 526:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 527:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 528:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Enables or disables the Internal High Speed oscillator for USB (HSI48).
 529:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         This function is only applicable for STM32F072 devices.  
 530:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   After enabling the HSI48, the application software should wait on 
 531:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         HSI48RDY flag to be set indicating that HSI48 clock is stable and can
 532:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         be used to clock the USB.
 533:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The HSI48 is stopped by hardware when entering STOP and STANDBY modes.
 534:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the HSI48.
 535:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
 536:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 537:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 538:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_HSI48Cmd(FunctionalState NewState)
 539:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 499              		.loc 1 539 0
 500              		.cfi_startproc
 501              	.LVL23:
 540:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 541:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 542:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 543:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 502              		.loc 1 543 0
 503 0000 0028     		cmp	r0, #0
 504 0002 06D0     		beq	.L48
 544:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 545:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CR2 |= RCC_CR2_HSI48ON;
 505              		.loc 1 545 0
 506 0004 064A     		ldr	r2, .L50
 507 0006 536B     		ldr	r3, [r2, #52]
 508 0008 8021     		mov	r1, #128
 509 000a 4902     		lsl	r1, r1, #9
 510 000c 0B43     		orr	r3, r1
 511 000e 5363     		str	r3, [r2, #52]
 512 0010 04E0     		b	.L47
 513              	.L48:
 546:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 547:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
 548:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 549:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CR2 &= ~RCC_CR2_HSI48ON;
 514              		.loc 1 549 0
 515 0012 034A     		ldr	r2, .L50
 516 0014 516B     		ldr	r1, [r2, #52]
 517 0016 034B     		ldr	r3, .L50+4
 518 0018 0B40     		and	r3, r1
 519 001a 5363     		str	r3, [r2, #52]
 520              	.L47:
 550:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 551:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 521              		.loc 1 551 0
 522              		@ sp needed
 523 001c 7047     		bx	lr
 524              	.L51:
 525 001e C046     		.align	2
 526              	.L50:
 527 0020 00100240 		.word	1073876992
 528 0024 FFFFFEFF 		.word	-65537
 529              		.cfi_endproc
 530              	.LFE46:
 532              		.section	.text.RCC_PREDIV1Config,"ax",%progbits
 533              		.align	2
 534              		.global	RCC_PREDIV1Config
 535              		.code	16
 536              		.thumb_func
 538              	RCC_PREDIV1Config:
 539              	.LFB47:
 552:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 553:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 554:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Configures the PREDIV1 division factor.
 555:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   This function must be used only when the PLL is disabled.
 556:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_PREDIV1_Div: specifies the PREDIV1 clock division factor.
 557:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be RCC_PREDIV1_Divx where x:[1,16]
 558:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 559:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 560:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Div)
 561:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 540              		.loc 1 561 0
 541              		.cfi_startproc
 542              	.LVL24:
 562:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   uint32_t tmpreg = 0;
 563:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 564:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 565:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
 566:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 567:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg = RCC->CFGR2;
 543              		.loc 1 567 0
 544 0000 034A     		ldr	r2, .L53
 545 0002 D36A     		ldr	r3, [r2, #44]
 546              	.LVL25:
 568:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear PREDIV1[3:0] bits */
 569:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg &= ~(RCC_CFGR2_PREDIV1);
 547              		.loc 1 569 0
 548 0004 0F21     		mov	r1, #15
 549 0006 8B43     		bic	r3, r1
 550              	.LVL26:
 570:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set the PREDIV1 division factor */
 571:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg |= RCC_PREDIV1_Div;
 551              		.loc 1 571 0
 552 0008 1843     		orr	r0, r3
 553              	.LVL27:
 572:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Store the new value */
 573:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR2 = tmpreg;
 554              		.loc 1 573 0
 555 000a D062     		str	r0, [r2, #44]
 574:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 556              		.loc 1 574 0
 557              		@ sp needed
 558 000c 7047     		bx	lr
 559              	.L54:
 560 000e C046     		.align	2
 561              	.L53:
 562 0010 00100240 		.word	1073876992
 563              		.cfi_endproc
 564              	.LFE47:
 566              		.section	.text.RCC_ClockSecuritySystemCmd,"ax",%progbits
 567              		.align	2
 568              		.global	RCC_ClockSecuritySystemCmd
 569              		.code	16
 570              		.thumb_func
 572              	RCC_ClockSecuritySystemCmd:
 573              	.LFB48:
 575:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 576:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 577:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Enables or disables the Clock Security System.
 578:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   If a failure is detected on the HSE oscillator clock, this oscillator
 579:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         is automatically disabled and an interrupt is generated to inform the
 580:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         software about the failure (Clock Security System Interrupt, CSSI),
 581:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         allowing the MCU to perform rescue operations. The CSSI is linked to 
 582:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         the Cortex-M0 NMI (Non-Maskable Interrupt) exception vector.
 583:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the Clock Security System.
 584:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
 585:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 586:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 587:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
 588:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 574              		.loc 1 588 0
 575              		.cfi_startproc
 576              	.LVL28:
 589:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 590:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 591:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 592:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 577              		.loc 1 592 0
 578 0000 0028     		cmp	r0, #0
 579 0002 06D0     		beq	.L56
 593:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 594:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CR |= RCC_CR_CSSON;
 580              		.loc 1 594 0
 581 0004 064A     		ldr	r2, .L58
 582 0006 1368     		ldr	r3, [r2]
 583 0008 8021     		mov	r1, #128
 584 000a 0903     		lsl	r1, r1, #12
 585 000c 0B43     		orr	r3, r1
 586 000e 1360     		str	r3, [r2]
 587 0010 04E0     		b	.L55
 588              	.L56:
 595:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 596:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
 597:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 598:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CR &= ~RCC_CR_CSSON;
 589              		.loc 1 598 0
 590 0012 034A     		ldr	r2, .L58
 591 0014 1168     		ldr	r1, [r2]
 592 0016 034B     		ldr	r3, .L58+4
 593 0018 0B40     		and	r3, r1
 594 001a 1360     		str	r3, [r2]
 595              	.L55:
 599:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 600:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 596              		.loc 1 600 0
 597              		@ sp needed
 598 001c 7047     		bx	lr
 599              	.L59:
 600 001e C046     		.align	2
 601              	.L58:
 602 0020 00100240 		.word	1073876992
 603 0024 FFFFF7FF 		.word	-524289
 604              		.cfi_endproc
 605              	.LFE48:
 607              		.section	.text.RCC_MCOConfig,"ax",%progbits
 608              		.align	2
 609              		.global	RCC_MCOConfig
 610              		.code	16
 611              		.thumb_func
 613              	RCC_MCOConfig:
 614              	.LFB49:
 601:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 602:.\StdPeriphLib\src/stm32f0xx_rcc.c **** #ifdef STM32F051
 603:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 604:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Selects the clock source to output on MCO pin (PA8).
 605:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   PA8 should be configured in alternate function mode.
 606:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_MCOSource: specifies the clock source to output.
 607:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 608:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_NoClock: No clock selected.
 609:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_HSI14: HSI14 oscillator clock selected.
 610:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_LSI: LSI oscillator clock selected.
 611:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_LSE: LSE oscillator clock selected.
 612:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_SYSCLK: System clock selected.
 613:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_HSI: HSI oscillator clock selected.
 614:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_HSE: HSE oscillator clock selected.
 615:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_PLLCLK_Div2: PLL clock divided by 2 selected.
 616:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 617:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 618:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_MCOConfig(uint8_t RCC_MCOSource)
 619:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 620:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 621:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
 622:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 623:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Select MCO clock source and prescaler */
 624:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *(__IO uint8_t *) CFGR_BYTE3_ADDRESS =  RCC_MCOSource;
 625:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 626:.\StdPeriphLib\src/stm32f0xx_rcc.c **** #else
 627:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 628:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 629:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Selects the clock source to output on MCO pin (PA8) and the corresponding
 630:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         prescsaler.
 631:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   PA8 should be configured in alternate function mode.
 632:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_MCOSource: specifies the clock source to output.
 633:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 634:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_NoClock: No clock selected.
 635:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_HSI14: HSI14 oscillator clock selected.
 636:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_LSI: LSI oscillator clock selected.
 637:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_LSE: LSE oscillator clock selected.
 638:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_SYSCLK: System clock selected.
 639:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_HSI: HSI oscillator clock selected.
 640:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_HSE: HSE oscillator clock selected.
 641:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_PLLCLK_Div2: PLL clock divided by 2 selected.
 642:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_PLLCLK: PLL clock selected.
 643:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOSource_HSI48: HSI48 clock selected.
 644:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_MCOPrescaler: specifies the prescaler on MCO pin.
 645:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 646:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOPrescaler_1: MCO clock is divided by 1.
 647:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOPrescaler_2: MCO clock is divided by 2.
 648:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOPrescaler_4: MCO clock is divided by 4.
 649:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOPrescaler_8: MCO clock is divided by 8.
 650:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOPrescaler_16: MCO clock is divided by 16.
 651:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOPrescaler_32: MCO clock is divided by 32.
 652:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOPrescaler_64: MCO clock is divided by 64.
 653:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_MCOPrescaler_128: MCO clock is divided by 128.    
 654:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 655:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 656:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_MCOConfig(uint8_t RCC_MCOSource, uint32_t RCC_MCOPrescaler)
 657:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 615              		.loc 1 657 0
 616              		.cfi_startproc
 617              	.LVL29:
 658:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   uint32_t tmpreg = 0;
 659:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 660:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 661:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
 662:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_MCO_PRESCALER(RCC_MCOPrescaler));
 663:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     
 664:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Get CFGR value */  
 665:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg = RCC->CFGR;
 618              		.loc 1 665 0
 619 0000 044A     		ldr	r2, .L61
 620 0002 5368     		ldr	r3, [r2, #4]
 621              	.LVL30:
 666:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear MCOPRE[2:0] bits */
 667:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg &= ~(RCC_CFGR_MCO_PRE | RCC_CFGR_MCO | RCC_CFGR_PLLNODIV);
 622              		.loc 1 667 0
 623 0004 1B02     		lsl	r3, r3, #8
 624              	.LVL31:
 625 0006 1B0A     		lsr	r3, r3, #8
 626 0008 1943     		orr	r1, r3
 627              	.LVL32:
 668:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set the RCC_MCOSource and RCC_MCOPrescaler */
 669:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg |= (RCC_MCOPrescaler | ((uint32_t)RCC_MCOSource<<24));
 628              		.loc 1 669 0
 629 000a 0006     		lsl	r0, r0, #24
 630              	.LVL33:
 631 000c 0143     		orr	r1, r0
 632              	.LVL34:
 670:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Store the new value */
 671:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR = tmpreg;
 633              		.loc 1 671 0
 634 000e 5160     		str	r1, [r2, #4]
 672:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 635              		.loc 1 672 0
 636              		@ sp needed
 637 0010 7047     		bx	lr
 638              	.L62:
 639 0012 C046     		.align	2
 640              	.L61:
 641 0014 00100240 		.word	1073876992
 642              		.cfi_endproc
 643              	.LFE49:
 645              		.section	.text.RCC_SYSCLKConfig,"ax",%progbits
 646              		.align	2
 647              		.global	RCC_SYSCLKConfig
 648              		.code	16
 649              		.thumb_func
 651              	RCC_SYSCLKConfig:
 652              	.LFB50:
 673:.\StdPeriphLib\src/stm32f0xx_rcc.c **** #endif /* STM32F072 */
 674:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 675:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 676:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @}
 677:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 678:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 679:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /** @defgroup RCC_Group2 System AHB and APB busses clocks configuration functions
 680:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  *  @brief   System, AHB and APB busses clocks configuration functions
 681:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  *
 682:.\StdPeriphLib\src/stm32f0xx_rcc.c **** @verbatim
 683:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  ===============================================================================
 684:.\StdPeriphLib\src/stm32f0xx_rcc.c ****      ##### System, AHB and APB busses clocks configuration functions #####
 685:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  ===============================================================================
 686:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 687:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     [..] This section provide functions allowing to configure the System, AHB and 
 688:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          APB busses clocks.
 689:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,
 690:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              HSE and PLL.
 691:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              The AHB clock (HCLK) is derived from System clock through configurable prescaler
 692:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              and used to clock the CPU, memory and peripherals mapped on AHB bus (DMA and GPIO).
 693:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              and APB (PCLK) clocks are derived from AHB clock through 
 694:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              configurable prescalers and used to clock the peripherals mapped on these busses.
 695:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              You can use "RCC_GetClocksFreq()" function to retrieve the frequencies of these clocks
 696:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 697:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
 698:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              (+@) The ADC clock which is derived from HSI14 or APB (APB divided by a
 699:.\StdPeriphLib\src/stm32f0xx_rcc.c ****                   programmable prescaler: 2 or 4).
 700:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              (+@) The CEC clock which is derived from LSE or HSI divided by 244.
 701:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              (+@) The I2C clock which is derived from HSI or system clock (SYSCLK).
 702:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              (+@) The USART clock which is derived from HSI, system clock (SYSCLK), APB or LSE.
 703:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              (+@) The RTC/LCD clock which is derived from the LSE, LSI or 2 MHz HSE_RTC (HSE
 704:.\StdPeriphLib\src/stm32f0xx_rcc.c ****                   divided by a programmable prescaler).
 705:.\StdPeriphLib\src/stm32f0xx_rcc.c ****                   The System clock (SYSCLK) frequency must be higher or equal to the RTC/LCD
 706:.\StdPeriphLib\src/stm32f0xx_rcc.c ****                   clock frequency.
 707:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              (+@) IWDG clock which is always the LSI clock.
 708:.\StdPeriphLib\src/stm32f0xx_rcc.c ****        
 709:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) The maximum frequency of the SYSCLK, HCLK and PCLK is 48 MHz.
 710:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              Depending on the maximum frequency, the FLASH wait states (WS) should be 
 711:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              adapted accordingly:
 712:.\StdPeriphLib\src/stm32f0xx_rcc.c ****         +--------------------------------------------- +
 713:.\StdPeriphLib\src/stm32f0xx_rcc.c ****         |  Wait states  |   HCLK clock frequency (MHz) |
 714:.\StdPeriphLib\src/stm32f0xx_rcc.c ****         |---------------|------------------------------|
 715:.\StdPeriphLib\src/stm32f0xx_rcc.c ****         |0WS(1CPU cycle)|       0 < HCLK <= 24         |
 716:.\StdPeriphLib\src/stm32f0xx_rcc.c ****         |---------------|------------------------------|
 717:.\StdPeriphLib\src/stm32f0xx_rcc.c ****         |1WS(2CPU cycle)|       24 < HCLK <= 48        |
 718:.\StdPeriphLib\src/stm32f0xx_rcc.c ****         +----------------------------------------------+
 719:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 720:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) After reset, the System clock source is the HSI (8 MHz) with 0 WS and 
 721:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              prefetch is disabled.
 722:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 723:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     [..] It is recommended to use the following software sequences to tune the number
 724:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          of wait states needed to access the Flash memory with the CPU frequency (HCLK).
 725:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (+) Increasing the CPU frequency
 726:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (++) Program the Flash Prefetch buffer, using "FLASH_PrefetchBufferCmd(ENABLE)" 
 727:.\StdPeriphLib\src/stm32f0xx_rcc.c ****               function
 728:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (++) Check that Flash Prefetch buffer activation is taken into account by 
 729:.\StdPeriphLib\src/stm32f0xx_rcc.c ****               reading FLASH_ACR using the FLASH_GetPrefetchBufferStatus() function
 730:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (++) Program Flash WS to 1, using "FLASH_SetLatency(FLASH_Latency_1)" function
 731:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (++) Check that the new number of WS is taken into account by reading FLASH_ACR
 732:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (++) Modify the CPU clock source, using "RCC_SYSCLKConfig()" function
 733:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (++) If needed, modify the CPU clock prescaler by using "RCC_HCLKConfig()" function
 734:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (++) Check that the new CPU clock source is taken into account by reading 
 735:.\StdPeriphLib\src/stm32f0xx_rcc.c ****               the clock source status, using "RCC_GetSYSCLKSource()" function 
 736:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (+) Decreasing the CPU frequency
 737:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (++) Modify the CPU clock source, using "RCC_SYSCLKConfig()" function
 738:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (++) If needed, modify the CPU clock prescaler by using "RCC_HCLKConfig()" function
 739:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (++) Check that the new CPU clock source is taken into account by reading 
 740:.\StdPeriphLib\src/stm32f0xx_rcc.c ****               the clock source status, using "RCC_GetSYSCLKSource()" function
 741:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (++) Program the new number of WS, using "FLASH_SetLatency()" function
 742:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (++) Check that the new number of WS is taken into account by reading FLASH_ACR
 743:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (++) Disable the Flash Prefetch buffer using "FLASH_PrefetchBufferCmd(DISABLE)" 
 744:.\StdPeriphLib\src/stm32f0xx_rcc.c ****               function
 745:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (++) Check that Flash Prefetch buffer deactivation is taken into account by reading FLASH_
 746:.\StdPeriphLib\src/stm32f0xx_rcc.c ****               using the FLASH_GetPrefetchBufferStatus() function.
 747:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 748:.\StdPeriphLib\src/stm32f0xx_rcc.c **** @endverbatim
 749:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @{
 750:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 751:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 752:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 753:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Configures the system clock (SYSCLK).
 754:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The HSI is used (enabled by hardware) as system clock source after
 755:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         startup from Reset, wake-up from STOP and STANDBY mode, or in case
 756:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         of failure of the HSE used directly or indirectly as system clock
 757:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         (if the Clock Security System CSS is enabled).
 758:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   A switch from one clock source to another occurs only if the target
 759:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         clock source is ready (clock stable after startup delay or PLL locked). 
 760:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         If a clock source which is not yet ready is selected, the switch will
 761:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         occur when the clock source will be ready. 
 762:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         You can use RCC_GetSYSCLKSource() function to know which clock is
 763:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         currently used as system clock source.  
 764:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_SYSCLKSource: specifies the clock source used as system clock source 
 765:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 766:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_SYSCLKSource_HSI:    HSI selected as system clock source
 767:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
 768:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
 769:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_SYSCLKSource_HSI48:  HSI48 selected as system clock source, applicable only
 770:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 771:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 772:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
 773:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 653              		.loc 1 773 0
 654              		.cfi_startproc
 655              	.LVL35:
 774:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   uint32_t tmpreg = 0;
 775:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 776:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 777:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
 778:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 779:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg = RCC->CFGR;
 656              		.loc 1 779 0
 657 0000 034A     		ldr	r2, .L64
 658 0002 5368     		ldr	r3, [r2, #4]
 659              	.LVL36:
 780:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 781:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear SW[1:0] bits */
 782:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg &= ~RCC_CFGR_SW;
 660              		.loc 1 782 0
 661 0004 0321     		mov	r1, #3
 662 0006 8B43     		bic	r3, r1
 663              	.LVL37:
 783:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 784:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
 785:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg |= RCC_SYSCLKSource;
 664              		.loc 1 785 0
 665 0008 1843     		orr	r0, r3
 666              	.LVL38:
 786:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 787:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Store the new value */
 788:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR = tmpreg;
 667              		.loc 1 788 0
 668 000a 5060     		str	r0, [r2, #4]
 789:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 669              		.loc 1 789 0
 670              		@ sp needed
 671 000c 7047     		bx	lr
 672              	.L65:
 673 000e C046     		.align	2
 674              	.L64:
 675 0010 00100240 		.word	1073876992
 676              		.cfi_endproc
 677              	.LFE50:
 679              		.section	.text.RCC_GetSYSCLKSource,"ax",%progbits
 680              		.align	2
 681              		.global	RCC_GetSYSCLKSource
 682              		.code	16
 683              		.thumb_func
 685              	RCC_GetSYSCLKSource:
 686              	.LFB51:
 790:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 791:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 792:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Returns the clock source used as system clock.
 793:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  None
 794:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval The clock source used as system clock. The returned value can be one 
 795:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         of the following values:
 796:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           - 0x00: HSI used as system clock
 797:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           - 0x04: HSE used as system clock  
 798:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           - 0x08: PLL used as system clock
 799:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           - 0x0C: HSI48 used as system clock, applicable only for STM32F072 devices  
 800:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 801:.\StdPeriphLib\src/stm32f0xx_rcc.c **** uint8_t RCC_GetSYSCLKSource(void)
 802:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 687              		.loc 1 802 0
 688              		.cfi_startproc
 803:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 689              		.loc 1 803 0
 690 0000 024B     		ldr	r3, .L67
 691 0002 5B68     		ldr	r3, [r3, #4]
 692 0004 0C20     		mov	r0, #12
 693 0006 1840     		and	r0, r3
 804:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 694              		.loc 1 804 0
 695              		@ sp needed
 696 0008 7047     		bx	lr
 697              	.L68:
 698 000a C046     		.align	2
 699              	.L67:
 700 000c 00100240 		.word	1073876992
 701              		.cfi_endproc
 702              	.LFE51:
 704              		.section	.text.RCC_HCLKConfig,"ax",%progbits
 705              		.align	2
 706              		.global	RCC_HCLKConfig
 707              		.code	16
 708              		.thumb_func
 710              	RCC_HCLKConfig:
 711              	.LFB52:
 805:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 806:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 807:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Configures the AHB clock (HCLK).
 808:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
 809:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         the system clock (SYSCLK).
 810:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 811:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_SYSCLK_Div1:   AHB clock = SYSCLK
 812:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_SYSCLK_Div2:   AHB clock = SYSCLK/2
 813:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_SYSCLK_Div4:   AHB clock = SYSCLK/4
 814:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_SYSCLK_Div8:   AHB clock = SYSCLK/8
 815:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_SYSCLK_Div16:  AHB clock = SYSCLK/16
 816:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_SYSCLK_Div64:  AHB clock = SYSCLK/64
 817:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
 818:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
 819:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
 820:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 821:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 822:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
 823:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 712              		.loc 1 823 0
 713              		.cfi_startproc
 714              	.LVL39:
 824:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   uint32_t tmpreg = 0;
 825:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 826:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 827:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_HCLK(RCC_SYSCLK));
 828:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 829:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg = RCC->CFGR;
 715              		.loc 1 829 0
 716 0000 034A     		ldr	r2, .L70
 717 0002 5368     		ldr	r3, [r2, #4]
 718              	.LVL40:
 830:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 831:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear HPRE[3:0] bits */
 832:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg &= ~RCC_CFGR_HPRE;
 719              		.loc 1 832 0
 720 0004 F021     		mov	r1, #240
 721 0006 8B43     		bic	r3, r1
 722              	.LVL41:
 833:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 834:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
 835:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg |= RCC_SYSCLK;
 723              		.loc 1 835 0
 724 0008 1843     		orr	r0, r3
 725              	.LVL42:
 836:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 837:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Store the new value */
 838:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR = tmpreg;
 726              		.loc 1 838 0
 727 000a 5060     		str	r0, [r2, #4]
 839:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 728              		.loc 1 839 0
 729              		@ sp needed
 730 000c 7047     		bx	lr
 731              	.L71:
 732 000e C046     		.align	2
 733              	.L70:
 734 0010 00100240 		.word	1073876992
 735              		.cfi_endproc
 736              	.LFE52:
 738              		.section	.text.RCC_PCLKConfig,"ax",%progbits
 739              		.align	2
 740              		.global	RCC_PCLKConfig
 741              		.code	16
 742              		.thumb_func
 744              	RCC_PCLKConfig:
 745              	.LFB53:
 840:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 841:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 842:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Configures the APB clock (PCLK).
 843:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_HCLK: defines the APB clock divider. This clock is derived from 
 844:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         the AHB clock (HCLK).
 845:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 846:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_HCLK_Div1: APB clock = HCLK
 847:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_HCLK_Div2: APB clock = HCLK/2
 848:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_HCLK_Div4: APB clock = HCLK/4
 849:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_HCLK_Div8: APB clock = HCLK/8
 850:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_HCLK_Div16: APB clock = HCLK/16
 851:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 852:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 853:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_PCLKConfig(uint32_t RCC_HCLK)
 854:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 746              		.loc 1 854 0
 747              		.cfi_startproc
 748              	.LVL43:
 855:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   uint32_t tmpreg = 0;
 856:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 857:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 858:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_PCLK(RCC_HCLK));
 859:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 860:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg = RCC->CFGR;
 749              		.loc 1 860 0
 750 0000 034A     		ldr	r2, .L73
 751 0002 5168     		ldr	r1, [r2, #4]
 752              	.LVL44:
 861:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 862:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear PPRE[2:0] bits */
 863:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg &= ~RCC_CFGR_PPRE;
 753              		.loc 1 863 0
 754 0004 034B     		ldr	r3, .L73+4
 755 0006 0B40     		and	r3, r1
 756              	.LVL45:
 864:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 865:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set PPRE[2:0] bits according to RCC_HCLK value */
 866:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmpreg |= RCC_HCLK;
 757              		.loc 1 866 0
 758 0008 1843     		orr	r0, r3
 759              	.LVL46:
 867:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 868:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Store the new value */
 869:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR = tmpreg;
 760              		.loc 1 869 0
 761 000a 5060     		str	r0, [r2, #4]
 870:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 762              		.loc 1 870 0
 763              		@ sp needed
 764 000c 7047     		bx	lr
 765              	.L74:
 766 000e C046     		.align	2
 767              	.L73:
 768 0010 00100240 		.word	1073876992
 769 0014 FFF8FFFF 		.word	-1793
 770              		.cfi_endproc
 771              	.LFE53:
 773              		.section	.text.RCC_ADCCLKConfig,"ax",%progbits
 774              		.align	2
 775              		.global	RCC_ADCCLKConfig
 776              		.code	16
 777              		.thumb_func
 779              	RCC_ADCCLKConfig:
 780              	.LFB54:
 871:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 872:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 873:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Configures the ADC clock (ADCCLK).
 874:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   This function is obsolete.
 875:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         For proper ADC clock selection, refer to ADC_ClockModeConfig() in the ADC driver
 876:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_ADCCLK: defines the ADC clock source. This clock is derived 
 877:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         from the HSI14 or APB clock (PCLK).
 878:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 879:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_ADCCLK_HSI14: ADC clock = HSI14 (14MHz)
 880:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_ADCCLK_PCLK_Div2: ADC clock = PCLK/2
 881:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_ADCCLK_PCLK_Div4: ADC clock = PCLK/4  
 882:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 883:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 884:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_ADCCLKConfig(uint32_t RCC_ADCCLK)
 885:.\StdPeriphLib\src/stm32f0xx_rcc.c **** { 
 781              		.loc 1 885 0
 782              		.cfi_startproc
 783              	.LVL47:
 886:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 887:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_ADCCLK(RCC_ADCCLK));
 888:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 889:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear ADCPRE bit */
 890:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR &= ~RCC_CFGR_ADCPRE;
 784              		.loc 1 890 0
 785 0000 094B     		ldr	r3, .L76
 786 0002 5968     		ldr	r1, [r3, #4]
 787 0004 094A     		ldr	r2, .L76+4
 788 0006 0A40     		and	r2, r1
 789 0008 5A60     		str	r2, [r3, #4]
 891:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set ADCPRE bits according to RCC_PCLK value */
 892:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR |= RCC_ADCCLK & 0xFFFF;
 790              		.loc 1 892 0
 791 000a 5968     		ldr	r1, [r3, #4]
 792 000c 0204     		lsl	r2, r0, #16
 793 000e 120C     		lsr	r2, r2, #16
 794 0010 0A43     		orr	r2, r1
 795 0012 5A60     		str	r2, [r3, #4]
 893:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 894:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear ADCSW bit */
 895:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR3 &= ~RCC_CFGR3_ADCSW; 
 796              		.loc 1 895 0
 797 0014 196B     		ldr	r1, [r3, #48]
 798 0016 064A     		ldr	r2, .L76+8
 799 0018 0A40     		and	r2, r1
 800 001a 1A63     		str	r2, [r3, #48]
 896:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set ADCSW bits according to RCC_ADCCLK value */
 897:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR3 |= RCC_ADCCLK >> 16;  
 801              		.loc 1 897 0
 802 001c 1A6B     		ldr	r2, [r3, #48]
 803 001e 000C     		lsr	r0, r0, #16
 804              	.LVL48:
 805 0020 1043     		orr	r0, r2
 806 0022 1863     		str	r0, [r3, #48]
 898:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 807              		.loc 1 898 0
 808              		@ sp needed
 809 0024 7047     		bx	lr
 810              	.L77:
 811 0026 C046     		.align	2
 812              	.L76:
 813 0028 00100240 		.word	1073876992
 814 002c FFBFFFFF 		.word	-16385
 815 0030 FFFEFFFF 		.word	-257
 816              		.cfi_endproc
 817              	.LFE54:
 819              		.section	.text.RCC_CECCLKConfig,"ax",%progbits
 820              		.align	2
 821              		.global	RCC_CECCLKConfig
 822              		.code	16
 823              		.thumb_func
 825              	RCC_CECCLKConfig:
 826              	.LFB55:
 899:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 900:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 901:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Configures the CEC clock (CECCLK).
 902:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_CECCLK: defines the CEC clock source. This clock is derived 
 903:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         from the HSI or LSE clock.
 904:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 905:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_CECCLK_HSI_Div244: CEC clock = HSI/244 (32768Hz)
 906:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_CECCLK_LSE: CEC clock = LSE
 907:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 908:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 909:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_CECCLKConfig(uint32_t RCC_CECCLK)
 910:.\StdPeriphLib\src/stm32f0xx_rcc.c **** { 
 827              		.loc 1 910 0
 828              		.cfi_startproc
 829              	.LVL49:
 911:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 912:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_CECCLK(RCC_CECCLK));
 913:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 914:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear CECSW bit */
 915:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR3 &= ~RCC_CFGR3_CECSW;
 830              		.loc 1 915 0
 831 0000 044B     		ldr	r3, .L79
 832 0002 1A6B     		ldr	r2, [r3, #48]
 833 0004 4021     		mov	r1, #64
 834 0006 8A43     		bic	r2, r1
 835 0008 1A63     		str	r2, [r3, #48]
 916:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set CECSW bits according to RCC_CECCLK value */
 917:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR3 |= RCC_CECCLK;
 836              		.loc 1 917 0
 837 000a 1A6B     		ldr	r2, [r3, #48]
 838 000c 1043     		orr	r0, r2
 839              	.LVL50:
 840 000e 1863     		str	r0, [r3, #48]
 918:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 841              		.loc 1 918 0
 842              		@ sp needed
 843 0010 7047     		bx	lr
 844              	.L80:
 845 0012 C046     		.align	2
 846              	.L79:
 847 0014 00100240 		.word	1073876992
 848              		.cfi_endproc
 849              	.LFE55:
 851              		.section	.text.RCC_I2CCLKConfig,"ax",%progbits
 852              		.align	2
 853              		.global	RCC_I2CCLKConfig
 854              		.code	16
 855              		.thumb_func
 857              	RCC_I2CCLKConfig:
 858              	.LFB56:
 919:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 920:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 921:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Configures the I2C1 clock (I2C1CLK).
 922:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_I2CCLK: defines the I2C1 clock source. This clock is derived 
 923:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         from the HSI or System clock.
 924:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 925:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_I2C1CLK_HSI: I2C1 clock = HSI
 926:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_I2C1CLK_SYSCLK: I2C1 clock = System Clock
 927:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 928:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 929:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_I2CCLKConfig(uint32_t RCC_I2CCLK)
 930:.\StdPeriphLib\src/stm32f0xx_rcc.c **** { 
 859              		.loc 1 930 0
 860              		.cfi_startproc
 861              	.LVL51:
 931:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 932:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_I2CCLK(RCC_I2CCLK));
 933:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 934:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear I2CSW bit */
 935:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR3 &= ~RCC_CFGR3_I2C1SW;
 862              		.loc 1 935 0
 863 0000 044B     		ldr	r3, .L82
 864 0002 1A6B     		ldr	r2, [r3, #48]
 865 0004 1021     		mov	r1, #16
 866 0006 8A43     		bic	r2, r1
 867 0008 1A63     		str	r2, [r3, #48]
 936:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set I2CSW bits according to RCC_I2CCLK value */
 937:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR3 |= RCC_I2CCLK;
 868              		.loc 1 937 0
 869 000a 1A6B     		ldr	r2, [r3, #48]
 870 000c 1043     		orr	r0, r2
 871              	.LVL52:
 872 000e 1863     		str	r0, [r3, #48]
 938:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 873              		.loc 1 938 0
 874              		@ sp needed
 875 0010 7047     		bx	lr
 876              	.L83:
 877 0012 C046     		.align	2
 878              	.L82:
 879 0014 00100240 		.word	1073876992
 880              		.cfi_endproc
 881              	.LFE56:
 883              		.section	.text.RCC_USARTCLKConfig,"ax",%progbits
 884              		.align	2
 885              		.global	RCC_USARTCLKConfig
 886              		.code	16
 887              		.thumb_func
 889              	RCC_USARTCLKConfig:
 890              	.LFB57:
 939:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 940:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 941:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Configures the USART1 clock (USART1CLK).
 942:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_USARTCLK: defines the USART clock source. This clock is derived 
 943:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         from the HSI or System clock.
 944:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 945:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_USART1CLK_PCLK: USART1 clock = APB Clock (PCLK)
 946:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_USART1CLK_SYSCLK: USART1 clock = System Clock
 947:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_USART1CLK_LSE: USART1 clock = LSE Clock
 948:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_USART1CLK_HSI: USART1 clock = HSI Clock
 949:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_USART2CLK_PCLK: USART2 clock = APB Clock (PCLK), applicable only for STM32
 950:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_USART2CLK_SYSCLK: USART2 clock = System Clock, applicable only for STM32F0
 951:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_USART2CLK_LSE: USART2 clock = LSE Clock, applicable only for STM32F072 and
 952:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_USART2CLK_HSI: USART2 clock = HSI Clock, applicable only for STM32F072 and
 953:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_USART3CLK_PCLK: USART3 clock = APB Clock (PCLK), applicable only for STM32
 954:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_USART3CLK_SYSCLK: USART3 clock = System Clock, applicable only for STM32F0
 955:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_USART3CLK_LSE: USART3 clock = LSE Clock, applicable only for STM32F091 dev
 956:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_USART3CLK_HSI: USART3 clock = HSI Clock, applicable only for STM32F091 dev
 957:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 958:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
 959:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_USARTCLKConfig(uint32_t RCC_USARTCLK)
 960:.\StdPeriphLib\src/stm32f0xx_rcc.c **** { 
 891              		.loc 1 960 0
 892              		.cfi_startproc
 893              	.LVL53:
 961:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   uint32_t tmp = 0;
 962:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 963:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
 964:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));
 965:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 966:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Get USART index */
 967:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmp = (RCC_USARTCLK >> 28);
 894              		.loc 1 967 0
 895 0000 030F     		lsr	r3, r0, #28
 896              	.LVL54:
 968:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 969:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear USARTSW[1:0] bit */
 970:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (tmp == (uint32_t)0x00000001)
 897              		.loc 1 970 0
 898 0002 012B     		cmp	r3, #1
 899 0004 05D1     		bne	.L85
 971:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 972:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* Clear USART1SW[1:0] bit */  
 973:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
 900              		.loc 1 973 0
 901 0006 0C4A     		ldr	r2, .L88
 902 0008 136B     		ldr	r3, [r2, #48]
 903              	.LVL55:
 904 000a 0321     		mov	r1, #3
 905 000c 8B43     		bic	r3, r1
 906 000e 1363     		str	r3, [r2, #48]
 907 0010 0CE0     		b	.L86
 908              	.LVL56:
 909              	.L85:
 974:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 975:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else if (tmp == (uint32_t)0x00000002)
 910              		.loc 1 975 0
 911 0012 022B     		cmp	r3, #2
 912 0014 05D1     		bne	.L87
 976:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 977:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* Clear USART2SW[1:0] bit */
 978:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
 913              		.loc 1 978 0
 914 0016 084A     		ldr	r2, .L88
 915 0018 116B     		ldr	r1, [r2, #48]
 916 001a 084B     		ldr	r3, .L88+4
 917              	.LVL57:
 918 001c 0B40     		and	r3, r1
 919 001e 1363     		str	r3, [r2, #48]
 920 0020 04E0     		b	.L86
 921              	.LVL58:
 922              	.L87:
 979:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 980:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else 
 981:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 982:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* Clear USART3SW[1:0] bit */
 983:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->CFGR3 &= ~RCC_CFGR3_USART3SW;
 923              		.loc 1 983 0
 924 0022 054A     		ldr	r2, .L88
 925 0024 116B     		ldr	r1, [r2, #48]
 926 0026 064B     		ldr	r3, .L88+8
 927              	.LVL59:
 928 0028 0B40     		and	r3, r1
 929 002a 1363     		str	r3, [r2, #48]
 930              	.L86:
 984:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
 985:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 986:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set USARTxSW bits according to RCC_USARTCLK value */
 987:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR3 |= RCC_USARTCLK;
 931              		.loc 1 987 0
 932 002c 024A     		ldr	r2, .L88
 933 002e 136B     		ldr	r3, [r2, #48]
 934 0030 1843     		orr	r0, r3
 935              	.LVL60:
 936 0032 1063     		str	r0, [r2, #48]
 988:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 937              		.loc 1 988 0
 938              		@ sp needed
 939 0034 7047     		bx	lr
 940              	.L89:
 941 0036 C046     		.align	2
 942              	.L88:
 943 0038 00100240 		.word	1073876992
 944 003c FFFFFCFF 		.word	-196609
 945 0040 FFFFF3FF 		.word	-786433
 946              		.cfi_endproc
 947              	.LFE57:
 949              		.section	.text.RCC_USBCLKConfig,"ax",%progbits
 950              		.align	2
 951              		.global	RCC_USBCLKConfig
 952              		.code	16
 953              		.thumb_func
 955              	RCC_USBCLKConfig:
 956              	.LFB58:
 989:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 990:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
 991:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Configures the USB clock (USBCLK).
 992:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         This function is only applicable for STM32F072 devices.  
 993:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_USBCLK: defines the USB clock source. This clock is derived 
 994:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         from the HSI48 or system clock.
 995:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
 996:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_USBCLK_HSI48: USB clock = HSI48
 997:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_USBCLK_PLLCLK: USB clock = PLL clock
 998:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
 999:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1000:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_USBCLKConfig(uint32_t RCC_USBCLK)
1001:.\StdPeriphLib\src/stm32f0xx_rcc.c **** { 
 957              		.loc 1 1001 0
 958              		.cfi_startproc
 959              	.LVL61:
1002:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
1003:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_USBCLK(RCC_USBCLK));
1004:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1005:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Clear USBSW bit */
1006:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR3 &= ~RCC_CFGR3_USBSW;
 960              		.loc 1 1006 0
 961 0000 044B     		ldr	r3, .L91
 962 0002 1A6B     		ldr	r2, [r3, #48]
 963 0004 8021     		mov	r1, #128
 964 0006 8A43     		bic	r2, r1
 965 0008 1A63     		str	r2, [r3, #48]
1007:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set USBSW bits according to RCC_USBCLK value */
1008:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CFGR3 |= RCC_USBCLK;
 966              		.loc 1 1008 0
 967 000a 1A6B     		ldr	r2, [r3, #48]
 968 000c 1043     		orr	r0, r2
 969              	.LVL62:
 970 000e 1863     		str	r0, [r3, #48]
1009:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 971              		.loc 1 1009 0
 972              		@ sp needed
 973 0010 7047     		bx	lr
 974              	.L92:
 975 0012 C046     		.align	2
 976              	.L91:
 977 0014 00100240 		.word	1073876992
 978              		.cfi_endproc
 979              	.LFE58:
 981              		.global	__aeabi_uidiv
 982              		.section	.text.RCC_GetClocksFreq,"ax",%progbits
 983              		.align	2
 984              		.global	RCC_GetClocksFreq
 985              		.code	16
 986              		.thumb_func
 988              	RCC_GetClocksFreq:
 989              	.LFB59:
1010:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1011:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1012:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Returns the frequencies of the System, AHB and APB busses clocks.
1013:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note    The frequency returned by this function is not the real frequency
1014:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           in the chip. It is calculated based on the predefined constant and
1015:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           the source selected by RCC_SYSCLKConfig():
1016:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *                                              
1017:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note     If SYSCLK source is HSI, function returns constant HSI_VALUE(*)
1018:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *                                              
1019:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note     If SYSCLK source is HSE, function returns constant HSE_VALUE(**)
1020:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *                          
1021:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note     If SYSCLK source is PLL, function returns constant HSE_VALUE(**) 
1022:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             or HSI_VALUE(*) multiplied by the PLL factors.
1023:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *               
1024:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note     If SYSCLK source is HSI48, function returns constant HSI48_VALUE(***) 
1025:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             
1026:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note     (*) HSI_VALUE is a constant defined in stm32f0xx.h file (default value
1027:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *               8 MHz) but the real value may vary depending on the variations
1028:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *               in voltage and temperature, refer to RCC_AdjustHSICalibrationValue().   
1029:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *    
1030:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note     (**) HSE_VALUE is a constant defined in stm32f0xx.h file (default value
1031:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *                8 MHz), user has to ensure that HSE_VALUE is same as the real
1032:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *                frequency of the crystal used. Otherwise, this function may
1033:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *                return wrong result.
1034:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *
1035:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note     (***) HSI48_VALUE is a constant defined in stm32f0xx.h file (default value
1036:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *                 48 MHz) but the real value may vary depending on the variations
1037:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *                 in voltage and temperature.
1038:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *                                   
1039:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The result of this function could be not correct when using fractional
1040:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         value for HSE crystal.   
1041:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             
1042:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold 
1043:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         the clocks frequencies. 
1044:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *     
1045:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   This function can be used by the user application to compute the 
1046:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         baudrate for the communication peripherals or configure other parameters.
1047:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   Each time SYSCLK, HCLK and/or PCLK clock changes, this function
1048:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         must be called to update the structure's field. Otherwise, any
1049:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         configuration based on this function will be incorrect.
1050:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *    
1051:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
1052:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1053:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
1054:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 990              		.loc 1 1054 0
 991              		.cfi_startproc
 992              	.LVL63:
 993 0000 70B5     		push	{r4, r5, r6, lr}
 994              	.LCFI1:
 995              		.cfi_def_cfa_offset 16
 996              		.cfi_offset 4, -16
 997              		.cfi_offset 5, -12
 998              		.cfi_offset 6, -8
 999              		.cfi_offset 14, -4
 1000 0002 041C     		mov	r4, r0
 1001              	.LVL64:
1055:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
1056:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1057:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Get SYSCLK source -------------------------------------------------------*/
1058:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmp = RCC->CFGR & RCC_CFGR_SWS;
 1002              		.loc 1 1058 0
 1003 0004 724B     		ldr	r3, .L124
 1004 0006 5B68     		ldr	r3, [r3, #4]
 1005              	.LVL65:
 1006 0008 0C22     		mov	r2, #12
 1007 000a 1340     		and	r3, r2
 1008              	.LVL66:
1059:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
1060:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   switch (tmp)
 1009              		.loc 1 1060 0
 1010 000c 042B     		cmp	r3, #4
 1011 000e 0CD0     		beq	.L95
 1012 0010 02D8     		bhi	.L96
 1013 0012 002B     		cmp	r3, #0
 1014 0014 05D0     		beq	.L97
 1015 0016 28E0     		b	.L94
 1016              	.L96:
 1017 0018 082B     		cmp	r3, #8
 1018 001a 0AD0     		beq	.L98
 1019 001c 0C2B     		cmp	r3, #12
 1020 001e 20D0     		beq	.L99
 1021 0020 23E0     		b	.L94
 1022              	.L97:
1061:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1062:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     case 0x00:  /* HSI used as system clock */
1063:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 1023              		.loc 1 1063 0
 1024 0022 6C4B     		ldr	r3, .L124+4
 1025              	.LVL67:
 1026 0024 0360     		str	r3, [r0]
1055:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 1027              		.loc 1 1055 0
 1028 0026 0020     		mov	r0, #0
 1029              	.LVL68:
1064:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       break;
 1030              		.loc 1 1064 0
 1031 0028 22E0     		b	.L100
 1032              	.LVL69:
 1033              	.L95:
1065:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     case 0x04:  /* HSE used as system clock */
1066:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 1034              		.loc 1 1066 0
 1035 002a 6A4B     		ldr	r3, .L124+4
 1036              	.LVL70:
 1037 002c 0360     		str	r3, [r0]
1055:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 1038              		.loc 1 1055 0
 1039 002e 0020     		mov	r0, #0
 1040              	.LVL71:
1067:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       break;
 1041              		.loc 1 1067 0
 1042 0030 1EE0     		b	.L100
 1043              	.LVL72:
 1044              	.L98:
1068:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     case 0x08:  /* PLL used as system clock */
1069:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       /* Get PLL clock source and multiplication factor ----------------------*/
1070:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 1045              		.loc 1 1070 0
 1046 0032 674B     		ldr	r3, .L124
 1047              	.LVL73:
 1048 0034 5868     		ldr	r0, [r3, #4]
 1049              	.LVL74:
1071:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 1050              		.loc 1 1071 0
 1051 0036 5A68     		ldr	r2, [r3, #4]
 1052              	.LVL75:
1070:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 1053              		.loc 1 1070 0
 1054 0038 8002     		lsl	r0, r0, #10
 1055              	.LVL76:
1072:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       pllmull = ( pllmull >> 18) + 2;
 1056              		.loc 1 1072 0
 1057 003a 000F     		lsr	r0, r0, #28
 1058 003c 851C     		add	r5, r0, #2
 1059              	.LVL77:
1073:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       
1074:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       if (pllsource == 0x00)
 1060              		.loc 1 1074 0
 1061 003e C023     		mov	r3, #192
 1062 0040 5B02     		lsl	r3, r3, #9
 1063 0042 1A42     		tst	r2, r3
 1064 0044 02D1     		bne	.L101
1075:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       {
1076:.\StdPeriphLib\src/stm32f0xx_rcc.c ****         /* HSI oscillator clock divided by 2 selected as PLL clock entry */
1077:.\StdPeriphLib\src/stm32f0xx_rcc.c ****         pllclk = (HSI_VALUE >> 1) * pllmull;
 1065              		.loc 1 1077 0
 1066 0046 6448     		ldr	r0, .L124+8
 1067 0048 6843     		mul	r0, r5
 1068              	.LVL78:
 1069 004a 08E0     		b	.L102
 1070              	.LVL79:
 1071              	.L101:
1078:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       }
1079:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       else
1080:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       {
1081:.\StdPeriphLib\src/stm32f0xx_rcc.c ****         prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 1072              		.loc 1 1081 0
 1073 004c 604B     		ldr	r3, .L124
 1074 004e DB6A     		ldr	r3, [r3, #44]
 1075              	.LVL80:
 1076 0050 0F21     		mov	r1, #15
 1077 0052 1940     		and	r1, r3
 1078 0054 0131     		add	r1, r1, #1
 1079              	.LVL81:
1082:.\StdPeriphLib\src/stm32f0xx_rcc.c ****         /* HSE oscillator clock selected as PREDIV1 clock entry */
1083:.\StdPeriphLib\src/stm32f0xx_rcc.c ****         pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
 1080              		.loc 1 1083 0
 1081 0056 5F48     		ldr	r0, .L124+4
 1082 0058 FFF7FEFF 		bl	__aeabi_uidiv
 1083              	.LVL82:
 1084 005c 6843     		mul	r0, r5
 1085              	.LVL83:
 1086              	.L102:
1084:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       }
1085:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       RCC_Clocks->SYSCLK_Frequency = pllclk;      
 1087              		.loc 1 1085 0
 1088 005e 2060     		str	r0, [r4]
1086:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       break;
 1089              		.loc 1 1086 0
 1090 0060 06E0     		b	.L100
 1091              	.LVL84:
 1092              	.L99:
1087:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     case 0x0C:  /* HSI48 used as system clock */
1088:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       RCC_Clocks->SYSCLK_Frequency = HSI48_VALUE;
 1093              		.loc 1 1088 0
 1094 0062 5E4B     		ldr	r3, .L124+12
 1095              	.LVL85:
 1096 0064 0360     		str	r3, [r0]
1055:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 1097              		.loc 1 1055 0
 1098 0066 0020     		mov	r0, #0
 1099              	.LVL86:
1089:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       break;
 1100              		.loc 1 1089 0
 1101 0068 02E0     		b	.L100
 1102              	.LVL87:
 1103              	.L94:
1090:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     default: /* HSI used as system clock */
1091:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 1104              		.loc 1 1091 0
 1105 006a 5A4B     		ldr	r3, .L124+4
 1106              	.LVL88:
 1107 006c 2360     		str	r3, [r4]
1055:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 1108              		.loc 1 1055 0
 1109 006e 0020     		mov	r0, #0
 1110              	.LVL89:
 1111              	.L100:
1092:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       break;
1093:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1094:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
1095:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Get HCLK prescaler */
1096:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmp = RCC->CFGR & RCC_CFGR_HPRE;
 1112              		.loc 1 1096 0
 1113 0070 5749     		ldr	r1, .L124
 1114 0072 4B68     		ldr	r3, [r1, #4]
 1115 0074 1B06     		lsl	r3, r3, #24
1097:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmp = tmp >> 4;
 1116              		.loc 1 1097 0
 1117 0076 1B0F     		lsr	r3, r3, #28
 1118              	.LVL90:
1098:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   presc = APBAHBPrescTable[tmp]; 
 1119              		.loc 1 1098 0
 1120 0078 594D     		ldr	r5, .L124+16
 1121 007a EB5C     		ldrb	r3, [r5, r3]
 1122              	.LVL91:
 1123 007c DBB2     		uxtb	r3, r3
 1124              	.LVL92:
1099:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* HCLK clock frequency */
1100:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 1125              		.loc 1 1100 0
 1126 007e 2668     		ldr	r6, [r4]
 1127 0080 321C     		mov	r2, r6
 1128 0082 DA40     		lsr	r2, r2, r3
 1129 0084 6260     		str	r2, [r4, #4]
1101:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1102:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Get PCLK prescaler */
1103:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmp = RCC->CFGR & RCC_CFGR_PPRE;
 1130              		.loc 1 1103 0
 1131 0086 4B68     		ldr	r3, [r1, #4]
 1132              	.LVL93:
 1133 0088 5B05     		lsl	r3, r3, #21
1104:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmp = tmp >> 8;
 1134              		.loc 1 1104 0
 1135 008a 5B0F     		lsr	r3, r3, #29
 1136              	.LVL94:
1105:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   presc = APBAHBPrescTable[tmp];
 1137              		.loc 1 1105 0
 1138 008c EB5C     		ldrb	r3, [r5, r3]
 1139              	.LVL95:
 1140 008e DBB2     		uxtb	r3, r3
 1141              	.LVL96:
1106:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* PCLK clock frequency */
1107:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC_Clocks->PCLK_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 1142              		.loc 1 1107 0
 1143 0090 DA40     		lsr	r2, r2, r3
 1144 0092 131C     		mov	r3, r2
 1145              	.LVL97:
 1146 0094 A260     		str	r2, [r4, #8]
1108:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1109:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* ADCCLK clock frequency */
1110:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_ADCSW) != RCC_CFGR3_ADCSW)
 1147              		.loc 1 1110 0
 1148 0096 0A6B     		ldr	r2, [r1, #48]
 1149 0098 D205     		lsl	r2, r2, #23
 1150 009a 02D4     		bmi	.L103
1111:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1112:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* ADC Clock is HSI14 Osc. */
1113:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->ADCCLK_Frequency = HSI14_VALUE;
 1151              		.loc 1 1113 0
 1152 009c 514A     		ldr	r2, .L124+20
 1153 009e E260     		str	r2, [r4, #12]
 1154 00a0 08E0     		b	.L104
 1155              	.L103:
1114:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1115:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1116:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1117:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     if((RCC->CFGR & RCC_CFGR_ADCPRE) != RCC_CFGR_ADCPRE)
 1156              		.loc 1 1117 0
 1157 00a2 4B4A     		ldr	r2, .L124
 1158 00a4 5268     		ldr	r2, [r2, #4]
 1159 00a6 5204     		lsl	r2, r2, #17
 1160 00a8 02D4     		bmi	.L105
1118:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     {
1119:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       /* ADC Clock is derived from PCLK/2 */
1120:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK_Frequency >> 1;
 1161              		.loc 1 1120 0
 1162 00aa 5A08     		lsr	r2, r3, #1
 1163 00ac E260     		str	r2, [r4, #12]
 1164 00ae 01E0     		b	.L104
 1165              	.L105:
1121:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     }
1122:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     else
1123:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     {
1124:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       /* ADC Clock is derived from PCLK/4 */
1125:.\StdPeriphLib\src/stm32f0xx_rcc.c ****       RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK_Frequency >> 2;
 1166              		.loc 1 1125 0
 1167 00b0 9A08     		lsr	r2, r3, #2
 1168 00b2 E260     		str	r2, [r4, #12]
 1169              	.L104:
1126:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     }
1127:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     
1128:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1129:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1130:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* CECCLK clock frequency */
1131:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_CECSW) != RCC_CFGR3_CECSW)
 1170              		.loc 1 1131 0
 1171 00b4 464A     		ldr	r2, .L124
 1172 00b6 126B     		ldr	r2, [r2, #48]
 1173 00b8 5206     		lsl	r2, r2, #25
 1174 00ba 02D4     		bmi	.L106
1132:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1133:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* CEC Clock is HSI/244 */
1134:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->CECCLK_Frequency = HSI_VALUE / 244;
 1175              		.loc 1 1134 0
 1176 00bc 4A4A     		ldr	r2, .L124+24
 1177 00be 2261     		str	r2, [r4, #16]
 1178 00c0 02E0     		b	.L107
 1179              	.L106:
1135:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1136:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1137:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1138:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* CECC Clock is LSE Osc. */
1139:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->CECCLK_Frequency = LSE_VALUE;
 1180              		.loc 1 1139 0
 1181 00c2 8022     		mov	r2, #128
 1182 00c4 1202     		lsl	r2, r2, #8
 1183 00c6 2261     		str	r2, [r4, #16]
 1184              	.L107:
1140:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1141:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1142:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* I2C1CLK clock frequency */
1143:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
 1185              		.loc 1 1143 0
 1186 00c8 414A     		ldr	r2, .L124
 1187 00ca 126B     		ldr	r2, [r2, #48]
 1188 00cc D206     		lsl	r2, r2, #27
 1189 00ce 02D4     		bmi	.L108
1144:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1145:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* I2C1 Clock is HSI Osc. */
1146:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
 1190              		.loc 1 1146 0
 1191 00d0 404A     		ldr	r2, .L124+4
 1192 00d2 6261     		str	r2, [r4, #20]
 1193 00d4 00E0     		b	.L109
 1194              	.L108:
1147:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1148:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1149:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1150:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* I2C1 Clock is System Clock */
1151:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1195              		.loc 1 1151 0
 1196 00d6 6661     		str	r6, [r4, #20]
 1197              	.L109:
1152:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1153:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1154:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* USART1CLK clock frequency */
1155:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
 1198              		.loc 1 1155 0
 1199 00d8 3D4A     		ldr	r2, .L124
 1200 00da 126B     		ldr	r2, [r2, #48]
 1201 00dc 9207     		lsl	r2, r2, #30
 1202 00de 01D1     		bne	.L110
1156:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1157:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* USART1 Clock is PCLK */
1158:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK_Frequency;
 1203              		.loc 1 1158 0
 1204 00e0 A361     		str	r3, [r4, #24]
 1205 00e2 19E0     		b	.L111
 1206              	.L110:
1159:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1160:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
 1207              		.loc 1 1160 0
 1208 00e4 3A4A     		ldr	r2, .L124
 1209 00e6 126B     		ldr	r2, [r2, #48]
 1210 00e8 0321     		mov	r1, #3
 1211 00ea 0A40     		and	r2, r1
 1212 00ec 012A     		cmp	r2, #1
 1213 00ee 01D1     		bne	.L112
1161:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1162:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* USART1 Clock is System Clock */
1163:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1214              		.loc 1 1163 0
 1215 00f0 A661     		str	r6, [r4, #24]
 1216 00f2 11E0     		b	.L111
 1217              	.L112:
1164:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1165:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
 1218              		.loc 1 1165 0
 1219 00f4 364A     		ldr	r2, .L124
 1220 00f6 126B     		ldr	r2, [r2, #48]
 1221 00f8 0321     		mov	r1, #3
 1222 00fa 0A40     		and	r2, r1
 1223 00fc 022A     		cmp	r2, #2
 1224 00fe 03D1     		bne	.L113
1166:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1167:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* USART1 Clock is LSE Osc. */
1168:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
 1225              		.loc 1 1168 0
 1226 0100 8022     		mov	r2, #128
 1227 0102 1202     		lsl	r2, r2, #8
 1228 0104 A261     		str	r2, [r4, #24]
 1229 0106 07E0     		b	.L111
 1230              	.L113:
1169:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1170:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
 1231              		.loc 1 1170 0
 1232 0108 314A     		ldr	r2, .L124
 1233 010a 126B     		ldr	r2, [r2, #48]
 1234 010c 0321     		mov	r1, #3
 1235 010e 0A40     		and	r2, r1
 1236 0110 032A     		cmp	r2, #3
 1237 0112 01D1     		bne	.L111
1171:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1172:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* USART1 Clock is HSI Osc. */
1173:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
 1238              		.loc 1 1173 0
 1239 0114 2F4A     		ldr	r2, .L124+4
 1240 0116 A261     		str	r2, [r4, #24]
 1241              	.L111:
1174:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1175:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
1176:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* USART2CLK clock frequency */
1177:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == 0x0)
 1242              		.loc 1 1177 0
 1243 0118 2D4A     		ldr	r2, .L124
 1244 011a 116B     		ldr	r1, [r2, #48]
 1245 011c C022     		mov	r2, #192
 1246 011e 9202     		lsl	r2, r2, #10
 1247 0120 1142     		tst	r1, r2
 1248 0122 01D1     		bne	.L114
1178:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1179:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* USART Clock is PCLK */
1180:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK_Frequency;
 1249              		.loc 1 1180 0
 1250 0124 E361     		str	r3, [r4, #28]
 1251 0126 20E0     		b	.L115
 1252              	.L114:
1181:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1182:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_0)
 1253              		.loc 1 1182 0
 1254 0128 294A     		ldr	r2, .L124
 1255 012a 116B     		ldr	r1, [r2, #48]
 1256 012c C022     		mov	r2, #192
 1257 012e 9202     		lsl	r2, r2, #10
 1258 0130 0A40     		and	r2, r1
 1259 0132 8021     		mov	r1, #128
 1260 0134 4902     		lsl	r1, r1, #9
 1261 0136 8A42     		cmp	r2, r1
 1262 0138 01D1     		bne	.L116
1183:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1184:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* USART Clock is System Clock */
1185:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1263              		.loc 1 1185 0
 1264 013a E661     		str	r6, [r4, #28]
 1265 013c 15E0     		b	.L115
 1266              	.L116:
1186:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1187:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_1)
 1267              		.loc 1 1187 0
 1268 013e 244A     		ldr	r2, .L124
 1269 0140 116B     		ldr	r1, [r2, #48]
 1270 0142 C022     		mov	r2, #192
 1271 0144 9202     		lsl	r2, r2, #10
 1272 0146 0A40     		and	r2, r1
 1273 0148 8021     		mov	r1, #128
 1274 014a 8902     		lsl	r1, r1, #10
 1275 014c 8A42     		cmp	r2, r1
 1276 014e 03D1     		bne	.L117
1188:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1189:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* USART Clock is LSE Osc. */
1190:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->USART2CLK_Frequency = LSE_VALUE;
 1277              		.loc 1 1190 0
 1278 0150 8022     		mov	r2, #128
 1279 0152 1202     		lsl	r2, r2, #8
 1280 0154 E261     		str	r2, [r4, #28]
 1281 0156 08E0     		b	.L115
 1282              	.L117:
1191:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1192:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW)
 1283              		.loc 1 1192 0
 1284 0158 1D4A     		ldr	r2, .L124
 1285 015a 126B     		ldr	r2, [r2, #48]
 1286 015c C021     		mov	r1, #192
 1287 015e 8902     		lsl	r1, r1, #10
 1288 0160 0A40     		and	r2, r1
 1289 0162 8A42     		cmp	r2, r1
 1290 0164 01D1     		bne	.L115
1193:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1194:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* USART Clock is HSI Osc. */
1195:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->USART2CLK_Frequency = HSI_VALUE;
 1291              		.loc 1 1195 0
 1292 0166 1B4A     		ldr	r2, .L124+4
 1293 0168 E261     		str	r2, [r4, #28]
 1294              	.L115:
1196:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1197:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
1198:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* USART3CLK clock frequency */
1199:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == 0x0)
 1295              		.loc 1 1199 0
 1296 016a 194A     		ldr	r2, .L124
 1297 016c 116B     		ldr	r1, [r2, #48]
 1298 016e C022     		mov	r2, #192
 1299 0170 1203     		lsl	r2, r2, #12
 1300 0172 1142     		tst	r1, r2
 1301 0174 01D1     		bne	.L118
1200:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1201:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* USART Clock is PCLK */
1202:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->PCLK_Frequency;
 1302              		.loc 1 1202 0
 1303 0176 2362     		str	r3, [r4, #32]
 1304 0178 20E0     		b	.L119
 1305              	.L118:
1203:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1204:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_0)
 1306              		.loc 1 1204 0
 1307 017a 154B     		ldr	r3, .L124
 1308 017c 1A6B     		ldr	r2, [r3, #48]
 1309 017e C023     		mov	r3, #192
 1310 0180 1B03     		lsl	r3, r3, #12
 1311 0182 1340     		and	r3, r2
 1312 0184 8022     		mov	r2, #128
 1313 0186 D202     		lsl	r2, r2, #11
 1314 0188 9342     		cmp	r3, r2
 1315 018a 01D1     		bne	.L120
1205:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1206:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* USART Clock is System Clock */
1207:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1316              		.loc 1 1207 0
 1317 018c 2662     		str	r6, [r4, #32]
 1318 018e 15E0     		b	.L119
 1319              	.L120:
1208:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1209:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_1)
 1320              		.loc 1 1209 0
 1321 0190 0F4B     		ldr	r3, .L124
 1322 0192 1A6B     		ldr	r2, [r3, #48]
 1323 0194 C023     		mov	r3, #192
 1324 0196 1B03     		lsl	r3, r3, #12
 1325 0198 1340     		and	r3, r2
 1326 019a 8022     		mov	r2, #128
 1327 019c 1203     		lsl	r2, r2, #12
 1328 019e 9342     		cmp	r3, r2
 1329 01a0 03D1     		bne	.L121
1210:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1211:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* USART Clock is LSE Osc. */
1212:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->USART3CLK_Frequency = LSE_VALUE;
 1330              		.loc 1 1212 0
 1331 01a2 8023     		mov	r3, #128
 1332 01a4 1B02     		lsl	r3, r3, #8
 1333 01a6 2362     		str	r3, [r4, #32]
 1334 01a8 08E0     		b	.L119
 1335              	.L121:
1213:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1214:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW)
 1336              		.loc 1 1214 0
 1337 01aa 094B     		ldr	r3, .L124
 1338 01ac 1B6B     		ldr	r3, [r3, #48]
 1339 01ae C022     		mov	r2, #192
 1340 01b0 1203     		lsl	r2, r2, #12
 1341 01b2 1340     		and	r3, r2
 1342 01b4 9342     		cmp	r3, r2
 1343 01b6 01D1     		bne	.L119
1215:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1216:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* USART Clock is HSI Osc. */
1217:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->USART3CLK_Frequency = HSI_VALUE;
 1344              		.loc 1 1217 0
 1345 01b8 064B     		ldr	r3, .L124+4
 1346 01ba 2362     		str	r3, [r4, #32]
 1347              	.L119:
1218:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1219:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
1220:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* USBCLK clock frequency */
1221:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_USBSW) != RCC_CFGR3_USBSW)
 1348              		.loc 1 1221 0
 1349 01bc 044B     		ldr	r3, .L124
 1350 01be 1B6B     		ldr	r3, [r3, #48]
 1351 01c0 1B06     		lsl	r3, r3, #24
 1352 01c2 02D4     		bmi	.L122
1222:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1223:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* USB Clock is HSI48 */
1224:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->USBCLK_Frequency = HSI48_VALUE;
 1353              		.loc 1 1224 0
 1354 01c4 054B     		ldr	r3, .L124+12
 1355 01c6 6362     		str	r3, [r4, #36]
 1356 01c8 00E0     		b	.L93
 1357              	.L122:
1225:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1226:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1227:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1228:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* USB Clock is PLL clock */
1229:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC_Clocks->USBCLK_Frequency = pllclk;
 1358              		.loc 1 1229 0
 1359 01ca 6062     		str	r0, [r4, #36]
 1360              	.L93:
1230:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }   
1231:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1361              		.loc 1 1231 0
 1362              		@ sp needed
 1363              	.LVL98:
 1364 01cc 70BD     		pop	{r4, r5, r6, pc}
 1365              	.L125:
 1366 01ce C046     		.align	2
 1367              	.L124:
 1368 01d0 00100240 		.word	1073876992
 1369 01d4 00127A00 		.word	8000000
 1370 01d8 00093D00 		.word	4000000
 1371 01dc 006CDC02 		.word	48000000
 1372 01e0 00000000 		.word	.LANCHOR0
 1373 01e4 809FD500 		.word	14000000
 1374 01e8 12800000 		.word	32786
 1375              		.cfi_endproc
 1376              	.LFE59:
 1378              		.section	.text.RCC_RTCCLKConfig,"ax",%progbits
 1379              		.align	2
 1380              		.global	RCC_RTCCLKConfig
 1381              		.code	16
 1382              		.thumb_func
 1384              	RCC_RTCCLKConfig:
 1385              	.LFB60:
1232:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1233:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1234:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @}
1235:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1236:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1237:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /** @defgroup RCC_Group3 Peripheral clocks configuration functions
1238:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  *  @brief   Peripheral clocks configuration functions 
1239:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  *
1240:.\StdPeriphLib\src/stm32f0xx_rcc.c **** @verbatim
1241:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  ===============================================================================
1242:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              #####Peripheral clocks configuration functions #####
1243:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  ===============================================================================  
1244:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1245:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     [..] This section provide functions allowing to configure the Peripheral clocks. 
1246:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) The RTC clock which is derived from the LSE, LSI or  HSE_Div32 (HSE
1247:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              divided by 32).
1248:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) After restart from Reset or wakeup from STANDBY, all peripherals are off
1249:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              except internal SRAM, Flash and SWD. Before to start using a peripheral you
1250:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              have to enable its interface clock. You can do this using RCC_AHBPeriphClockCmd(),
1251:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              RCC_APB2PeriphClockCmd() and RCC_APB1PeriphClockCmd() functions.
1252:.\StdPeriphLib\src/stm32f0xx_rcc.c ****          (#) To reset the peripherals configuration (to the default state after device reset)
1253:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              you can use RCC_AHBPeriphResetCmd(), RCC_APB2PeriphResetCmd() and 
1254:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              RCC_APB1PeriphResetCmd() functions.
1255:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1256:.\StdPeriphLib\src/stm32f0xx_rcc.c **** @endverbatim
1257:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @{
1258:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1259:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1260:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1261:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Configures the RTC clock (RTCCLK).
1262:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   As the RTC clock configuration bits are in the Backup domain and write
1263:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         access is denied to this domain after reset, you have to enable write
1264:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         access using PWR_BackupAccessCmd(ENABLE) function before to configure
1265:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         the RTC clock source (to be done once after reset).    
1266:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   Once the RTC clock is configured it can't be changed unless the RTC
1267:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         is reset using RCC_BackupResetCmd function, or by a Power On Reset (POR)
1268:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             
1269:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_RTCCLKSource: specifies the RTC clock source.
1270:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
1271:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
1272:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
1273:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *            @arg RCC_RTCCLKSource_HSE_Div32: HSE divided by 32 selected as RTC clock
1274:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *       
1275:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   If the LSE or LSI is used as RTC clock source, the RTC continues to
1276:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         work in STOP and STANDBY modes, and can be used as wakeup source.
1277:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         However, when the HSE clock is used as RTC clock source, the RTC
1278:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         cannot be used in STOP and STANDBY modes.
1279:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             
1280:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The maximum input clock frequency for RTC is 2MHz (when using HSE as
1281:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         RTC clock source).
1282:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *                          
1283:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
1284:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1285:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
1286:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 1386              		.loc 1 1286 0
 1387              		.cfi_startproc
 1388              	.LVL99:
1287:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
1288:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
1289:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
1290:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Select the RTC clock source */
1291:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->BDCR |= RCC_RTCCLKSource;
 1389              		.loc 1 1291 0
 1390 0000 024A     		ldr	r2, .L127
 1391 0002 136A     		ldr	r3, [r2, #32]
 1392 0004 1843     		orr	r0, r3
 1393              	.LVL100:
 1394 0006 1062     		str	r0, [r2, #32]
1292:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1395              		.loc 1 1292 0
 1396              		@ sp needed
 1397 0008 7047     		bx	lr
 1398              	.L128:
 1399 000a C046     		.align	2
 1400              	.L127:
 1401 000c 00100240 		.word	1073876992
 1402              		.cfi_endproc
 1403              	.LFE60:
 1405              		.section	.text.RCC_RTCCLKCmd,"ax",%progbits
 1406              		.align	2
 1407              		.global	RCC_RTCCLKCmd
 1408              		.code	16
 1409              		.thumb_func
 1411              	RCC_RTCCLKCmd:
 1412              	.LFB61:
1293:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1294:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1295:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Enables or disables the RTC clock.
1296:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   This function must be used only after the RTC clock source was selected
1297:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         using the RCC_RTCCLKConfig function.
1298:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the RTC clock.
1299:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
1300:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
1301:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1302:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_RTCCLKCmd(FunctionalState NewState)
1303:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 1413              		.loc 1 1303 0
 1414              		.cfi_startproc
 1415              	.LVL101:
1304:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
1305:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1306:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
1307:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 1416              		.loc 1 1307 0
 1417 0000 0028     		cmp	r0, #0
 1418 0002 06D0     		beq	.L130
1308:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1309:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->BDCR |= RCC_BDCR_RTCEN;
 1419              		.loc 1 1309 0
 1420 0004 064A     		ldr	r2, .L132
 1421 0006 136A     		ldr	r3, [r2, #32]
 1422 0008 8021     		mov	r1, #128
 1423 000a 0902     		lsl	r1, r1, #8
 1424 000c 0B43     		orr	r3, r1
 1425 000e 1362     		str	r3, [r2, #32]
 1426 0010 04E0     		b	.L129
 1427              	.L130:
1310:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1311:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1312:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1313:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->BDCR &= ~RCC_BDCR_RTCEN;
 1428              		.loc 1 1313 0
 1429 0012 034A     		ldr	r2, .L132
 1430 0014 116A     		ldr	r1, [r2, #32]
 1431 0016 034B     		ldr	r3, .L132+4
 1432 0018 0B40     		and	r3, r1
 1433 001a 1362     		str	r3, [r2, #32]
 1434              	.L129:
1314:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1315:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1435              		.loc 1 1315 0
 1436              		@ sp needed
 1437 001c 7047     		bx	lr
 1438              	.L133:
 1439 001e C046     		.align	2
 1440              	.L132:
 1441 0020 00100240 		.word	1073876992
 1442 0024 FF7FFFFF 		.word	-32769
 1443              		.cfi_endproc
 1444              	.LFE61:
 1446              		.section	.text.RCC_BackupResetCmd,"ax",%progbits
 1447              		.align	2
 1448              		.global	RCC_BackupResetCmd
 1449              		.code	16
 1450              		.thumb_func
 1452              	RCC_BackupResetCmd:
 1453              	.LFB62:
1316:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1317:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1318:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Forces or releases the Backup domain reset.
1319:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   This function resets the RTC peripheral (including the backup registers)
1320:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         and the RTC clock source selection in RCC_BDCR register.
1321:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the Backup domain reset.
1322:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
1323:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
1324:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1325:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_BackupResetCmd(FunctionalState NewState)
1326:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 1454              		.loc 1 1326 0
 1455              		.cfi_startproc
 1456              	.LVL102:
1327:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
1328:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1329:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
1330:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 1457              		.loc 1 1330 0
 1458 0000 0028     		cmp	r0, #0
 1459 0002 06D0     		beq	.L135
1331:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1332:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->BDCR |= RCC_BDCR_BDRST;
 1460              		.loc 1 1332 0
 1461 0004 064A     		ldr	r2, .L137
 1462 0006 136A     		ldr	r3, [r2, #32]
 1463 0008 8021     		mov	r1, #128
 1464 000a 4902     		lsl	r1, r1, #9
 1465 000c 0B43     		orr	r3, r1
 1466 000e 1362     		str	r3, [r2, #32]
 1467 0010 04E0     		b	.L134
 1468              	.L135:
1333:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1334:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1335:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1336:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->BDCR &= ~RCC_BDCR_BDRST;
 1469              		.loc 1 1336 0
 1470 0012 034A     		ldr	r2, .L137
 1471 0014 116A     		ldr	r1, [r2, #32]
 1472 0016 034B     		ldr	r3, .L137+4
 1473 0018 0B40     		and	r3, r1
 1474 001a 1362     		str	r3, [r2, #32]
 1475              	.L134:
1337:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1338:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1476              		.loc 1 1338 0
 1477              		@ sp needed
 1478 001c 7047     		bx	lr
 1479              	.L138:
 1480 001e C046     		.align	2
 1481              	.L137:
 1482 0020 00100240 		.word	1073876992
 1483 0024 FFFFFEFF 		.word	-65537
 1484              		.cfi_endproc
 1485              	.LFE62:
 1487              		.section	.text.RCC_AHBPeriphClockCmd,"ax",%progbits
 1488              		.align	2
 1489              		.global	RCC_AHBPeriphClockCmd
 1490              		.code	16
 1491              		.thumb_func
 1493              	RCC_AHBPeriphClockCmd:
 1494              	.LFB63:
1339:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1340:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1341:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Enables or disables the AHB peripheral clock.
1342:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   After reset, the peripheral clock (used for registers read/write access)
1343:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         is disabled and the application software has to enable this clock before 
1344:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         using it.    
1345:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
1346:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be any combination of the following values:
1347:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_GPIOA: GPIOA clock
1348:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_GPIOB: GPIOB clock
1349:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_GPIOC: GPIOC clock
1350:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_GPIOD: GPIOD clock
1351:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_GPIOE: GPIOE clock, applicable only for STM32F072 devices  
1352:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_GPIOF: GPIOF clock
1353:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_TS:    TS clock
1354:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_CRC:   CRC clock
1355:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_FLITF: (has effect only when the Flash memory is in power down m
1356:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_SRAM:  SRAM clock
1357:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_DMA1:  DMA1 clock
1358:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_DMA2:  DMA2 clock  
1359:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the specified peripheral clock.
1360:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
1361:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
1362:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1363:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
1364:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 1495              		.loc 1 1364 0
 1496              		.cfi_startproc
 1497              	.LVL103:
1365:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
1366:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
1367:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1368:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
1369:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 1498              		.loc 1 1369 0
 1499 0000 0029     		cmp	r1, #0
 1500 0002 04D0     		beq	.L140
1370:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1371:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->AHBENR |= RCC_AHBPeriph;
 1501              		.loc 1 1371 0
 1502 0004 044A     		ldr	r2, .L142
 1503 0006 5369     		ldr	r3, [r2, #20]
 1504 0008 1843     		orr	r0, r3
 1505              	.LVL104:
 1506 000a 5061     		str	r0, [r2, #20]
 1507 000c 03E0     		b	.L139
 1508              	.LVL105:
 1509              	.L140:
1372:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1373:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1374:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1375:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->AHBENR &= ~RCC_AHBPeriph;
 1510              		.loc 1 1375 0
 1511 000e 024A     		ldr	r2, .L142
 1512 0010 5369     		ldr	r3, [r2, #20]
 1513 0012 8343     		bic	r3, r0
 1514 0014 5361     		str	r3, [r2, #20]
 1515              	.LVL106:
 1516              	.L139:
1376:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1377:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1517              		.loc 1 1377 0
 1518              		@ sp needed
 1519 0016 7047     		bx	lr
 1520              	.L143:
 1521              		.align	2
 1522              	.L142:
 1523 0018 00100240 		.word	1073876992
 1524              		.cfi_endproc
 1525              	.LFE63:
 1527              		.section	.text.RCC_APB2PeriphClockCmd,"ax",%progbits
 1528              		.align	2
 1529              		.global	RCC_APB2PeriphClockCmd
 1530              		.code	16
 1531              		.thumb_func
 1533              	RCC_APB2PeriphClockCmd:
 1534              	.LFB64:
1378:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1379:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1380:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
1381:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   After reset, the peripheral clock (used for registers read/write access)
1382:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         is disabled and the application software has to enable this clock before 
1383:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         using it.
1384:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
1385:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be any combination of the following values:
1386:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
1387:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_USART6: USART6 clock  
1388:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_USART7: USART7 clock
1389:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_USART8: USART8 clock   
1390:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_ADC1:   ADC1 clock
1391:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_TIM1:   TIM1 clock
1392:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_SPI1:   SPI1 clock
1393:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_USART1: USART1 clock   
1394:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_TIM15:  TIM15 clock
1395:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_TIM16:  TIM16 clock
1396:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_TIM17:  TIM17 clock
1397:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_DBGMCU: DBGMCU clock
1398:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the specified peripheral clock.
1399:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
1400:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
1401:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1402:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
1403:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 1535              		.loc 1 1403 0
 1536              		.cfi_startproc
 1537              	.LVL107:
1404:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
1405:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
1406:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1407:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1408:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 1538              		.loc 1 1408 0
 1539 0000 0029     		cmp	r1, #0
 1540 0002 04D0     		beq	.L145
1409:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1410:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->APB2ENR |= RCC_APB2Periph;
 1541              		.loc 1 1410 0
 1542 0004 044A     		ldr	r2, .L147
 1543 0006 9369     		ldr	r3, [r2, #24]
 1544 0008 1843     		orr	r0, r3
 1545              	.LVL108:
 1546 000a 9061     		str	r0, [r2, #24]
 1547 000c 03E0     		b	.L144
 1548              	.LVL109:
 1549              	.L145:
1411:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1412:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1413:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1414:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->APB2ENR &= ~RCC_APB2Periph;
 1550              		.loc 1 1414 0
 1551 000e 024A     		ldr	r2, .L147
 1552 0010 9369     		ldr	r3, [r2, #24]
 1553 0012 8343     		bic	r3, r0
 1554 0014 9361     		str	r3, [r2, #24]
 1555              	.LVL110:
 1556              	.L144:
1415:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1416:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1557              		.loc 1 1416 0
 1558              		@ sp needed
 1559 0016 7047     		bx	lr
 1560              	.L148:
 1561              		.align	2
 1562              	.L147:
 1563 0018 00100240 		.word	1073876992
 1564              		.cfi_endproc
 1565              	.LFE64:
 1567              		.section	.text.RCC_APB1PeriphClockCmd,"ax",%progbits
 1568              		.align	2
 1569              		.global	RCC_APB1PeriphClockCmd
 1570              		.code	16
 1571              		.thumb_func
 1573              	RCC_APB1PeriphClockCmd:
 1574              	.LFB65:
1417:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1418:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1419:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
1420:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   After reset, the peripheral clock (used for registers read/write access)
1421:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         is disabled and the application software has to enable this clock before 
1422:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         using it.
1423:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
1424:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be any combination of the following values:
1425:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_TIM2:   TIM2 clock, applicable only for STM32F051 and STM32F072 d
1426:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_TIM3:   TIM3 clock
1427:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_TIM6:   TIM6 clock
1428:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_TIM7:   TIM7 clock, applicable only for STM32F072 devices   
1429:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_TIM14:  TIM14 clock
1430:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_WWDG:   WWDG clock
1431:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_SPI2:   SPI2 clock
1432:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_USART2: USART2 clock
1433:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_USART3: USART3 clock, applicable only for STM32F072 and STM32F091
1434:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_USART4: USART4 clock, applicable only for STM32F072 and STM32F091
1435:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_USART5: USART5 clock, applicable only for STM32F091 devices      
1436:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_I2C1:   I2C1 clock
1437:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_I2C2:   I2C2 clock
1438:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_USB:    USB clock, applicable only for STM32F042 and STM32F072 de
1439:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_CAN:    CAN clock, applicable only for STM32F042 and STM32F072 de
1440:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_CRS:    CRS clock , applicable only for STM32F042 and STM32F072 d
1441:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_PWR:    PWR clock
1442:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_DAC:    DAC clock, applicable only for STM32F051 and STM32F072 de
1443:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_CEC:    CEC clock, applicable only for STM32F051, STM32F042 and S
1444:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the specified peripheral clock.
1445:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
1446:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
1447:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1448:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
1449:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 1575              		.loc 1 1449 0
 1576              		.cfi_startproc
 1577              	.LVL111:
1450:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
1451:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
1452:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1453:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1454:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 1578              		.loc 1 1454 0
 1579 0000 0029     		cmp	r1, #0
 1580 0002 04D0     		beq	.L150
1455:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1456:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->APB1ENR |= RCC_APB1Periph;
 1581              		.loc 1 1456 0
 1582 0004 044A     		ldr	r2, .L152
 1583 0006 D369     		ldr	r3, [r2, #28]
 1584 0008 1843     		orr	r0, r3
 1585              	.LVL112:
 1586 000a D061     		str	r0, [r2, #28]
 1587 000c 03E0     		b	.L149
 1588              	.LVL113:
 1589              	.L150:
1457:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1458:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1459:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1460:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->APB1ENR &= ~RCC_APB1Periph;
 1590              		.loc 1 1460 0
 1591 000e 024A     		ldr	r2, .L152
 1592 0010 D369     		ldr	r3, [r2, #28]
 1593 0012 8343     		bic	r3, r0
 1594 0014 D361     		str	r3, [r2, #28]
 1595              	.LVL114:
 1596              	.L149:
1461:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1462:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1597              		.loc 1 1462 0
 1598              		@ sp needed
 1599 0016 7047     		bx	lr
 1600              	.L153:
 1601              		.align	2
 1602              	.L152:
 1603 0018 00100240 		.word	1073876992
 1604              		.cfi_endproc
 1605              	.LFE65:
 1607              		.section	.text.RCC_AHBPeriphResetCmd,"ax",%progbits
 1608              		.align	2
 1609              		.global	RCC_AHBPeriphResetCmd
 1610              		.code	16
 1611              		.thumb_func
 1613              	RCC_AHBPeriphResetCmd:
 1614              	.LFB66:
1463:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1464:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1465:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Forces or releases AHB peripheral reset.
1466:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_AHBPeriph: specifies the AHB peripheral to reset.
1467:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be any combination of the following values:
1468:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_GPIOA: GPIOA clock
1469:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_GPIOB: GPIOB clock
1470:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_GPIOC: GPIOC clock
1471:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_GPIOD: GPIOD clock
1472:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_GPIOE: GPIOE clock, applicable only for STM32F072 devices  
1473:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_GPIOF: GPIOF clock
1474:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_AHBPeriph_TS:    TS clock
1475:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the specified peripheral reset.
1476:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
1477:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
1478:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1479:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
1480:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 1615              		.loc 1 1480 0
 1616              		.cfi_startproc
 1617              	.LVL115:
1481:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
1482:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
1483:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1484:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1485:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 1618              		.loc 1 1485 0
 1619 0000 0029     		cmp	r1, #0
 1620 0002 04D0     		beq	.L155
1486:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1487:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->AHBRSTR |= RCC_AHBPeriph;
 1621              		.loc 1 1487 0
 1622 0004 044A     		ldr	r2, .L157
 1623 0006 936A     		ldr	r3, [r2, #40]
 1624 0008 1843     		orr	r0, r3
 1625              	.LVL116:
 1626 000a 9062     		str	r0, [r2, #40]
 1627 000c 03E0     		b	.L154
 1628              	.LVL117:
 1629              	.L155:
1488:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1489:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1490:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1491:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->AHBRSTR &= ~RCC_AHBPeriph;
 1630              		.loc 1 1491 0
 1631 000e 024A     		ldr	r2, .L157
 1632 0010 936A     		ldr	r3, [r2, #40]
 1633 0012 8343     		bic	r3, r0
 1634 0014 9362     		str	r3, [r2, #40]
 1635              	.LVL118:
 1636              	.L154:
1492:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1493:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1637              		.loc 1 1493 0
 1638              		@ sp needed
 1639 0016 7047     		bx	lr
 1640              	.L158:
 1641              		.align	2
 1642              	.L157:
 1643 0018 00100240 		.word	1073876992
 1644              		.cfi_endproc
 1645              	.LFE66:
 1647              		.section	.text.RCC_APB2PeriphResetCmd,"ax",%progbits
 1648              		.align	2
 1649              		.global	RCC_APB2PeriphResetCmd
 1650              		.code	16
 1651              		.thumb_func
 1653              	RCC_APB2PeriphResetCmd:
 1654              	.LFB67:
1494:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1495:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1496:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
1497:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
1498:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be any combination of the following values:
1499:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
1500:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_USART6: USART6 clock  
1501:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_USART7: USART7 clock
1502:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_USART8: USART8 clock   
1503:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_ADC1:   ADC1 clock
1504:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_TIM1:   TIM1 clock
1505:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_SPI1:   SPI1 clock
1506:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_USART1: USART1 clock
1507:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_TIM15:  TIM15 clock
1508:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_TIM16:  TIM16 clock
1509:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_TIM17:  TIM17 clock
1510:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_APB2Periph_DBGMCU: DBGMCU clock
1511:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the specified peripheral reset.
1512:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
1513:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
1514:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1515:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
1516:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 1655              		.loc 1 1516 0
 1656              		.cfi_startproc
 1657              	.LVL119:
1517:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
1518:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
1519:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1520:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1521:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 1658              		.loc 1 1521 0
 1659 0000 0029     		cmp	r1, #0
 1660 0002 04D0     		beq	.L160
1522:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1523:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->APB2RSTR |= RCC_APB2Periph;
 1661              		.loc 1 1523 0
 1662 0004 044A     		ldr	r2, .L162
 1663 0006 D368     		ldr	r3, [r2, #12]
 1664 0008 1843     		orr	r0, r3
 1665              	.LVL120:
 1666 000a D060     		str	r0, [r2, #12]
 1667 000c 03E0     		b	.L159
 1668              	.LVL121:
 1669              	.L160:
1524:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1525:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1526:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1527:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->APB2RSTR &= ~RCC_APB2Periph;
 1670              		.loc 1 1527 0
 1671 000e 024A     		ldr	r2, .L162
 1672 0010 D368     		ldr	r3, [r2, #12]
 1673 0012 8343     		bic	r3, r0
 1674 0014 D360     		str	r3, [r2, #12]
 1675              	.LVL122:
 1676              	.L159:
1528:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1529:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1677              		.loc 1 1529 0
 1678              		@ sp needed
 1679 0016 7047     		bx	lr
 1680              	.L163:
 1681              		.align	2
 1682              	.L162:
 1683 0018 00100240 		.word	1073876992
 1684              		.cfi_endproc
 1685              	.LFE67:
 1687              		.section	.text.RCC_APB1PeriphResetCmd,"ax",%progbits
 1688              		.align	2
 1689              		.global	RCC_APB1PeriphResetCmd
 1690              		.code	16
 1691              		.thumb_func
 1693              	RCC_APB1PeriphResetCmd:
 1694              	.LFB68:
1530:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1531:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1532:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
1533:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
1534:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be any combination of the following values:
1535:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_TIM2:   TIM2 clock, applicable only for STM32F051 and STM32F072 d
1536:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_TIM3:   TIM3 clock
1537:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_TIM6:   TIM6 clock
1538:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_TIM7:   TIM7 clock, applicable only for STM32F072 devices   
1539:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_TIM14:  TIM14 clock
1540:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_WWDG:   WWDG clock
1541:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_SPI2:   SPI2 clock
1542:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_USART2: USART2 clock
1543:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_USART3: USART3 clock, applicable only for STM32F072 and STM32F091
1544:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_USART4: USART4 clock, applicable only for STM32F072 and STM32F091
1545:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_USART5: USART5 clock, applicable only for STM32F091 devices      
1546:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_I2C1:   I2C1 clock
1547:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_I2C2:   I2C2 clock
1548:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_USB:    USB clock, applicable only for STM32F042 and STM32F072 de
1549:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_CAN:    CAN clock, applicable only for STM32F042 and STM32F072 de
1550:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_CRS:    CRS clock , applicable only for STM32F042 and STM32F072 d
1551:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_PWR:    PWR clock
1552:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_DAC:    DAC clock, applicable only for STM32F051 and STM32F072 de
1553:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *           @arg RCC_APB1Periph_CEC:    CEC clock, applicable only for STM32F051, STM32F042 and S
1554:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the specified peripheral clock.
1555:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
1556:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
1557:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1558:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
1559:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 1695              		.loc 1 1559 0
 1696              		.cfi_startproc
 1697              	.LVL123:
1560:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
1561:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
1562:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1563:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1564:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 1698              		.loc 1 1564 0
 1699 0000 0029     		cmp	r1, #0
 1700 0002 04D0     		beq	.L165
1565:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1566:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->APB1RSTR |= RCC_APB1Periph;
 1701              		.loc 1 1566 0
 1702 0004 044A     		ldr	r2, .L167
 1703 0006 1369     		ldr	r3, [r2, #16]
 1704 0008 1843     		orr	r0, r3
 1705              	.LVL124:
 1706 000a 1061     		str	r0, [r2, #16]
 1707 000c 03E0     		b	.L164
 1708              	.LVL125:
 1709              	.L165:
1567:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1568:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1569:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1570:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     RCC->APB1RSTR &= ~RCC_APB1Periph;
 1710              		.loc 1 1570 0
 1711 000e 024A     		ldr	r2, .L167
 1712 0010 1369     		ldr	r3, [r2, #16]
 1713 0012 8343     		bic	r3, r0
 1714 0014 1361     		str	r3, [r2, #16]
 1715              	.LVL126:
 1716              	.L164:
1571:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1572:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1717              		.loc 1 1572 0
 1718              		@ sp needed
 1719 0016 7047     		bx	lr
 1720              	.L168:
 1721              		.align	2
 1722              	.L167:
 1723 0018 00100240 		.word	1073876992
 1724              		.cfi_endproc
 1725              	.LFE68:
 1727              		.section	.text.RCC_ITConfig,"ax",%progbits
 1728              		.align	2
 1729              		.global	RCC_ITConfig
 1730              		.code	16
 1731              		.thumb_func
 1733              	RCC_ITConfig:
 1734              	.LFB69:
1573:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1574:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1575:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @}
1576:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1577:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1578:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /** @defgroup RCC_Group4 Interrupts and flags management functions
1579:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  *  @brief   Interrupts and flags management functions 
1580:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  *
1581:.\StdPeriphLib\src/stm32f0xx_rcc.c **** @verbatim
1582:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  ===============================================================================
1583:.\StdPeriphLib\src/stm32f0xx_rcc.c ****              ##### Interrupts and flags management functions #####
1584:.\StdPeriphLib\src/stm32f0xx_rcc.c ****  ===============================================================================
1585:.\StdPeriphLib\src/stm32f0xx_rcc.c **** @endverbatim
1586:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @{
1587:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1588:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1589:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1590:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Enables or disables the specified RCC interrupts.
1591:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @note   The CSS interrupt doesn't have an enable bit; once the CSS is enabled
1592:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         and if the HSE clock fails, the CSS interrupt occurs and an NMI is
1593:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         automatically generated. The NMI will be executed indefinitely, and 
1594:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         since NMI has higher priority than any other IRQ (and main program)
1595:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         the application will be stacked in the NMI ISR unless the CSS interrupt
1596:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         pending bit is cleared.
1597:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
1598:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be any combination of the following values:
1599:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *              @arg RCC_IT_LSIRDY: LSI ready interrupt
1600:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *              @arg RCC_IT_LSERDY: LSE ready interrupt
1601:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *              @arg RCC_IT_HSIRDY: HSI ready interrupt
1602:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *              @arg RCC_IT_HSERDY: HSE ready interrupt
1603:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *              @arg RCC_IT_PLLRDY: PLL ready interrupt
1604:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *              @arg RCC_IT_HSI14RDY: HSI14 ready interrupt
1605:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *              @arg RCC_IT_HSI48RDY: HSI48 ready interrupt, applicable only for STM32F072 devices
1606:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  NewState: new state of the specified RCC interrupts.
1607:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be: ENABLE or DISABLE.
1608:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
1609:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1610:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
1611:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 1735              		.loc 1 1611 0
 1736              		.cfi_startproc
 1737              	.LVL127:
1612:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
1613:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_IT(RCC_IT));
1614:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1615:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
1616:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (NewState != DISABLE)
 1738              		.loc 1 1616 0
 1739 0000 0029     		cmp	r1, #0
 1740 0002 04D0     		beq	.L170
1617:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1618:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
1619:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     *(__IO uint8_t *) CIR_BYTE1_ADDRESS |= RCC_IT;
 1741              		.loc 1 1619 0
 1742 0004 044B     		ldr	r3, .L172
 1743 0006 1A78     		ldrb	r2, [r3]
 1744 0008 1043     		orr	r0, r2
 1745              	.LVL128:
 1746 000a 1870     		strb	r0, [r3]
 1747 000c 03E0     		b	.L169
 1748              	.LVL129:
 1749              	.L170:
1620:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1621:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1622:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1623:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     /* Perform Byte access to RCC_CIR[13:8] bits to disable the selected interrupts */
1624:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     *(__IO uint8_t *) CIR_BYTE1_ADDRESS &= (uint8_t)~RCC_IT;
 1750              		.loc 1 1624 0
 1751 000e 024A     		ldr	r2, .L172
 1752 0010 1378     		ldrb	r3, [r2]
 1753 0012 8343     		bic	r3, r0
 1754 0014 1370     		strb	r3, [r2]
 1755              	.LVL130:
 1756              	.L169:
1625:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1626:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1757              		.loc 1 1626 0
 1758              		@ sp needed
 1759 0016 7047     		bx	lr
 1760              	.L173:
 1761              		.align	2
 1762              	.L172:
 1763 0018 09100240 		.word	1073877001
 1764              		.cfi_endproc
 1765              	.LFE69:
 1767              		.section	.text.RCC_GetFlagStatus,"ax",%progbits
 1768              		.align	2
 1769              		.global	RCC_GetFlagStatus
 1770              		.code	16
 1771              		.thumb_func
 1773              	RCC_GetFlagStatus:
 1774              	.LFB70:
1627:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1628:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1629:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Checks whether the specified RCC flag is set or not.
1630:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_FLAG: specifies the flag to check.
1631:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
1632:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready  
1633:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
1634:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_PLLRDY: PLL clock ready
1635:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
1636:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
1637:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_OBLRST: Option Byte Loader (OBL) reset 
1638:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_PINRST: Pin reset
1639:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_V18PWRRSTF:  V1.8 power domain reset  
1640:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_PORRST: POR/PDR reset
1641:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_SFTRST: Software reset
1642:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
1643:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_WWDGRST: Window Watchdog reset
1644:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_LPWRRST: Low Power reset
1645:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_HSI14RDY: HSI14 oscillator clock ready
1646:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_FLAG_HSI48RDY: HSI48 oscillator clock ready, applicable only for STM32F072
1647:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval The new state of RCC_FLAG (SET or RESET).
1648:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1649:.\StdPeriphLib\src/stm32f0xx_rcc.c **** FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
1650:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 1775              		.loc 1 1650 0
 1776              		.cfi_startproc
 1777              	.LVL131:
1651:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   uint32_t tmp = 0;
1652:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   uint32_t statusreg = 0;
1653:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   FlagStatus bitstatus = RESET;
1654:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1655:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
1656:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_FLAG(RCC_FLAG));
1657:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1658:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Get the RCC register index */
1659:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmp = RCC_FLAG >> 5;
 1778              		.loc 1 1659 0
 1779 0000 4309     		lsr	r3, r0, #5
 1780              	.LVL132:
1660:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1661:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if (tmp == 0)               /* The flag to check is in CR register */
 1781              		.loc 1 1661 0
 1782 0002 02D1     		bne	.L175
1662:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1663:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     statusreg = RCC->CR;
 1783              		.loc 1 1663 0
 1784 0004 0A4B     		ldr	r3, .L179
 1785              	.LVL133:
 1786 0006 1B68     		ldr	r3, [r3]
 1787              	.LVL134:
 1788 0008 0BE0     		b	.L176
 1789              	.LVL135:
 1790              	.L175:
1664:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1665:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else if (tmp == 1)          /* The flag to check is in BDCR register */
 1791              		.loc 1 1665 0
 1792 000a 012B     		cmp	r3, #1
 1793 000c 02D1     		bne	.L177
1666:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1667:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     statusreg = RCC->BDCR;
 1794              		.loc 1 1667 0
 1795 000e 084B     		ldr	r3, .L179
 1796              	.LVL136:
 1797 0010 1B6A     		ldr	r3, [r3, #32]
 1798              	.LVL137:
 1799 0012 06E0     		b	.L176
 1800              	.LVL138:
 1801              	.L177:
1668:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1669:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else if (tmp == 2)          /* The flag to check is in CSR register */
 1802              		.loc 1 1669 0
 1803 0014 022B     		cmp	r3, #2
 1804 0016 02D1     		bne	.L178
1670:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1671:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     statusreg = RCC->CSR;
 1805              		.loc 1 1671 0
 1806 0018 054B     		ldr	r3, .L179
 1807              	.LVL139:
 1808 001a 5B6A     		ldr	r3, [r3, #36]
 1809              	.LVL140:
 1810 001c 01E0     		b	.L176
 1811              	.LVL141:
 1812              	.L178:
1672:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1673:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else                        /* The flag to check is in CR2 register */
1674:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1675:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     statusreg = RCC->CR2;
 1813              		.loc 1 1675 0
 1814 001e 044B     		ldr	r3, .L179
 1815              	.LVL142:
 1816 0020 5B6B     		ldr	r3, [r3, #52]
 1817              	.LVL143:
 1818              	.L176:
1676:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }    
1677:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1678:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Get the flag position */
1679:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   tmp = RCC_FLAG & FLAG_MASK;
1680:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1681:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 1819              		.loc 1 1681 0
 1820 0022 1F22     		mov	r2, #31
 1821 0024 1040     		and	r0, r2
 1822              	.LVL144:
 1823 0026 C340     		lsr	r3, r3, r0
 1824              	.LVL145:
 1825 0028 181C     		mov	r0, r3
1682:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1683:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     bitstatus = SET;
1684:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1685:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1686:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1687:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     bitstatus = RESET;
1688:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1689:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Return the flag status */
1690:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   return bitstatus;
 1826              		.loc 1 1690 0
 1827 002a 0123     		mov	r3, #1
 1828 002c 1840     		and	r0, r3
1691:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1829              		.loc 1 1691 0
 1830              		@ sp needed
 1831 002e 7047     		bx	lr
 1832              	.L180:
 1833              		.align	2
 1834              	.L179:
 1835 0030 00100240 		.word	1073876992
 1836              		.cfi_endproc
 1837              	.LFE70:
 1839              		.section	.text.RCC_WaitForHSEStartUp,"ax",%progbits
 1840              		.align	2
 1841              		.global	RCC_WaitForHSEStartUp
 1842              		.code	16
 1843              		.thumb_func
 1845              	RCC_WaitForHSEStartUp:
 1846              	.LFB35:
 228:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   __IO uint32_t StartUpCounter = 0;
 1847              		.loc 1 228 0
 1848              		.cfi_startproc
 1849 0000 10B5     		push	{r4, lr}
 1850              	.LCFI2:
 1851              		.cfi_def_cfa_offset 8
 1852              		.cfi_offset 4, -8
 1853              		.cfi_offset 14, -4
 1854 0002 82B0     		sub	sp, sp, #8
 1855              	.LCFI3:
 1856              		.cfi_def_cfa_offset 16
 229:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   ErrorStatus status = ERROR;
 1857              		.loc 1 229 0
 1858 0004 0023     		mov	r3, #0
 1859 0006 0193     		str	r3, [sp, #4]
 1860              	.LVL146:
 238:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 1861              		.loc 1 238 0
 1862 0008 A024     		mov	r4, #160
 1863 000a E401     		lsl	r4, r4, #7
 1864              	.LVL147:
 1865              	.L183:
 236:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     StartUpCounter++;  
 1866              		.loc 1 236 0 discriminator 2
 1867 000c 1120     		mov	r0, #17
 1868 000e FFF7FEFF 		bl	RCC_GetFlagStatus
 1869              	.LVL148:
 237:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 1870              		.loc 1 237 0 discriminator 2
 1871 0012 019B     		ldr	r3, [sp, #4]
 1872 0014 0133     		add	r3, r3, #1
 1873 0016 0193     		str	r3, [sp, #4]
 238:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 1874              		.loc 1 238 0 discriminator 2
 1875 0018 019B     		ldr	r3, [sp, #4]
 1876 001a A342     		cmp	r3, r4
 1877 001c 01D0     		beq	.L182
 238:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
 1878              		.loc 1 238 0 is_stmt 0 discriminator 1
 1879 001e 0028     		cmp	r0, #0
 1880 0020 F4D0     		beq	.L183
 1881              	.L182:
 240:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
 1882              		.loc 1 240 0 is_stmt 1
 1883 0022 1120     		mov	r0, #17
 1884              	.LVL149:
 1885 0024 FFF7FEFF 		bl	RCC_GetFlagStatus
 1886              	.LVL150:
 1887 0028 431E     		sub	r3, r0, #1
 1888 002a 9841     		sbc	r0, r0, r3
 1889              	.LVL151:
 248:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1890              		.loc 1 248 0
 1891 002c C0B2     		uxtb	r0, r0
 249:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
 1892              		.loc 1 249 0
 1893 002e 02B0     		add	sp, sp, #8
 1894              		@ sp needed
 1895 0030 10BD     		pop	{r4, pc}
 1896              		.cfi_endproc
 1897              	.LFE35:
 1899 0032 C046     		.section	.text.RCC_ClearFlag,"ax",%progbits
 1900              		.align	2
 1901              		.global	RCC_ClearFlag
 1902              		.code	16
 1903              		.thumb_func
 1905              	RCC_ClearFlag:
 1906              	.LFB71:
1692:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1693:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1694:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Clears the RCC reset flags.
1695:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         The reset flags are: RCC_FLAG_OBLRST, RCC_FLAG_PINRST, RCC_FLAG_V18PWRRSTF,
1696:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         RCC_FLAG_PORRST, RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST,
1697:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *         RCC_FLAG_LPWRRST.
1698:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  None
1699:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
1700:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1701:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_ClearFlag(void)
1702:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 1907              		.loc 1 1702 0
 1908              		.cfi_startproc
1703:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Set RMVF bit to clear the reset flags */
1704:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   RCC->CSR |= RCC_CSR_RMVF;
 1909              		.loc 1 1704 0
 1910 0000 034A     		ldr	r2, .L186
 1911 0002 536A     		ldr	r3, [r2, #36]
 1912 0004 8021     		mov	r1, #128
 1913 0006 4904     		lsl	r1, r1, #17
 1914 0008 0B43     		orr	r3, r1
 1915 000a 5362     		str	r3, [r2, #36]
1705:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1916              		.loc 1 1705 0
 1917              		@ sp needed
 1918 000c 7047     		bx	lr
 1919              	.L187:
 1920 000e C046     		.align	2
 1921              	.L186:
 1922 0010 00100240 		.word	1073876992
 1923              		.cfi_endproc
 1924              	.LFE71:
 1926              		.section	.text.RCC_GetITStatus,"ax",%progbits
 1927              		.align	2
 1928              		.global	RCC_GetITStatus
 1929              		.code	16
 1930              		.thumb_func
 1932              	RCC_GetITStatus:
 1933              	.LFB72:
1706:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1707:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1708:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Checks whether the specified RCC interrupt has occurred or not.
1709:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_IT: specifies the RCC interrupt source to check.
1710:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be one of the following values:
1711:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_LSIRDY: LSI ready interrupt
1712:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_LSERDY: LSE ready interrupt
1713:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_HSIRDY: HSI ready interrupt
1714:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_HSERDY: HSE ready interrupt
1715:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_PLLRDY: PLL ready interrupt
1716:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_HSI14RDY: HSI14 ready interrupt
1717:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_HSI48RDY: HSI48 ready interrupt, applicable only for STM32F072 devices 
1718:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_CSS: Clock Security System interrupt
1719:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval The new state of RCC_IT (SET or RESET).
1720:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1721:.\StdPeriphLib\src/stm32f0xx_rcc.c **** ITStatus RCC_GetITStatus(uint8_t RCC_IT)
1722:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 1934              		.loc 1 1722 0
 1935              		.cfi_startproc
 1936              	.LVL152:
1723:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   ITStatus bitstatus = RESET;
1724:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
1725:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
1726:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_GET_IT(RCC_IT));
1727:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
1728:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the status of the specified RCC interrupt */
1729:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 1937              		.loc 1 1729 0
 1938 0000 034B     		ldr	r3, .L189
 1939 0002 9B68     		ldr	r3, [r3, #8]
 1940              	.LVL153:
 1941 0004 1840     		and	r0, r3
 1942              	.LVL154:
 1943 0006 431E     		sub	r3, r0, #1
 1944 0008 9841     		sbc	r0, r0, r3
 1945              	.LVL155:
1730:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1731:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     bitstatus = SET;
1732:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1733:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   else
1734:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   {
1735:.\StdPeriphLib\src/stm32f0xx_rcc.c ****     bitstatus = RESET;
1736:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   }
1737:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Return the RCC_IT status */
1738:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   return  bitstatus;
 1946              		.loc 1 1738 0
 1947 000a C0B2     		uxtb	r0, r0
1739:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1948              		.loc 1 1739 0
 1949              		@ sp needed
 1950 000c 7047     		bx	lr
 1951              	.L190:
 1952 000e C046     		.align	2
 1953              	.L189:
 1954 0010 00100240 		.word	1073876992
 1955              		.cfi_endproc
 1956              	.LFE72:
 1958              		.section	.text.RCC_ClearITPendingBit,"ax",%progbits
 1959              		.align	2
 1960              		.global	RCC_ClearITPendingBit
 1961              		.code	16
 1962              		.thumb_func
 1964              	RCC_ClearITPendingBit:
 1965              	.LFB73:
1740:.\StdPeriphLib\src/stm32f0xx_rcc.c **** 
1741:.\StdPeriphLib\src/stm32f0xx_rcc.c **** /**
1742:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @brief  Clears the RCC's interrupt pending bits.
1743:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @param  RCC_IT: specifies the interrupt pending bit to clear.
1744:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *          This parameter can be any combination of the following values:
1745:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_LSIRDY: LSI ready interrupt
1746:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_LSERDY: LSE ready interrupt
1747:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_HSIRDY: HSI ready interrupt
1748:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_HSERDY: HSE ready interrupt
1749:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_PLLRDY: PLL ready interrupt
1750:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_HSI48RDY: HSI48 ready interrupt, applicable only for STM32F072 devices 
1751:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_HSI14RDY: HSI14 ready interrupt
1752:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *             @arg RCC_IT_CSS: Clock Security System interrupt
1753:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   * @retval None
1754:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   */
1755:.\StdPeriphLib\src/stm32f0xx_rcc.c **** void RCC_ClearITPendingBit(uint8_t RCC_IT)
1756:.\StdPeriphLib\src/stm32f0xx_rcc.c **** {
 1966              		.loc 1 1756 0
 1967              		.cfi_startproc
 1968              	.LVL156:
1757:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Check the parameters */
1758:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   assert_param(IS_RCC_CLEAR_IT(RCC_IT));
1759:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   
1760:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
1761:.\StdPeriphLib\src/stm32f0xx_rcc.c ****      pending bits */
1762:.\StdPeriphLib\src/stm32f0xx_rcc.c ****   *(__IO uint8_t *) CIR_BYTE2_ADDRESS = RCC_IT;
 1969              		.loc 1 1762 0
 1970 0000 014B     		ldr	r3, .L192
 1971 0002 1870     		strb	r0, [r3]
1763:.\StdPeriphLib\src/stm32f0xx_rcc.c **** }
 1972              		.loc 1 1763 0
 1973              		@ sp needed
 1974 0004 7047     		bx	lr
 1975              	.L193:
 1976 0006 C046     		.align	2
 1977              	.L192:
 1978 0008 0A100240 		.word	1073877002
 1979              		.cfi_endproc
 1980              	.LFE73:
 1982              		.section	.data.APBAHBPrescTable,"aw",%progbits
 1983              		.align	2
 1984              		.set	.LANCHOR0,. + 0
 1987              	APBAHBPrescTable:
 1988 0000 00       		.byte	0
 1989 0001 00       		.byte	0
 1990 0002 00       		.byte	0
 1991 0003 00       		.byte	0
 1992 0004 01       		.byte	1
 1993 0005 02       		.byte	2
 1994 0006 03       		.byte	3
 1995 0007 04       		.byte	4
 1996 0008 01       		.byte	1
 1997 0009 02       		.byte	2
 1998 000a 03       		.byte	3
 1999 000b 04       		.byte	4
 2000 000c 06       		.byte	6
 2001 000d 07       		.byte	7
 2002 000e 08       		.byte	8
 2003 000f 09       		.byte	9
 2004              		.text
 2005              	.Letext0:
 2006              		.file 2 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 2007              		.file 3 "c:\\myprograms\\sublime text build 3126\\gnu tools arm embedded\\arm-none-eabi\\include\\
 2008              		.file 4 ".\\CMSIS/stm32f0xx.h"
 2009              		.file 5 ".\\StdPeriphLib\\inc/stm32f0xx_rcc.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f0xx_rcc.c
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:18     .text.RCC_DeInit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:23     .text.RCC_DeInit:00000000 RCC_DeInit
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:77     .text.RCC_DeInit:00000048 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:87     .text.RCC_HSEConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:92     .text.RCC_HSEConfig:00000000 RCC_HSEConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:109    .text.RCC_HSEConfig:0000000c $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:114    .text.RCC_AdjustHSICalibrationValue:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:119    .text.RCC_AdjustHSICalibrationValue:00000000 RCC_AdjustHSICalibrationValue
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:145    .text.RCC_AdjustHSICalibrationValue:00000010 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:150    .text.RCC_HSICmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:155    .text.RCC_HSICmd:00000000 RCC_HSICmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:184    .text.RCC_HSICmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:189    .text.RCC_AdjustHSI14CalibrationValue:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:194    .text.RCC_AdjustHSI14CalibrationValue:00000000 RCC_AdjustHSI14CalibrationValue
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:220    .text.RCC_AdjustHSI14CalibrationValue:00000010 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:225    .text.RCC_HSI14Cmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:230    .text.RCC_HSI14Cmd:00000000 RCC_HSI14Cmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:259    .text.RCC_HSI14Cmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:264    .text.RCC_HSI14ADCRequestCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:269    .text.RCC_HSI14ADCRequestCmd:00000000 RCC_HSI14ADCRequestCmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:298    .text.RCC_HSI14ADCRequestCmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:303    .text.RCC_LSEConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:308    .text.RCC_LSEConfig:00000000 RCC_LSEConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:335    .text.RCC_LSEConfig:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:340    .text.RCC_LSEDriveConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:345    .text.RCC_LSEDriveConfig:00000000 RCC_LSEDriveConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:367    .text.RCC_LSEDriveConfig:00000014 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:372    .text.RCC_LSICmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:377    .text.RCC_LSICmd:00000000 RCC_LSICmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:406    .text.RCC_LSICmd:0000001c $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:411    .text.RCC_PLLConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:416    .text.RCC_PLLConfig:00000000 RCC_PLLConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:445    .text.RCC_PLLConfig:00000018 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:451    .text.RCC_PLLCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:456    .text.RCC_PLLCmd:00000000 RCC_PLLCmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:486    .text.RCC_PLLCmd:00000020 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:492    .text.RCC_HSI48Cmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:497    .text.RCC_HSI48Cmd:00000000 RCC_HSI48Cmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:527    .text.RCC_HSI48Cmd:00000020 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:533    .text.RCC_PREDIV1Config:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:538    .text.RCC_PREDIV1Config:00000000 RCC_PREDIV1Config
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:562    .text.RCC_PREDIV1Config:00000010 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:567    .text.RCC_ClockSecuritySystemCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:572    .text.RCC_ClockSecuritySystemCmd:00000000 RCC_ClockSecuritySystemCmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:602    .text.RCC_ClockSecuritySystemCmd:00000020 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:608    .text.RCC_MCOConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:613    .text.RCC_MCOConfig:00000000 RCC_MCOConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:641    .text.RCC_MCOConfig:00000014 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:646    .text.RCC_SYSCLKConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:651    .text.RCC_SYSCLKConfig:00000000 RCC_SYSCLKConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:675    .text.RCC_SYSCLKConfig:00000010 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:680    .text.RCC_GetSYSCLKSource:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:685    .text.RCC_GetSYSCLKSource:00000000 RCC_GetSYSCLKSource
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:700    .text.RCC_GetSYSCLKSource:0000000c $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:705    .text.RCC_HCLKConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:710    .text.RCC_HCLKConfig:00000000 RCC_HCLKConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:734    .text.RCC_HCLKConfig:00000010 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:739    .text.RCC_PCLKConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:744    .text.RCC_PCLKConfig:00000000 RCC_PCLKConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:768    .text.RCC_PCLKConfig:00000010 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:774    .text.RCC_ADCCLKConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:779    .text.RCC_ADCCLKConfig:00000000 RCC_ADCCLKConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:813    .text.RCC_ADCCLKConfig:00000028 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:820    .text.RCC_CECCLKConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:825    .text.RCC_CECCLKConfig:00000000 RCC_CECCLKConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:847    .text.RCC_CECCLKConfig:00000014 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:852    .text.RCC_I2CCLKConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:857    .text.RCC_I2CCLKConfig:00000000 RCC_I2CCLKConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:879    .text.RCC_I2CCLKConfig:00000014 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:884    .text.RCC_USARTCLKConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:889    .text.RCC_USARTCLKConfig:00000000 RCC_USARTCLKConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:943    .text.RCC_USARTCLKConfig:00000038 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:950    .text.RCC_USBCLKConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:955    .text.RCC_USBCLKConfig:00000000 RCC_USBCLKConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:977    .text.RCC_USBCLKConfig:00000014 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:983    .text.RCC_GetClocksFreq:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:988    .text.RCC_GetClocksFreq:00000000 RCC_GetClocksFreq
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1368   .text.RCC_GetClocksFreq:000001d0 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1379   .text.RCC_RTCCLKConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1384   .text.RCC_RTCCLKConfig:00000000 RCC_RTCCLKConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1401   .text.RCC_RTCCLKConfig:0000000c $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1406   .text.RCC_RTCCLKCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1411   .text.RCC_RTCCLKCmd:00000000 RCC_RTCCLKCmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1441   .text.RCC_RTCCLKCmd:00000020 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1447   .text.RCC_BackupResetCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1452   .text.RCC_BackupResetCmd:00000000 RCC_BackupResetCmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1482   .text.RCC_BackupResetCmd:00000020 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1488   .text.RCC_AHBPeriphClockCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1493   .text.RCC_AHBPeriphClockCmd:00000000 RCC_AHBPeriphClockCmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1523   .text.RCC_AHBPeriphClockCmd:00000018 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1528   .text.RCC_APB2PeriphClockCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1533   .text.RCC_APB2PeriphClockCmd:00000000 RCC_APB2PeriphClockCmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1563   .text.RCC_APB2PeriphClockCmd:00000018 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1568   .text.RCC_APB1PeriphClockCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1573   .text.RCC_APB1PeriphClockCmd:00000000 RCC_APB1PeriphClockCmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1603   .text.RCC_APB1PeriphClockCmd:00000018 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1608   .text.RCC_AHBPeriphResetCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1613   .text.RCC_AHBPeriphResetCmd:00000000 RCC_AHBPeriphResetCmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1643   .text.RCC_AHBPeriphResetCmd:00000018 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1648   .text.RCC_APB2PeriphResetCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1653   .text.RCC_APB2PeriphResetCmd:00000000 RCC_APB2PeriphResetCmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1683   .text.RCC_APB2PeriphResetCmd:00000018 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1688   .text.RCC_APB1PeriphResetCmd:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1693   .text.RCC_APB1PeriphResetCmd:00000000 RCC_APB1PeriphResetCmd
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1723   .text.RCC_APB1PeriphResetCmd:00000018 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1728   .text.RCC_ITConfig:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1733   .text.RCC_ITConfig:00000000 RCC_ITConfig
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1763   .text.RCC_ITConfig:00000018 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1768   .text.RCC_GetFlagStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1773   .text.RCC_GetFlagStatus:00000000 RCC_GetFlagStatus
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1835   .text.RCC_GetFlagStatus:00000030 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1840   .text.RCC_WaitForHSEStartUp:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1845   .text.RCC_WaitForHSEStartUp:00000000 RCC_WaitForHSEStartUp
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1900   .text.RCC_ClearFlag:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1905   .text.RCC_ClearFlag:00000000 RCC_ClearFlag
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1922   .text.RCC_ClearFlag:00000010 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1927   .text.RCC_GetITStatus:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1932   .text.RCC_GetITStatus:00000000 RCC_GetITStatus
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1954   .text.RCC_GetITStatus:00000010 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1959   .text.RCC_ClearITPendingBit:00000000 $t
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1964   .text.RCC_ClearITPendingBit:00000000 RCC_ClearITPendingBit
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1978   .text.RCC_ClearITPendingBit:00000008 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1983   .data.APBAHBPrescTable:00000000 $d
C:\Users\Dima\AppData\Local\Temp\cckDsoZC.s:1987   .data.APBAHBPrescTable:00000000 APBAHBPrescTable
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_uidiv
